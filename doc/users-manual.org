Beancount User's Manual
* Introduction

This is a user's manual to Beancount, a double-entry bookkeeping system. In it,
we introduce the basic princples of double-entry bookkeeping from first
principles and go on to explain how to use Beancount to keep track of a ledger,
as a professional accountant would..

Beancount provides a computer language that allows you to enter all your
transactions in a text file and a web interface that renders, a balance sheet,
an income statement, and more, for various subsets of your transactions (views).
It works with an any and multiple currencies and even allows you to track
unusual things, like vacation hours, airmiles and rewards points, and anything
else, really.


* Motivation
** Why build a computer language?

A bookkeeping system provides conditions for a solution that involves a simple
computer language for many reasons.

Single-entry bookkeeping is largely insufficient if you're trying to track
everything holistically. Existing systems either limit themselves to expense
categories with little checking beyond "reconciling" which sometimes involves
freezing the past. If you're not doign the bookkeeping for a company, sometimes
just changing the past and fixing the mistakes where they occurred makes more
sense. More importantly, the single-entry mthod leaves us wanting for the
natural error-checking mechanism involved in the double-entry system.

The problem is also not solvable elegantly by using spreadsheets; the simple
data structure that forms the basis of the double-entry system infers either a
very sparse spreadsheet with accounts on one dimension and transactions on the
other. For real-world usage, this is impractical. Another iteration on this
theme would involve inserting the postings with two columns, one with the
account and one with the amount, but the varying number of columns and the
lookup code makes this inelegant as well. Plus, it's not obvious how you would
deal with a large number of currencies.

Programs that provide fancy graphical or web-based user interfaces are
inevitably awkward, due to the nature of the problem: each transaction is
organized by viewing it through the lens of one account's journal, but any of
the accounts present in its postings provide equally valid views. Ideally, what
you want, is just to look at the transaction. Organizing them for most
convenient input has little to do with the order in which they are to be
presented. Using text has a lot of advantages:

- You can easily used search-and-replace and/or sed to make global changes, for
  example, rename or reorganize your accounts;

- You can organize the transactions in the order that is most convenient for
  data entry;

- There are a number of existing tools to search the text;

- You can easily write various little tools to spit out the data syntax, i.e.,
  for importing from other file types, or converting from other systems.

- Text is inherently *open*, that is the file format is one that you can read
  your data from and store anywhere else, not a binary blob that becomes
  obsolete when the company that makes the software stops supporting it.

Finally, systems that attempt to automate the process of importing all your data
from automated sources (e.g., mint.com) have one major shortfall: most often
it's not very easy to add information for accounts that aren't automated. It is
my experience that in practice you will have some entries and account to track
that will not have a nice downloadable file format, or that simply don't have a
real-world counterpart. In order to produce a complete view of one's balance
sheet, it is important to be able to enter all of an individual's account within
a single system. In other words, custom accounts and manually entered
transactions do matter a lot.

For all the reasons mentioned above, we feel that a computer language is more
appropriate to express this data structure than a heavy piece of software with a
customized interface. Being able to easily bring up a text file and quickly type
in a few lines of text to add a transaction is great--it's fast and easy. The
ledger file provides a naturally open way to express one's data, and can be
source-controlled or shared between people as well. Multiple files can be merged
together, and scripted manipulations on a source file can be used to reorganize
one's data history. Furthermore, a read-only web interface that presents the
various reports one expects and allows the user to explore different views on
the dataset is sufficient for the purpose of viewing the data.


** File Format or Input Language?

Now, one may wonder where this is a computer language or a data format. After
all, the problem we're trying to solve is essentially that of creating a
transactions to postings to accounts data structure.

One should ask: what is the difference between a data file format and a
simple declarative computer language? I think the distinction is made by who is
the intended writer of this file; is it a human? or is it a computer?
If the intended writer is a human, I file the format under the computer
language rubric.

The thing is, ledger files are meant to be manicured by a human, at least
briefly eyeballed. While we are trying to automate as much of this process as
possible--well, the unpleasant bits, anyway--we do want to insure that we
review all the new transactions that we're adding to the ledger in order to
ensure correctness.


** Credits & History

John Wiegley's Ledger was the inspiration for the first version of Beancount.
His system is where much of the original ideas for this system came from. When I
first learned about double-entry bookkeeping and realized that it could be the
perfect method to solve many of the tracking problems I was having in counting
various installments for my company, and after a quick disappointment in the
solutions that were available at the time (including GnuCash, which I could
break very easily), I was quickly led to the Ledger website. There, John laid
out his vision for a text-based system, in particular, the idea of doing away
with credits and debits and just the signs, and the basics of a convenient input
syntax which allows you to omit the amount of one of the postings. I got really
excited and had various enthusiastic discussions with him about Ledger and how I
wanted to use it. There was some cross-pollination of ideas and John was very
receptive to proposals for adding new features.

I was so intensely curious about bookkeeping that I began writing a Python
interface to Ledger. But in the end I found myself rewriting the entire thing in
Python--not for dislike of Ledger but rather because it was simple enough that I
could do most of it in little time, and immediately add some features I thought
would be useful. One reason for doing so was that instead of parsing the input
file every time and generate one report to the console, I would parse it once
and then serve the various reports from the in-memory database of transactions,
requested via a web page. Therefore, I did not need processing speed, so having
to use C++ for performance reasons was not necessary anymore, and I chose to
just stick with a dynamic language, which allowed me to add many features
quickly. This became Beancount version 1, which stood on its own and evolved its
own set of experimental features.

My dream was to be able to quickly and easily manipulate these transaction
objects to get various views and breakdowns of the data. I don't think the first
implementation pushed the limits far enough, however; the code was substandard,
to be honest--I wrote it really quickly--and making modifications to the system
was awkward. In particular, the way I originally implemented the tracking of
capital gains was inelegant and involved some manual counting. I was unhappy
with this, but it worked. It was also using ugly ad-hoc parser code in order to
remain reasonably compatible with Ledger syntax--I thought it would be
interesting to be able to share some common input syntax and use either system
for validation and maybe even to convert between them--and that made me weary of
making modifications to the syntax to evolve new features, so it stabilized for
a few years and I lost interest in adding new features.

But it was correct and it worked, mostly, so I used the system continuously from
2008 to 2013 to manage my own personal finances, my company's finances, and
joint property with my wife, with detailed transactions; this was great. I
learned a lot about how to keep books during that time (the examples section of
this document is meant to help you do the same). In the summer of 2013, I had an
epiphany and realized a correct and generalizable way to implement capital
gains, how to merged the tracking of positions held at a cost and regular
positions, and a set of simple rules for carrying out operations on them
sensibly (the design of how inventories work). I also saw a better way to factor
out the internal data structures, and decided to break from the constraint of
compatibility with Ledger and redesign the input syntax in order to parse the
input language using a lex/yacc generator, which would allow me to easily evolve
the input syntax without having to deal with parsing issues, and to create ports
to other languages more easily. In the process, a much simpler and more
consistent syntax emerged, and in a fit of sweat and a few intense weekends I
made re-implemented the entire thing from scratch, without even looking at the
previous version, clean-room. Beancount version 2 was born, much better than the
last, modular, and easy to extend.

The result is what I think is an elegant design involving a small set of
objects, a design that could easily be a basis for reimplementation in other
computer languages. This is described in the accompanying design doc, for those
who would have an interest in having a go at it (this would be welcome and I'm
expecting this will happen). While Ledger is a fascinating project ebullient
with complex ideas for expressing the problem of bookkeeping, the second version
of Beancount proposes a minimally simple design that leaves out any feature that
is not strictly necessary and aims at maximum usability through a simple web
interface and barely any command-line options. Ledger's syntax implements many
powerful features that trigger a lot of implicitly-defined behaviour; in
contrast, Beancount's design provides a less expressive, lower-level syntax but
one that closely matches the generated in-memory data structure, and thus is
perhaps more explicit in that way. I think both projects have strengths and
weaknesses.

Since I had more than 5 years worth of real-world usage experience with the
first version, I set myself a goal to remove all the features that I thought
weren't actually useful and introduced unnecessary complexity (like virtual
transactions, accounts not in the five groups, etc.), and to simplify the system
as much as possible without compromising on its usability. The result was a much
simpler to use and understand language and software, and the resulting data
structures and very simple to use, the processing more functional in nature, and
the internals of Beancount are very modular.

I separated out configuration directives used for importing and over many
iterations eventually figured out an elegant way to mostly automate imports and
automatically detect the various input files and convert them into my input
syntax. I also converted all my 6 years' worth of input data--thanks to some
very simple Python scripts to manipulate the file--and began using the new
version exclusively. It is now in a fully functional state, but I may have to
complete some documentation and examples. [2013-12-25]


** Design Goals

As people get interested in using this system, I will surely receive various
suggestions on improvements and proposed changes to the software. I have
different projects, and their goals and attitudes vary greatly; in this
particular project, I'm setting as an explicit goal to have the minimal set of
configurable options, and to evolve it to provide the best set of defaults that
will work for all users. I want to avoid adding configurable options at all
cost, and instead let that pressure improve the default behaviour.

Thus, by default I will resist making changes that aren't generic or that would
not work for other users. On the other hands, large-scale changes that would
generalize well are likely to be implemented. (One example of this is the
upcoming addition of average cost calculations for inventories.)


* Double-Entry Bookkeeping
** Bookkeeping vs. Accounting

The system described here is a language for "bookkeeping." It is important to
highlight where it fits in the various functions encompassed by the term
"accounting."  Accounting could imply:

- Tracking various assets, liabilities, incomes and expenses
- Generating various aggregated reports of these accounts, such as balance
  sheet, an income statement, an equity statement, and others.
- Managing payroll cycles, and invoicing of clients
- Calculating taxes and managing tax liabilities
- Dealing with complex equity structures and/or distributions (beyond tracking
  capital gains of equity investments)

Surely, there is more. This software limits itself to the first two: it provides
a way to track and count changes in various account types, and renders balaance
sheets, income statements, and other reports. It is essentially little more than
a fancy calculator that aggregates amounts in various buckets. The mechanics
involved in this are generic enough to apply to any situation.

In order to address the more specific scenarios required by the other functions
of accounting, it provides access to a very simple data structure so you can
write scripts to perform specialized tasks as required.


** What is Double-Entry Bookkeeping?

The double-entry system is a METHOD OF COUNTING. It is wonderfully simple, yet
provides an intrinsic means of error checking a user's data entry, and naturally
lends itself to producing reports that are consistent and sensible; this is
probably why firms use this system all over the world. The only principle
involved is that each change in an account has to be counter-balanced by an
equivalent amount of changes in other accounts. Everything else, and I mean all
the other principles involved, derive from that rule. In the following sections,
we will attempt to explain this system from first principles.

** Accounts Are Buckets that Count Things

Let's begin with a basic introduction to what we'll call an "Account." An
account is like a bucket that can contains "things," (let's call these things
"Currencies"), and has a history of the changes in its contents. Picture an
account as a vertical timeline, where time increases as you move down the line.
For instance, let's define an Account to track the contents of a real-world
bank checking account:

    "Checking"
        |
        |
        |
        |
        v

We will draw the current contents of an account as a square box, which we'll
call a "balance":

    "Checking"
        |
   +------------+
   | 743.23 USD |
   +------------+
        |
        v

The notation I've chosen above implies that the "Checking" account contains
743.23 units of a thing I called "USD" (I implicitly mean a US dollar here, but
Beancount support counting any kind of thing, really; let's stick with dollars
for now, because we're all familiar with money).

Every time there is a *change* in an account, we will picture that as a rounded
box on its timeline:

    "Checking"
        |
   +------------+
   | 743.23 USD |
   +------------+
        |
    ,----------.
   ( -36.84 USD )
    `----------'
        |
   +-------------+
   | 706.39  USD |
   +-------------+
        |
        v

We call such a change a "Posting" on an account. Notice how the newer balance is
the sum of a previous balance and postings in between them. An account opens
with an empty balance, so can now assert that an account's balance is the sum of
all its associated postings since it was opened.

** Fundamental Principle of the Double-Entry System

The principle of the double-entry system can be summarized succinctly:

  "Any change in an account must be counterbalanced by an equivalent change in
  other accounts."

The way we implement this, is by grouping postings (changes) within another
object which we will call a "Transaction":

    "Checking"
        |
   +------------+
   | 743.23 USD |
   +------------+      .===================.
        |             _|"Dinner with Sasha"|
    ,----------.     / `==================='
   ( -36.84 USD )___/
    `----------'
        |
   +-------------+
   | 706.39  USD |
   +-------------+
        |
        v

Now, let's complete the transaction to include one more leg with the inverse
amount. We will declare another account, which we label "Restaurants," to
contain this other posting:

    "Checking"                                    "Restaurants"
        |                                               |
   +------------+                                       |
   | 743.23 USD |                                       |
   +------------+      .===================.            |
        |             _|"Dinner with Sasha"|_           |
    ,----------.     / `===================' \     ,----------.
   ( -36.84 USD )___/                         \___( +36.84 USD )
    `----------'                                   `----------'
        |                                               |
   +-------------+                                      |
   | 706.39  USD |                                      |
   +-------------+                                      v
        |
        v

Now we have a Transaction that contains two Postings, and the sum of all
postings is zero. Each change is counterbalanced by the other. If all changes in
all accounts are to be inserted as part of Transactions, another way to state
the fundamental principle of double-entry bookkeeping is:

  "THE SUM OF ALL CHANGES IN THE POSTINGS OF A TRANSACTION HAS TO BE ZERO."

Beancount mainly provides a way to enter such Transactions, and spits out errors
when this fundamental rule is violated. An almost valid syntax to enter the set
of changes above is:

  2013-12-28 * "Dinner with Sasha"
    Checking        -36.84 USD
    Restaurants      36.84 USD

Note that all transactions occur on a date. In actuality, Accounts must be
placed in one of 5 categories, but that is really *only* used for organizing
reports; this will be introduced in a bit. I want to emphasize this here:

  All Accounts in Beancount work the same way: they just count things.
  There is no difference between any account, any which way we label them.


** The Structure of Transactions

Transactions do not have to contain only two postings, they can contain as many
as necessary. The principle does not change: the sum of all postings must equal
zero. Let's assume in the Transaction above that a tip of 5 dollars was added
to the bill, and that the bookkeeper wants to take account of these separately.
We can easily add a new account for tips:

    "Checking"                                    "Restaurants"       "Tips"
        |                                               |               |
   +------------+                                       |               |
   | 743.23 USD |                                       |               |
   +------------+      .===================.___________ | _________     |
        |             ,|"Dinner with Sasha"|.           |          \    |
    ,----------.     / `===================' \     ,----------.    ,----------.
   ( -36.84 USD )___/                         \___( +31.84 USD )  (  +5.00 USD )
    `----------'                                   `----------'    `----------'
        |                                               |               |
   +-------------+                               +-------------+   +-------------+
   | 706.39  USD |                               |  31.84 USD  |   |   5.00 USD  |
   +-------------+                               +-------------+   +-------------+
        |                                               |               |
        v                                               v               v

Now this transaction has 3 legs:

  2013-12-28 * "Dinner with Sasha"
    Checking        -36.84 USD
    Restaurants      31.84 USD
    Tips              5.00 USD

The sum is still zero.

The Transaction is the fundamental data structure involved in Beancount, and 99%
of all the directives you will write are Transaction entries.

For an example of a complex transaction with many legs, see the example on
booking salary payments later in this document.


** Account Types

Accounts can be created in order to track a wide variety of things. Accounts
will naturally be created for each "real world" account in various institutions,
e.g, bank accounts, credit card accounts, mortgage loan accounts, but also
virtual accounts for various kinds of expenses that you may have, e.g.
restaurants, sports, travel, transport, car, gas, etc. and various sources of
income, such as gross salary, taxable dividends, and deposit interest.

Note that this is an important difference between this and the single-entry
method: in a single-entry bookkeeping system, the counterpart of a posting in a
real world account is simply an "Expense Category," and the process of
integrating expenses reported from banks and credit card accounts only involve
attaching a category to each posting. In a double-entry system, that "category"
takes the for of an equivalently sized and opposite change in another account
that corresponds to this category. You can then make changes between any type of
account, not just real world accounts and categories, e.g., an intra-bank
transfer would have two postings, both of which would be associate with a
different Account corresponding to a real world account.

The granularity with which you choose to aggregate your amounts is a personal
choice. You can create as many Accounts are you need in Beancount, and they are
generally organized in a hierarchy, where parent accounts contain subaccounts,
recursively.

Now, imagine that we have a created a lot of these different accounts, and that
correspondingly, we have created a large number of Transaction objects to
reflect the changes within all of these accounts.

                           ...many many more...
 "Checking" "Savings" "CreditCard" ... "Restaurants" "Tips" "Flights" "Salary"
     |          |          |    ||||||||    |          |         |       |
     |          |          |    ||||||||    |          |         |       |
     |          |          |    ||||||||    |          |         |       |

We will label each of the accounts with one of five types. The first two types
of account are what we will call "balance sheet accounts," and they generally
correspond to accounts in the real world, which have some sort of total balance
that we care about:

1. Assets
2. Liablities

The balance of asset accounts is generally a positive number (something you
have), and the balance of a liability account generally negative (something you
owe). There is a third kind of balance sheet account, whose role we will explain
in detail later, in which you normally don't post transactions yourself:

3. Equity

The last two types of accounts are what we call "income statement accounts,"
and they often do not corresponds to accounts in the real world, but rather
to categories of changes that you are tracking, and are for transient changes,
that is, the sum total balance of these accounts will not be very relevant. We
will instead be interested in the sum total of changes that occur between two
dates. They are:

4. Income
5. Expenses

In summary, we have these five types of accounts:

1. Assets
2. Liabilities
3. Equity
4. Income
5. Expenses

In Beancount, any Account that you create must be of one of these types. The
way this constraint is applied, is by enforcing that each account is declared
as a subaccount of one of these root types. For example, the 7 accounts in the
previous example would be declared as:

  Assets:Checking
  Assets:Savings
  Liabilities:CreditCard
  Expenses:Restaurants
  Expenses:Tips
  Expenses:Flights
  Income:Salary

This introduces the syntax of how we refer to accounts: many capitalized words
separated by colons (:), where the first word is one of "Assets",
"Liabilities", "Equity", "Income", or "Expenses".

This is not optional; each of your accounts *must* live in one of those
categories. (A previous version of Beancount had support for custom account
roots, but this turned out to always be due to a mistake in how I was filing
transactions, there was always a better way that did not involve a custom
category; if you find yourself wanting for this kind of account, you're almost
certainly making a mistake in how you're thinking about your transaction. If
after trying really hard and consulting the "examples" section near the end of
this document you're still not convinced, you might consider using Ledger, as
Beancount enforces this on purpose and this will not change. We know custom
categories to be entirely unnecessary.)

Now, without loss of generality, we can reorder all the accounts that we
declared by how they're labeled, like this:

 "Assets"... "Liabilities"... "Equity"... "Income"... "Expenses"...
  ..........  ..........       ......      ..........  ..........
  ||||||||||  ||||||||||       ||||||      ||||||||||  ||||||||||
  ||||||||||  ||||||||||       ||||||      ||||||||||  ||||||||||
  ||||||||||  ||||||||||       ||||||      ||||||||||  ||||||||||

     "A"         "L"            "E"           "I"         "X"

Let's call the *sum* of all the balances at a specific date of all the "Assets"
accounts "A". We can do that same for all the other categories, the sum of all
the balances of all the accounts labeled "Expenses" is "X".

Now, we're ready to start looking at equivalences and define the various
statements that are in common use in accounting.


** Equilibrium & Equivalances

A corrollary of the fundamental principle of the double-entry system is that
since each of the Transactions balances to a sum of zero, the sum of all changes
from all Transactions across all accounts they affect also sums to a balance of
zero. This meants that:

- If we order the transactions chronologically, and draw a line at any point in
  time across all the accounts and sum all of their resulting balances, because
  all accounts had an initial balance of zero, after the changes in those
  transactions, the sum of all balances will still be zero.

- If we sum the changes of any subset of transactions across all of the accounts
  they affect, the sum will be zero as well.

By communutativity, we can then reorder and group the posting amounts by any
label that we choose. In particular, we can group the posting amounts by the
associated account types we just defined in the previous section. If we do this,
we know that the sum of all the account type sums is zero:

   A + L + E + I + X = 0

We could also zero out the Income and Expenses components (I + X) by inserting a
transaction that moves that sum into the Equity component (under an account we
will called "Retained Earnings" or "Net Income"), and obtain the following
equilibrium:

   NI = I + X

   A + L + E + (NI - NI) + I + X = 0
   A + L + (E + NI) + (-NI + I + X) = 0
   A + L + (E + NI) = 0
   A + L + E' = 0

This states that the sum of all Assets, Liabilities and Equity balances must be
zero, and will be a useful equation later on when we define the "balance sheet"
report.


** About Debits and Credits and the Signs of Amounts

If you already have some knowledge of accounting, at this point you have
probably noticed that we did not talk about credits and debits, nor have we
mentioned the notion of debitting or credit an account, nor have we
distinguished accounts in terms of being a "credit account" or a "debit
account." This is on purpose:  Beancount does away with this unnecessary
poo-pooin a clever way (which was introduced by John Wiegley's Ledger system):

- In Beancount, Accounts are not labeled as "credit accounts" nor "debit
  accounts"; we only have "accounts", and they all behave identically, which is
  nice;

- Postings to these accounts are also not labeled as "a credit", or "a debit,"
  (though you might want to use this confusing terminology if you're already
  used to it). In Beancount, debits to an account are simply negative numbers.
  There are only numbers that get added together.

This means that in Beancount, the usual balance of a Liabilities account will be
a negative number. Income and Equity are also usually negative numbers. The
burden of having to remember this is, in our opinion, a much lesser evil on the
mind than having to invert signs all over our system depending on the types of
account and how a change is posted to it. All you have to remember is the usual
signs of accounts (and this is very important):

  Assets      : positive
  Liabilities : negative
  Equity      : negative
  Income      : negative
  Expenses    : positive

For those unfamiliar with debits and credits, the idea is used in "normal"
accounting to deal with the fact that we tend to think of amounts and changes in
terms of positive numbers. In the usual account, all the numbers above are
positive. For instance, you will think of "a 150,000$ mortgage", and not a
-150,000$ liability. The problem with this is that a bookkeeper then has to be
incredibly careful when posting changes to accounts, because the meaning of a
change depends on the type of account... instead of imposing this burden on the
user, we take a computer scientist's approach and declare that for the sake of
simplicity, you should prefer simple sums.






FIXME: rewrite this to deal with the tranfer sign, as follows:

        A - L - E = 0
       (A' - L' - E') - (A - L - E) = I - X


    Because our system is not using debits and credits, and all the values are
    signed, we can simply sum all the account type sums. In accounting textbooks,
    you would find the signs inverted in hte equations; for instance:

       A - L - E + I - X = 0

    In traditional account, one would say that "Net Income" = Income - Expenses. In
    Beancount, we simply think of "Net Income" as the sum of Income + Expenses, but
    the Income happens to be a negative number.


** Tips to Remember the Signs

Now, it helps to think about the signs a bit more, to really get a sense for
why they're this way. Let's consider a simplified salary payment transaction:

  2013-12-31 * "Payment from Boogle Inc"
    Income:Boogle:Salary                       -5000 USD
    Assets:Checking                             3000 USD
    Expenses:Taxes:Federal                      1200 USD
    Expenses:Taxes:State                         800 USD

- The *income is a negative number* here, because it is an account that serves
  to keep track of how much "work" was given away in order to obtain the
  corresponding deposits in our asset account. You can imagine that from your
  perspective, you have a bucket containing *work potential* that you have, and
  by doing the work for Boogle Inc, you are giving away 5000 USD's worth of this
  work potential, so it is debited from that imaginary account (if you want it
  to get more real, try to conceive of the sum total of all the work you could
  perform until your death as being valued somehow). You gave away that work, a
  negative number, from your perspective.

- The *expense is a positive number*, because you "received" a paid amount on
  your gross salary. That might seem odd, since we often refer to expenses are
  *things we pay*, so initially one would think of it as a negative number.

  Actually, this taxe expense is actually received somewhere, filed by the
  employer, just that it is sent to the government to an account with your name
  on it, the amount of which will be used as already paid towards your tax
  calculation at the end of the year, so technically, you *have* this tax money
  on your name, it's a positive for you. (In fact, an alternative way to track
  this amount in paid taxes could be in an asset account that you would later on
  debit when you do file your taxes, but I think in practice it's more common to
  count it as an expense right away on each paycheck so that a mid-year balance
  sheet doesn't reflect it as something you have.)

If this is easier to understand, think of a restaurant transaction:

  2013-12-31 * "Dinner with Bob"
    Assets:Cash                             -25 USD
    Expenses:Restaurant                      25 USD

You've exchanged 25$ in cash for a meal. After dinner, you *have* this meal
sitting in your stomach. We don't count it as "1 MEAL", but as "25 USD's worth
of restaurant stuff."  But it's something you have.  And it's an expense and
not an asset, because it is transient: tomorrow, the meal is gone.


Now, as you get used to these signs, you will grow comfortable with it and this
will be a breeze. Another person reading your ledger might get confused,
however. In order to communicate reports with accountants and other external
users, we will provide an option to switch the signs in the reports produced by
Beancount. But the input syntax should always be signed, for simplicity. Trust
me, this is a lot simpler than having to think of credits and debits
everywhere... your head would explode.

Now, on to the reports.

** Reports
*** Income Statement Report

An "income statement" is a type of report that *aggregates changes* to accounts
labeled "Income" or "Expenses" due to Transactions occurring from a cetain date
to another date. It's a delta, changes from a snapshot of your balances. It
always applies to a period, which we sometimes call the "exercise period" or
"reporting period" for a firm, or for an individual this is typically a calendar
year, though a monthly report could be useful. Beancount can generate these
reports for any period desired. They are laid out like this:

   From: 2012-01-01 To: 2012-12-31
   +--------------+---------------+
   | Income       | Expenses      |
   |              |               |
   |              |               |
   |              |               |
   |              |               |
   |              |               |
   +--------------+---------------+
   | = I          | = X           |
   +--------------+---------------+
   | = I-X  = net income          |
   +------------------------------+

Changes in accounts before the beginning of the period are ignored; thus, you
can imagine that all these accounts begin with a balance of zero at the
beginning of the reporting period.

The final line contains the sum of all incomes minus the sum of all expenses and
is generally non-zero, because we're only considering changes in a subset of all
accounts. This is "how much money remains" after the exercise is complete, and
the origin of the expression: "the bottom line." In other words, this is what
really matters, how much you get to keep. In the next section, this amount will
be moved to a special account in the balance sheet report, called
Equity:RetainedEarnings, via an automatically inserted transaction that "closes
the year" by zeroing out the income statement accounts at the end of the period.


*** Balance Sheet Report

A "balance sheet" is a type of report that provides a *snapshot* of the balances
of all your accounts at a particular point in time. The report is usually laid
out in this way:

    As Of: 2013-01-01
   +--------------+---------------+
   | Assets       | Liabilities   |
   |              |               |
   |              |               |
   |              |               |
   |              |---------------|
   |              | Equity        |
   |              |               |
   |              |               |
   |              |               |
   +--------------+---------------+

Note that the Income and Expenses accounts do not show up on this report.
Because the balance sheet isn't designed to show transient changes (i.e.,
changes in Income and Expenses accounts), the net income from the income
statement has been reflected to an equity account on the balance sheet.

A common view of a set of transaction is the view of *a period*, typically of an
annual period. (Beancount provide such views from its root page.) This means
that there are two balance sheets to look at: the snapshot at the beginning of
the period, and a snapshot at the end of the period.

In Beancount, we call the period beginning snapshot the "Opening Balances"
report. The sum total of all previous Income and Expenses transactions before
the beginning of the period is moved to the balance sheet by a transaction that
puts this amount under a Equity:Earnings:Previous account. In addition, for
those period views, all the transactions in Assets and Liabilities accounts
before the beginning of the period are lumped together and replaced by a single
transaction that moves the amounts to an Equity:Opening-Balances account,
because we don't want the journals to display the detail of transactions and
postings before the beginning of the period.

The end-of-period snapshot is simply called the "Balance Sheet" report. For the
purposes of rendering the balance sheet, the sum total of postings to Income and
Expenses accounts occurring between the begin and end date of the period are
transferred to an Equity:Current account by an automatically inserted
transaction. (Note that the names of these accounts are configurable; see
options.)

You will note the signs of the Equity account in your reports are generally
negative. This is normal and expected. Think of the Equity account as something
from the past that you had to give up in order to obtain the beginning snapshot
of the Assets + Liabilities balance.


*** Journal, or Statements

A basic feature of the system is to render a view of all transactions from the
point of view of a single account. We call this a "journal" in Beancount (in
Ledger, this corresponds to the "register").

This view orders all the postings in an account chronologically, finds the
corresponding transactions, and renders a statement for that account. It is
analogous with a bank statement: there are two columns, one for the amount
posted (the change in the account), and one for the result balance.

Other directives are also rendered in the journal, such as balance checks
(succesful or failed), notes, and documents.


* Beancount Language Syntax
** Directives

Beancount is a declarative language. The input consist in a text file
containing a list of *directives*. The order of the directives is entirely
irrelevant (in fact, the entries are re-sorted chronologically after parsing).

Each directive begins with a date (all directives have an associated date), and
the second word defines which kind of directive it is. Thus, all directives
begin like this:

   YYYY-MM-DD <directive-name> ...something...

where YYYY is the year, MM is the numerical month, and DD the numerical date.
All digits are required (we use ISO8601 format, and only this one).
<directive-name> declares the kind of directive. For example, a directive to
open an account parses like this:

  2013-12-31 open <...account...> <...currencies...>

There are 9 kinds of directives, described in the sections below.

*** Currencies

Accounts contain amounts in "currencies." Currencies do not need to be
declared, they simply come into being as you use them.  The syntax for a
currency is a word all *in capital letters*.

You can create any currency--in fact, Beancount does not know anything special
about the kinds of things you can count. It does not even know anything about US
dollars, Euros, stocks, etc. They're just names of things. You can create a
currency for your home (e.g. MYLOFT), vacation hours (VACHR), or potential
contributions to your retirement accounts allowed annually (IRAUSD, RSPCAD).
You can just come up with anything.

I would advance that it would be good practice to use the standard ISO names for
currencies, just for the sake of familiarity. For example, in this document, we
use "USD" for US dollars, and the common ticker symbol of stocks to represent
them.

*** Account Names

Accounts can be used anywhere, and do not need to be declared to be valid
account names. A account name must begin with one of

  Assets:
  Liabilities:
  Equity:
  Income:
  Expenses:

and be following by capitalized words.

Following their naming, accounts will be arranged in a tree in the reports
generated by Beancount, so it's a good idea to think of them as being in a
hierarchy and use multiple levels.

For people with accounts in multiple countries, I would strongly suggest the
following hierarchy, which I've come to put to good use over multiple years of
usage living in 3 places:

  <AccountType>:<Country>:<Institution>:<Account>

For example:

  Assets:US:TDBank:Savings

This grouping tends to produce sensible reports. If you're not convinced,
you're welcome to experiment with whatever suits you, but if you have no
opinion, I think starting this way will save you time later o.a

*** Entering Text

All text in a Beancount file is considered a "string" and should be surrounded
by double-quotes.


** Opening and Closing an Account

Account names do not have to be declared, but in order for transactions to be
considered valid, we require that you open your accounts.

  YYYY-MM-DD open ACCOUNT CURRENCIES

for example:

  2012-06-01 open Assets:US:TDBank:Savings    USD

CURRENCIES is a list of comman-separated currencies, and it entirely optional.
If you provide it, postings to this account will be checked for and only accept
the currencies declared.

Accounts can also be closed. This helps for reporting; accounts that have been
closed prior to a reporting period will not be rendered in such views. You
should close your accounts on the date that they actually close. Here is how to
close the account above:

  2013-11-30 close Assets:US:TDBank:Savings


** Inserting Transactions




*** Costs & Inventories

costs, how it works, Inventory objects





*** The Tag Set

** Inserting Balance Checks

** Automatically Inserting a Padding Transaction

** Notes

** Documents


** Price

** Events


** Options


* Getting Started
** Establishing your Chart of Accounts and Balance Sheet

FIXME continue here


** Checking the Validity of Your Ledger File

  bean-check


* Generating reports
** Web Interface

  bean-web

** Views

WHat are views



* Sample Files
** Hello World - Minimal Beancount file

The absolute beancount file will involve a single transaction blablabla

Bring up bean-web on minimal.beancount and try browsing the different reports
generated in order to get a sense of where the data is going.




* Updating your Ledger
** Automating the Import Process


* Example Transactions
** A Word of Caution

There are many many ways to do this

Also, please keep in mind that I'm not a professional accountant.

** Types...
...

many many many of each type


* TODO

** Padding Directives

- bring up an example of starting an account from scratch
- then not from scratch, inserting a manual transaction
- introduce "pad" for this
- finally, provide an example of multiple missing statements,
  to justify that pad does not only get used once at the beginning

** Balance Directive

(with balance directive detail)
There is generally no balance directive used in income statement account.
Emember how we're generally only interested in transient changes in these types
of accounts. It makes little sense to consider the "sum total of all restaurant
expenses since you were born." However, it makes sense to find out how much
restaurant expenses were incurred in the *period* of the first three months of
the year.

** Emacs Support

beancount.el
trying to remain as simple as possible


** Misc

  - (documentation) In the stock transaction example, make sure that the sell
    side has both a cost and a price, so that a price entry is implicitly
    created. Explain this.

