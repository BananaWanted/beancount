= Beancount Design Doc =

Author: Martin Blais
Email: blais@furius.ca
Last Update: 2013-07-20

* Introduction

This document describes the various data structures and operations on them that
are used to implement the internal representations and computations of the
Beancount double-entry book-keeping system.  This is not a user's manual; if
you are interested in just using Beancount, see the associated "User's Manual"
document. However, if you are a developer, this document may help you
understand how Beancount works better.

This document is language-independent; the components it and operations it
describes should be implementable across different computer languages and
systems. The descriptions of the structures I have provided are conceptual, and
how they get mapped to each language is a matter of choice.

The purpose of the document is twofold:

1. to provide a human-readable overview of the internals of Beancount for
   contributors and people who want to process the data structures with custom
   programs, and

2. to encourage others to adopt the same internal design, in order to foster
   common applications between the various implementations of command-line
   double-entry book-keeping systems.

The implementation of the Ledger system provides explicit access to high-level
operations that are invoked from "expressions," either specified on the
command-line or in the input file. These expressions have to be provided by the
system's implementation and thus their set is limited to what happens to be
implemented. In contrast, Beancount provides a simplified syntax, a very simple
set of immutable data structures with all their members public, and a parser
that allows the user to easily convert a text file into this data structure and
write their own script for doing custom processing or reporting on them, using
any and all of the libraries available from the Python environment (NumPy and
Pandas come in particularly handy). For this reason, I thought it would be
useful to provide a high-level description of the data structures used in its
implementation. This will help contributors read and understand the code,
especially since the main implementation is in a dynamic language without
explicit type declarations.


* Core: Data Structures & Basic Operations
** Number

A *Number* is simply a Decimal object that represents a quantity, rounded by
any number of decimal digits. In the Python3 implementation, this is an
instance of `cdecimal.Decimal` or `decimal.Decimal`.

** Currency

A *Currency* is a string that represents a unit for the kinds of "things" that
can be stored in accounts. These strings typically only contain capital letters
and numbers. Beancount does not predefine any currency names or categories-all
currencies are created equal. In particular, it does not know which type of
currencies represent "money" and it does not have the concept of a "homed"
currency; it's entirely a multi-currency system. Currencies need not be defined
explicitly in the input file format; you can just start using them in amounts
and they will be recognized as such.

The most commonly used currencies will likely include monetary units, such as
"USD", "CAD", "GBP", "JPY", "AUD". Tickers for units of stock and other
financial instruments held at a cost are also often used as currency symbols,
such as "GOOG", "AAPL" or "RGAGX" (a type of mutual fund). You can also create
your own stock units, which would be a typical thing to do to represent of
shares or options of a company that is not traded publicly (e.g. ACMEOPTIONS).
You will also typically use individual currencies to represent airmiles or
various rewards points (e.g. AIRMILES, HSBCPTS) if you track them, vacation or
billable hours (e.g., VACHR, HOUR), allowable potential contributions to a
pre-tax investment account, such as an IRA or a Canadian RRSP (e.g., RSPCAD,
IRACAD), or large unique assets, such as your home (when I owned a condo unit at
4530 Clark st., I called mine LOFT4530, and I had exactly one unit of it in a
special account). You can really get creative with defining new currencies. In
short: if it's something you can count, it should have an associated currency.

In the Python3 implementation, we do not create an explicit type for currency
objects; we just use the string itself.

** Amount

An *Amount* is the combination of a number and an associated currency:

  Amount = (Number, Currency)

*** About Prices

A price does not have an explicit representation; rather, it is represented as
an amount; for example you could say "GOOG" shares are worth a price (amount) or
(510.00, "USD") by associating that amount with the "GOOG" currency or with a
*Position* in that currency (more below).

** Lot

A *Lot* identifies a specific currency held as a particular cost, acquired on a
particular date.

  Lot = (Currency, Amount(cost), Date)

For example, shares of Google bought at 510$ on 2012-03-05 would be represented
as

  Lot = ("GOOG", (510.00, "USD"), 2012-03-05)

Both the cost and the lot-date are optional. In fact, the most common case of
lots are lots without cost, used to represent "just dollars", e.g.

  ("USD", -, -)

and herein lies a useful simplification in our implementation: Beancount does
not have to track lots held at cost any differently than lots without cost:
in the operations on lots, lots without a cost are associated together in the
same way that lots held at a specific cost would. It just so happens that most
lots are held a the cost of "no cost." All operations only have to handle that
case (it turns out not to be a burden) and so it generalizes.

Unless you are tracking long-term vs. short-term profit from holding and trading
multiple different lots of the same types of shares held in the same account,
most of these shares don't usually end up tracking the date explicitly. It's up
to you to include the lot-date in the input syntax or not; if it is not
included, the lot-date is a null.

** Positions

A position is simply the number of units of a specific lot:

  Position = (Number, Lot)

For example, 12 shares of "GOOG" bought at 510$ is represent as a position of

  Position = (12.00, ("GOOG", (510.00, "USD"), -)

A transaction entry has with it associated multiple postings, or legs, each of
which has an associated position and optionally, a price.

*** Cost of a Position

If the position's lot has an associated cost amount, you can compute the
equivalent position "at cost" by multiplying the number by the cost number:

  cost of (  12.00, ("GOOG", (510.00, "USD"), -))
 ------------------------------------------------
          (6120.00, ("USD", -, -))

** Inventory

An *Inventory* is a kind of container object, that contains multiple positions.
Positions for equal Lots are associated and summed together. You can think of
an Inventory as a mapping from Lot to Number:

  Inventory = [
     (Lot1, Number),
     (Lot2, Number),
     (Lot3, Number),
     ...
     (LotN, Number),
     ]

Each of the lots above is kept unique. Addition or subtraction of positions are
grouped by lot.

We can define operations on lots: negation, addition, subtraction, adding or
removing of positions. In practice only a few of these are actually useful. We
provide some examples here.

Summing positions of the same lot:

  [(USD, -, -), 200]  +
  [(USD, -, -), 50]
 --------------------------------
  [(USD, -, -), 250]

The same goes for lots at a price, or at date, all fields must match:

  [(GOOG, 400 USD, -), 10]  +
  [(GOOG, 400 USD, -), 2]
 --------------------------------
  [(GOOG, 400 USD, -), 12]

Summing positions of differents ltos:

  [(USD, -, -), 200]  +
  [(CAD, -, -), 100]
 --------------------------------
  [(USD, -, -), 200, (CAD, -, -), 100]

The costs must match too:

  [(GOOG, 400 USD, -), 10]  +
  [(GOOG, 450 USD, -), 2]
 --------------------------------
  [(GOOG, 400 USD, -), 10, (GOOG, 450 USD, -), 2]


Subtracting positions:

  [(USD, -, -), 200]  -
  [(USD, -, -),  50]
 --------------------------------
  [(USD, -, -), 150]

When positions become zero, they get removed:

  [(USD, -, -), 200, (CAD, -, -), 100]  -
  [(CAD, -, -), 100]
 --------------------------------
  [(USD, -, -), 200]

You may subtract into negative numbers:

  [(USD, -, -), 200]  -
  [(USD, -, -), 250]
 --------------------------------
  [(USD, -, -), -50]

It is typically indicative of a user error, however, to subtract units held at
cost to a negative number of units, so that will be flagged as an error by
default (this is a choice).

*** Cost of an Inventory

Similarly to a Position's cost, you can compute the cost of an Inventory by
combining all of its positions at cost:


  cost of [(  12.00, ("GOOG", (510.00, "USD"), -)), (450, ("USD", -, -))]
 ------------------------------------------------
          [(6120.00, ("USD", -,  -)), (450, ("USD", -, -))]


** Account

An *Account* is basically just the name of a counter and is represented as a
string. Account names have multiple components separated by a special character
(":"), which form an implicit hierarchy, for example:

  Assets:US:TDBank:Checking

implicitly defines a tree of nodes with parent nodes "Assets", "US", "TDBank"
and leaf node "Checking."

The first component of an account name is limited to one of five category names:

- Assets
- Liabilities
- Equity
- Income
- Expenses

This constraint is important, because some of the operations that use account
groups assume that all accounts belong to one of these basic accounting
categories. The names as read in the input syntax may be customized with
"option" directives, so you can change the names to french, or even just rename
"Income" to "Revenue" if you prefer to do that.

** Flags

Flags may be associated with transactions and postings to indicate whether they
are assumed to be correct ("reconciled") or flagged as suspicious. They are
represented in Python by a single-character string, or by a null value (if
absent).

** Posting

Each transaction entry is composed of multiple legs, or *Postings*. Each of
these postings is associated with an account, a position and an optional price
and an optional flag:

  Posting = (Account, Position, Price, Flag, Entry)

The price is most often a null value, and when it is set, it is used to declare
conversions that do not track the cost of their units, such as currency
conversions. This have an impact on the accounting equation and in general you
will have a limited number of them-they typically correspond to currrency
conversions. Almost always, transactions that have postings with positions in
different types of units, such as purchases and sales in an investment account
(e.g. giving cash for shares, or vice-versa) use cost tracking and the price
slot is not used.

Also, flags on postings are also relatively rare, but supported; usually users
will find it sufficient to flag an entire transaction instead of a specific
posting.

A Posting can ever only be contained by a single entry, and so each Posting
instance should refer to the Entry that contains it. This is necessary because
when we realize a particular view of a subset of entries, we will create lists
of postings and need to be able to refer to their transactions. However, this
creates a cycle of references, as the Transaction entries contain a list of
their postings and must be dealt with in the implementation depending on how the
host language does memory management.

See the section on "Balancing Postings" below to see how postings are checked
against each other.

** Transaction

A *Transaction* is a kind of *Entry*. This is by far the most common and
important type of entry found in Beancount files. The function of a book-keeping
system is to organize these entries' postings in different groups and compute
balances and sums within these groups of associated postings. All the other
types of entries occupy supporting roles in our system.

  Transaction = (Date, Flag, Payee, Narration, Postings, Tags, Links)

Description of fields:

- Date: Each transaction has a single date. Sometimes different postings of the
  same transaction will appear at different dates, so eventually we will allow a
  posting to have its own date to override the transaction's date, to be used as
  documentation; in the simplest version, we enforce all transactions to occur
  punctually, which is simple to understand and was not found to be a
  significant problem in practice. Eventually we might deal with transactions
  with postings at differing dates by implicitly converting them into multiple
  transaction entries and using some sort of transfer accounts.

- Flag: A transaction is sometimes marked as incomplete or suspicious by the
  author. For that purpose, a flag can be set to various values. "!" can be
  indicate that this transaction needs review and will appear highlighted in the
  journals. The default value is "*", which means that the transaction is
  thought to be correct. Other flags are also supported; see the parser to for
  details.

- Payee & Narration: The narration is a user-provided description of the
  transaction, such as "Dinner with Mary-Ann." Yon can put any information in
  this string. It shows up in the journal report. Oftentimes it is used to
  enrich the transaction with context that cannot be imported automatically,
  such as "transfer from savings account to pay for car repairs."

  The payee name is optional, and exists to describe the entity with which the
  transaction is conducted, such as "Whole Foods Market" or "Shell." Note that
  you can view reports for all transactions associated with a particular payee,
  so it's a nice extra to enter consistent payee names if the effort is not too
  great.

  If the transactions were written by one of the importers, the OFX source files
  will most often contain the name of the payee in a somewhat unnormalized name,
  like "BARNES&NOBLE BKSTRE #2000NEW YOR". We leave it up to importer code to
  clean up these names into names that can be reconciled with each other, and
  will provide tools to help do this manually if this ends up being the only
  workable solution. In any case, even if you choose to leave your payee names
  are all ugly and not fully de-dupped, it's really not a big deal. It's just a
  nice extra to be able to group transactions by payee.

- Postings: a list of the posting instances associated with this transaction.

- Tags & Links: These are both meant to be unique sets of strings, and in
  practice will be usually empty for most transactions. See section below on
  their use and meaning.

*** Tags

Tags are strings that can be used to group sets of transactions. A view of this
subset of transactions can then be generated, including all the usual reports
(balance sheet, income statement, journals, etc.). You can tag transactions for
a variety of purposes; here are some examples:

- All transactions during a particular travel might be tagged to later summarize
  your trip expenses. Those transactions will usually occur around the same date
  and therefore there is convenient syntax used to automatically tag many
  transactions that are declared together in a file.

- Transactions related to a particular project to be accomplished. I took some
  classes in an online program once, and tagged all related expenses to it. I
  use this to track all my immigration-related expenses for a particular stage
  (e.g. green card).

- Declaring a group of expenses to be paid back by an employer (or your own
  company) later on.

- Expenses related to moving between locations.

Typical tag names that I use for tags look like "#trip-israel-2012",
"#conference-siggraph", and "#course-cfa".

In general, tags are useful where adding a sub-accounts won't do. This is often
the case where a group of related expenses are of differing types, and so they
would not belong to a single account. Feel free to get creative.

*** Links

Links are a way for a transaction to refer to other transactions. They work
similarly to tags, that is, grouping a set of transactions, but have a different
purpose: they are not meant to be used for summarizing. Instead, they are used
to associate transactions for whatever reason you may have, usually for tracking
related events.

Examples include:  transaction-ids from trading accounts (these often provide an
id to a "related" or "other" transaction); account entries associated with
related corrections, for example a reversed fee following a phone call could be
linked to the original invalid fee from several weeks before; the purchase and
sale of a home, and related acquisition expenses.

In contrast to tags, their strings are most often unique numbers produced by the
importers. No views are produced for links; only a journal of a particular links
transactions can be produced and a rendered transaction should be accompanied by
an actual "link" icon you can click on to view all the other related
transactions.

** Balancing Postings

The fundamental principle of double-entry book-keeping is enforced in each of
the the Transaction entries: the sum of all postings must be zero. This section
describes the specific way in which we do this.

Postings may be associated with positions in any currency unit. This position
may or may not be associated with a particular cost amount. Furthermore,
postings may have an associated price. How do we balance?

Each of the posting's positions are first converted into a "balance amount":

- If the posting has an associated cost, the cost of the









balancing






** Other Entries

Open        = namedtuple('Open'        , 'fileloc date account currencies')
Close       = namedtuple('Close'       , 'fileloc date account')
Pad         = namedtuple('Pad'         , 'fileloc date account account_pad')
Check       = namedtuple('Check'       , 'fileloc date account amount errdiff')
Transaction = namedtuple('Transaction' , 'fileloc date flag payee narration tags links postings')
Note        = namedtuple('Note'        , 'fileloc date account comment')
Event       = namedtuple('Event'       , 'fileloc date type description')
Price       = namedtuple('Price'       , 'fileloc date currency amount')
Document    = namedtuple('Document'    , 'fileloc date account filename')

* Functional Operations
** Padding
** Check
** Summarizing
** Realization

** Loading
  Describe operations used in load()

** Realizing
  Describe operations used in balanace sheet and income statement

* Ideas

** Subaccounts vs. Payees vs. Tags

Expenses:Legal:Immigration vs. #immigration

Typically, if the kinds of expenses vary, using tags is more appropriate.




* Documents & Other Features


* Parser: Syntax



* Import: The Problem

** Merging entries




* Web Interface & Reports
