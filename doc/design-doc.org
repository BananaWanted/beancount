= Beancount Design Doc =

Author: Martin Blais
Email: blais@furius.ca
Date: 2013-07-14

* Introduction

This document describes the various data structures and operations on them that
are used to implement the internal representations and computations of the
Beancount double-entry book-keeping system.  This is not a user's manual; if
you are interested in just using Beancount, see the associated "User's Manual"
document. However, if you are a developer, this document may help you
understand how Beancount works better.

This document is language-independent; the components it and operations it
describes should be implementable across different computer languages and
systems. The purpose of the document is twofold:

1. to provide a human-readable overview of the internals of Beancount for
   contributors and people who want to process the data structures with custom
   programs, and

2. to encourage others to adopt the same internal design, in order to foster
   common applications between the various implementations of command-line
   double-entry book-keeping systems.

The implementation of the Ledger system provides explicit access to high-level
operations that are invoked from "expressions," either specified on the
command-line or in the input file. These expressions have to be provided by the
system's implementation and thus their set is limited to what happens to be
implemented. In contrast, Beancount provides a simplified syntax, a very simple
set of immutable data structures with all their members public, and a parser
that allows the user to easily convert a text file into this data structure and
write their own script for doing custom processing or reporting on them, using
any and all of the libraries available from the Python environment (NumPy and
Pandas come in particularly handy). For this reason, I thought it would be
useful to provide a high-level description of the data structures used in its
implementation. This will help contributors read and understand the code,
especially since the main implementation is in a dynamic language without
explicit type declarations.


* Core: Data Structures & Basic Operations
** Number

A *Number* is simply a Decimal object that represents a quantity, rounded by
any number of decimal digits. In the Python3 implementation, this is an
instance of `cdecimal.Decimal` or `decimal.Decimal`.


** Currency

A *Currency* is a string that represents a unit for the kinds of "things" that
can be stored in accounts. These strings typically only contain capital letters
and numbers. Beancount does not predefine any currency names or categories-all
currencies are created equal. In particular, it does not know which type of
currencies represent "money" and it does not have the concept of a "homed"
currency; it's entirely a multi-currency system. Currencies need not be defined
explicitly in the input file format; you can just start using them in amounts
and they will be recognized as such.

The most commonly used currencies will likely include monetary units, such as
"USD", "CAD", "GBP", "JPY", "AUD". Tickers for units of stock and other
financial instruments held at a cost are also often used as currency symbols,
such as "GOOG", "AAPL" or "RGAGX" (a type of mutual fund). You can also create
your own stock units, which would be a typical thing to do to represent of
shares or options of a company that is not traded publicly (e.g. ACMEOPTIONS).
You will also typically use individual currencies to represent airmiles or
various rewards points (e.g. AIRMILES, HSBCPTS) if you track them, vacation or
billable hours (e.g., VACHR, HOUR), allowable potential contributions to a
pre-tax investment account, such as an IRA or a Canadian RRSP (e.g., RSPCAD,
IRACAD), or large unique assets, such as your home (when I owned a condo unit at
4530 Clark st., I called mine LOFT4530, and I had exactly one unit of it in a
special account). You can really get creative with defining new currencies. In
short: if it's something you can count, it should have an associated currency.

In the Python3 implementation, we do not create an explicit type for currency
objects; we just use the string itself.


** Amount

An *Amount* is the combination of a number and an associated currency:

  Amount = (Number, Currency)


*** About Prices

A price does not have an explicit representation; rather, it is represented as
an amount; for example you could say "GOOG" shares are worth a price (amount) or
(510.00, "USD") by associating that amount with the "GOOG" currency or with a
*Position* in that currency (more below).


** Lot

A *Lot* identifies a specific currency held as a particular cost, acquired on a
particular date.

  Lot = (Currency, Amount(cost), Date)

For example, shares of Google bought at 510$ on 2012-03-05 would be represented
as

  Lot = ("GOOG", (510.00, "USD"), 2012-03-05)

Both the cost and the lot-date are optional. In fact, the most common case of
lots are lots without cost, used to represent "just dollars", e.g.

  ("USD", -, -)

and herein lies a useful simplification in our implementation: Beancount does
not have to track lots held at cost any differently than lots without cost:
in the operations on lots, lots without a cost are associated together in the
same way that lots held at a specific cost would. It just so happens that most
lots are held a the cost of "no cost." All operations only have to handle that
case (it turns out not to be a burden) and so it generalizes.

Unless you are tracking long-term vs. short-term profit from holding and trading
multiple different lots of the same types of shares held in the same account,
most of these shares don't usually end up tracking the date explicitly. It's up
to you to include the lot-date in the input syntax or not; if it is not
included, the lot-date is a null.


** Positions

A position is simply the number of units of a specific lot:

  Position = (Number, Lot)

For example, 12 shares of "GOOG" bought at 510$ is represent as a position of

  Position = (12.00, ("GOOG", (510.00, "USD"), -)

A transaction entry has with it associated multiple postings, or legs, each of
which has an associated position and optionally, a price.

*** Cost of a Position

If the position's lot has an associated cost amount, you can compute the
equivalent position "at cost" by multiplying the number by the cost number:

  cost of (  12.00, ("GOOG", (510.00, "USD"), -))
 ------------------------------------------------
          (6120.00, ("USD", -, -))


** Inventory

An *Inventory* is a kind of container object, that contains multiple positions.
Positions for equal Lots are associated and summed together. You can think of
an Inventory as a mapping from Lot to Number:

  Inventory = [
     (Lot1, Number),
     (Lot2, Number),
     (Lot3, Number),
     ...
     (LotN, Number),
     ]

Each of the lots above is kept unique. Addition or subtraction of positions are
grouped by lot.

We can define operations on lots: negation, addition, subtraction, adding or
removing of positions. In practice only a few of these are actually useful. We
provide some examples here.

Summing positions of the same lot:

  [(USD, -, -), 200]  +
  [(USD, -, -), 50]
 --------------------------------
  [(USD, -, -), 250]

The same goes for lots at a price, or at date, all fields must match:

  [(GOOG, 400 USD, -), 10]  +
  [(GOOG, 400 USD, -), 2]
 --------------------------------
  [(GOOG, 400 USD, -), 12]

Summing positions of differents ltos:

  [(USD, -, -), 200]  +
  [(CAD, -, -), 100]
 --------------------------------
  [(USD, -, -), 200, (CAD, -, -), 100]

The costs must match too:

  [(GOOG, 400 USD, -), 10]  +
  [(GOOG, 450 USD, -), 2]
 --------------------------------
  [(GOOG, 400 USD, -), 10, (GOOG, 450 USD, -), 2]


Subtracting positions:

  [(USD, -, -), 200]  -
  [(USD, -, -),  50]
 --------------------------------
  [(USD, -, -), 150]

When positions become zero, they get removed:

  [(USD, -, -), 200, (CAD, -, -), 100]  -
  [(CAD, -, -), 100]
 --------------------------------
  [(USD, -, -), 200]

You may subtract into negative numbers:

  [(USD, -, -), 200]  -
  [(USD, -, -), 250]
 --------------------------------
  [(USD, -, -), -50]

It is typically indicative of a user error, however, to subtract units held at
cost to a negative number of units, so that will be flagged as an error by
default (this is a choice).


*** Cost of an Inventory

Similarly to a Position's cost, you can compute the cost of an Inventory by
combining all of its positions at cost:


  cost of [(  12.00, ("GOOG", (510.00, "USD"), -)), (450, ("USD", -, -))]
 ------------------------------------------------
          [(6120.00, ("USD", -,  -)), (450, ("USD", -, -))]


** Account

An *Account* is basically just the name of a counter and is represented as a
string. Account names have multiple components separated by a special character
(":"), which form an implicit hierarchy, for example:

  Assets:US:TDBank:Checking

implicitly defines a tree of nodes with parent nodes "Assets", "US", "TDBank"
and leaf node "Checking."

The first component of an account name is limited to one of five category names:

- Assets
- Liabilities
- Equity
- Income
- Expenses

This constraint is important, because some of the operations that use account
groups assume that all accounts belong to one of these basic accounting
categories. The names as read in the input syntax may be customized with
"option" directives, so you can change the names to french, or even just rename
"Income" to "Revenue" if you prefer to do that.


** Flags

Flags may be associated with transactions and postings to indicate whether they
are assumed to be correct ("reconciled") or flagged as suspicious. They are
represented in Python by a single-character string, or by a null value (if
absent).


** Posting

Each transaction entry is composed of multiple legs, or *Postings*. Each of
these postings is composed of an account, a position and an optional price and
an optional flag.

  Posting = (Account, Position, Price, Flag)

The price is most often elided to a null value, and is used to declare
conversions that do not track the cost of units, such as currency conversions
(these have an impact on the accounting equation and should show up
sparingly-most conversions within one country, such as purchases and sales in an
investment account, take place using the cost). Flags on postings are also rare;
usually a user will flag an entire transaction instead of a specific posting.

See the section on "Balancing Postings" below to see how postings are used.

** Transaction

A *Transaction* is a kind of *Entry*.


This is by far the most common and important type of entry found in files. The
function of a book-keeping system is to contain these entries and compute
amounts from different groupings of their associated postings. All the other
types of entries occupy supporting roles.




*** Balancing Postings


The fundamental principle of double-entry book-keeping is enforced here:

balancing



** Tags & Links



** Entries


Open        = namedtuple('Open'        , 'fileloc date account currencies')
Close       = namedtuple('Close'       , 'fileloc date account')
Pad         = namedtuple('Pad'         , 'fileloc date account account_pad')
Check       = namedtuple('Check'       , 'fileloc date account amount errdiff')
Transaction = namedtuple('Transaction' , 'fileloc date flag payee narration tags links postings')
Note        = namedtuple('Note'        , 'fileloc date account comment')
Event       = namedtuple('Event'       , 'fileloc date type description')
Price       = namedtuple('Price'       , 'fileloc date currency amount')
Document    = namedtuple('Document'    , 'fileloc date account filename')






* Functional Operations
** Padding
** Check
** Summarizing
** Realization

** Loading
  Describe operations used in load()

** Realizing
  Describe operations used in balanace sheet and income statement


* Documents & Other Features


* Parser: Syntax



* Import: The Problem

** Merging entries




* Web Interface & Reports
