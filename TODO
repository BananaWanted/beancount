-*- mode: org -*-
beancount: TODO
* Requirements for Shipping 2.0
** Current

  - Complete presentation

  - Fix rendering of balances for HTML journals, esp. w.r.t. example file,
    rendering lots is just _not_ the ticket.

      In HTML rendering, render only by units, and provide a link to a /context
      page that renders inventory befre and after just like my context utility.

  - Add more tests for intra-day trading, esp. w.r.t. ordering and inventory booking.

  - Complete more thorough tests for journal_text_test.py

  - Improve printer to avoid inserting spaces between directives of the same
    type, except when they are transactions. This will result in a tider output
    that is natural and prettier.


** Establish Display Precision

  - Build a routine that can compute the commonly used precision for each
    currency and (currency, account) pairs, and derive a PrecisionContext
    object that can then be used to render all the data.


  - Write unit tests for display precision, this isn't too great now.

  - With the tests, figure out if we still need MAXDIGITS_QUANTIZE,
    MAXDIGITS_PRINTER, etc., based on all usage. I think this is not the way I
    want it to be.

  - Allow the printer control over whether commas are to be rendered or not.

  - Fix the alignment of the rendered postings by printer, it's out of whack.
    See example.beancount file, doesn't look nice anymore. Has to do with
    replacement of strings I believe. But the printer should *always* output
    nicely aligned numbers.


  - Fix all of these with the routine:

     grep -srn '\.str\b'    /home/blais/p/beancount/src/python/beancount/
     /home/blais/p/beancount/src/python/beancount/parser/printer.py:57:        price_str = ('@ {}'.format(posting.price.str(amount.MAXDIGITS_PRINTER))
     /home/blais/p/beancount/src/python/beancount/parser/printer.py:64:                balance_amount_str = balance_amount.str(amount.MAXDIGITS_PRINTER)
     /home/blais/p/beancount/src/python/beancount/core/position.py:99:        amount_str = Amount(self.number, lot.currency).str(MAXDIGITS_PRINTER)
     /home/blais/p/beancount/src/python/beancount/core/position.py:107:                    Amount(lot.cost.number, lot.cost.currency).str(MAXDIGITS_PRINTER))
     /home/blais/p/beancount/src/python/beancount/core/amount.py:111:        return self.str(MAXDIGITS_QUANTIZE)
     /home/blais/p/beancount/src/python/beancount/reports/convert_reports.py:185:            price_str = '@ {}'.format(posting.price.str(amount.MAXDIGITS_PRINTER))
     /home/blais/p/beancount/src/python/beancount/reports/convert_reports.py:195:                    posting.position.lot.cost.str(amount.MAXDIGITS_PRINTER))
     /home/blais/p/beancount/src/python/beancount/reports/convert_reports.py:287:        price_str = ('@ {}'.format(posting.price.str(amount.MAXDIGITS_PRINTER))


  - At the same time, figure out why printing is basically _always_ adding the
    comment on each posting. It shouldn't, this is a bug.

  - Maybe use this routine in the BQL rendering routines instead of using the
    display precision mode in the displayed numbers only.


** Rounding

  - Implement experimental precision check suggested by Nathan Grigg
  - Implement Equity:Rounding accumulation suggested by Nathan Grigg

  - Make (SMALL_EPSILON) balance tolerance user-configurable before release.

  - Infer precision from numbers like this:

      >>> d = Decimal('1.2300')
      >>> getcontext().power(10, -(len(str(d).split('.')[-1])+1)) * 5
      Decimal('0.00005')

  - Maybe provide a way to make thhis tolerance settable by commodity.
    (See thread w/ Nathan on the mailing-list)

  - Doc: https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/YjkmOM3LHXIJ

  Alright, so here's what I propose:

  - I could add an option for the user to insert the name of a rounding account.
  - This option would be empty by default, and the current behaviour would not
    change.
  - However, if you set an account for it, all transactions with an inexact
    balance will receive the balance amount (and perhaps have a new leg inserted
    on them automatically).

  Would that be a reasonable compromise? With no account, you get 0.005 looseness
  (or whatever this becomes if inference is implemented). With an account, you get
  precise balances throughout, but no manual input is required.

  - Complete and merge sampled_quantization


** Units, Weight Name Everything Consistently

  It's time for a bit of a better establishment in the names of the quantities
  we use. This should be done for 2.0.

  - Clean up terminology re. units, weight, etc.
  - Rename all "balance amounts" to "weight".

  - Rename compute_balance_amount() -> compute_weight() and provide functions to
    compute units, weight, etc. from Position objects, using consistent
    terminology.

  - Rename Position.get_amount() -> Position.get_units(). Make sure the
    terminology matches that of Inventory.

  - I think we should remove Inventory.get_amounts(), replace by get_units().


** Renames and Move Files to Final Location

  As I'm moving to a system with more plugins and less code in the core, and
  with the intermediate reports stage instead of just the web interface, it's
  becoming clearer where some files need to move. Try to make these moves
  before shipping, so that things don't move nearly as much later on.

  - Move examples/tutoral/example.beancount -> examples/example.beancount, does
    not need to be under tutorial/

  - Maybe beancount.core.complete should be called beancount.core.interpolate.
    That's the term I've been using for a while now isn't it. Clean up
    terminology.

  - Revise beancount.loader.load() to beancount.loader.load_file() + alias, as
    for the parser.

  - beancount.core.realization: Look at deps for beancount.core.realization and
    move it upstream where it makes sense, maybe ops.

  - beancount.core.getters: Should this move to ops as well? Check the
    dependency tree, see if it makes sense.

  - Emerge a principle for where the following files should separate:

      beancount.ops.*
      beancount.plugins.*

  - Make various attempts to simplify depgraph, we want to ship with a really
    lean dependency graph.

  - Should 'bean-query not be called bean-count or bean-report? Choose a final
    name and live with it. I like 'bean-count' best. EMBRACE ONE.
    bean-report


** Cleanup Tasks

  Some amount of generic cleanup should be performed before calling the release.
  This is just tightening up the bolts on the beast before shipping. I want to
  have a pretty solid pylint configuration passing.

  - Fix all FIXMEs everywhere, or convert them to items in this list.

  - Configure and run a clean pylint on the entire codebase.

  - Add __author__ to all files?

  - Install flake8, PyChecker, pep8 after pylint passes, run all of them.


** Unsure

  - Implement unit tests for all the functions in beancount.reports.journal_text

  - Differentiate between the concept of "journal" and "register" report: a
    "journal" should include all the postings and no running balance. A
    "register" should by default only render just one account's postings and
    render a running balance column. This is the distinction between the two,
    and making this distinction will allow us to produce two useful but
    distinct reports for the console output, even if these are somewhat similar
    for the web output.

    This should probably be done before the release, so that at least the first
    version has some decent console reports, even if the revamp of reports
    comes later on.


  - Implement text report for journal, income statement and balance sheet.
    These should be present for a 1.0 release, even if in a rudimentary form.


** Reports

  - Reconcile the rendering of units, cost, lots between text and HTML reports,
    the set of options for all of these should be the same.


** Documentation / Ongoing

  - Is there a script somewhere that can accept a CSV file and render a CSV
    pivot table from it?  The reason we need support is in order to carry out
    operations on columns of inventories. Maybe we should impleemnted some sort
    of swiss-knife tool that is able to parse inventories from columns and
    perform various operations on them, aggregations, etc. using Beancount's
    Inventory() class. This could be a powerful tool!

  - Nice Health Care section is nearly complete... complete it with DEDUC and COPAY
    legs explanation

  - Write out the taxes section, you have all the details, no need to wait

  - Clean up this TODO file, reorganize sections, remove what's redundant from
    the proposal files.

  - Create new doc: Inter account transfer
  - Create new doc: Computing portfolio returns using Beancount

  - Change script to try to download to ODT format and then batch format to ebook


* Current / Misc / To Be Classified

  (This is a grab bag of ideas. When I have a new idea coming to me, I don't
  have time to think about where to put it, I just come here and jot it down.
  Every couple of months I clean this mess up and put it in the sections below.
  Please excuse the mess. Of course, I'll clean it up before every release.)


  - Allow sign normalization:

    * Add an option to the parser to allow signs to be entered with the "all
      positive" convention, and actually invert the signs right at the output
      of the parser.  Balance errors should be enhanced to emphasize which of
      the postings should be increased or decreased, based on the sign of the
      balance error and the type of each account.

    * For display, in the shell, provide a SIGN(account) function that allows
      the user to multiply the inventory by, or a NORM(inventory, account)
      function that would do that itself on the inventory.

    This whole thing should be a minor version. This would be a valuable feature
    IMO, allowing users to choose their favorite convention would be a plus.


  - Separate inventory booking to be implemented in a plugin. It should do
    three things:

    * Find matching lots and raise errors when not found

    * replace all partially specified lots to their fully specified versions
      (they matched lots). For augmenting lots, this means insert the date. For
      lot reductions, it means, find the matching lot and use that instead of
      the partially specified one.

    * Insert links on matching lots, so that trades can be identified a
      posteriori.

    This means, move beancount.ops.validation.validate_inventory_booking() to
    its own file and make it do the three steps above.



  - Create a two-column tool to convert one column into two columns (for text
    mode balance sheet and income statement). The equivalent UNIX tool does not
    exist. Select columns by regexp.



  - Support an include directive that is a URL, in order to fetch lists of
    prices updated remotely, or via crontab. This way the dashboard does not
    have to include code that fetches prices.


  - Idea: option to search a lot from any account, not just the current account,
    and cause an automatic lot transfer. Must match shares in the current
    account, but the lot with the corresponding cost could come from any
    account.

  - Idea: Another output data format for the reports/query language could be
    parseable Python format.


  - Idea for an additional check: a plugin that computes the weight using the "@
    price" value on a posting held-at-cost, checked against the rest of postings
    minus income (gains) accounts.



  - Comparison w/ Ledger doc: "balance sheet and closing of year"


  - Docs for inventory booking: Add {* 634.23 USD} idea for average cost
    booking: there should be an optional amount, and the star just means "before
    and after". Add this to B docs.


  - You should have a dwdidated section of your document that explains how market
    values are reported, that is, via the unrealized gains plugin. Also provide a
    market() function, to value holdings.



  - BUG/CHANGE: Unrealized gain when rendering for closed years does not appear.
    Perhaps we should insert the unrealized gains during close operation.

    Idea: close realized gains along with close(), so that they don't show up for
    the latest year.



  - Idea for a plugin: Create a new plugin that automatically inserts legs for
    the "Trading Accounts" methods described here:
    http://wiki.gnucash.org/wiki/Trading_Accounts
    http://www.mscs.dal.ca/~selinger/accounting/tutorial.html
    http://www.mscs.dal.ca/~selinger/accounting/gnucash.html
    This should be implementable via a plugin.
    The resulting Conversions entry should be empty...


  - Make options to render *all* reports with
      --lots (default)
      --units
      --cost
      --weight
      --market
    See Query & Filtering language doc for details.

  - (query syntax) It *would* make sense to use full SQL for this, even if the
    aggregation method is an inventory.

      targets: units, cost, market, lots
      data-source: balances, journal, holdings
      restricts: ... all the conditions that match transactions, with = ...
      aggregations: by currency, by day, by month, by account (regexp), etc.
      other: filter display, pivot table (for by-month reports), max depth

    You would render these as a table.


  - (docs) Write a script to download and bake all my PDFs docs in a printable
    and mobile-friendly formats.

  - (docs) I'd like the documentation links to open in "View" mode by default,
    YET still allowing the user to switch to "Suggestion" mode if they want to.

  - 'sum' ('balances'): Find some way to aggregate all inventories for a set of
    unrelated accounts, e.g., Assets.*Vanguard.*RGAGX, to obtain the total
    amounts of RGAGX'es. This should be a new kind of report, e.g., 'sum'.


  - Implement csv output for 'balances' report.


  - balances report: support rendering the values not-at-cost for HTML reports too.


  (avg cost idea)
  - PROBLEM: You need be able to provide the cost with both and addition and a
    reduction, e.g.
       -2 GOOG {* 650 USD} ;; Should be possible even if current avg cost if 600 USD
        2 GOOG {* 650 USD} ;; Means "add at this cost and then convert to avg
    cost"

    This is nice! The "*" now always means "after applying this operation,
    convert to avg cost.".


  (documentation)
  - Write a worked and detailed example of generating automated transactions in
    the Plugins document.


  (portfolio)
  - Move portfolio code our of experiments
  - Build a report dedicated to uninvested cash


  - Journal rendering: add terminal colors (easy).



  - Would it make sense for every plugin to provide a validation function? We
    could then move all the validation routines in their plugin file. I very
    much like this idea: it creates more isolation for routines and less
    dependencies. Open/Close, Balance checks, do seem to be able to fit in this
    category. Those functions should return only a single list of errors, no
    entries, and the calling function should perform a simple hash check to
    ensure that the mutable portion of the entries hasn't been modified by the
    user-provided validation functions.
    'beancount.ops.documents' could benefit from this split.



  (open directives)
  - An invariant that we would love to have is to ensure that after parsing, all
    accounts that are used in a list of entries should have a corresponding Open
    directive for them. This would mean a variant of the validation routine that
    automatically inserts missing directives. At the moment, when an Open
    directive is missing, processing code that assumes they are always present
    might fail. We cannot insert the missing directives in the validation code
    simply because validation code is not allowed to modify the list of
    entries. We could insert a "fixup" step after validation, that does these
    kinds of automatic recoveries. Ponder this for a while.

  - Do we need to insert Open entries for the equity accounts described in
    options? I think we could safely plop that at the very beginning of the
    entries list in the parser.



  - (performance) Write your own lexer manually and compare performance with
    flex one. I think we can do a much better job at error reporting by writing
    our own, but I'm unsure how the performance compares.



  - Along with the new inventory, you can make Holding -> Position. This makes
    a lot of sense actually. Do do this!



  - (documents) documents found in parent directories don't end up creating a
    directive because we skip them because we only restrict to accounts which
    have had an open declaration... this is probably not what we want, in order
    to maximize the number of documents captured by this. {fa96aa05361d}


  - Bring in all the generic functions from experiments/returns/returns.py into
    core beancount. Bring in returns as a plugin.

  - (architecture) Seriously consider merging entries and errors; errors are
    just a special type of entry, and they have dates, and they get rendered in
    journals. This could make a lot of sense.


  - I need a report dedicated to detailing uninvested cash.


  - Closing an account with a non-zero balance should trigger an error! Right
    now it does not. This is important.


  - Enhance error reporting! Make all errors possibly hold on to a list of
    entries, not just one. Many, many errors will benefit from this.


  - (parser) Is it possible to specify no flag on a transaction?, e.g. just the date?

       2014-07-12
         ..

    Does this work? (It would be nice if it did. Make it so.)
    We should change the grammar so that the flag is part of the txn_fields.
    This is elegant: basically, instead of the flag taking the place of the
    transaction, the 'txn' keyword just becomes optional. That's it. DO THIS!


  - (parser) Should we disallow periods in currency names? It allows for weird
    things like CAD.11 as a currency.


  - (web) All errors should be displayed in an overlay; proper error handling
    and display for the web interface is not optional. This needs to be done
    before shipping.


  - Figure out how to disable googleapis fonts when on a very slow connection.
    I'd like to enable the fonts, but if they cannot be fetched quickly, or
    cached, this should be disabled.


  - Idea: a plugin that autopads all initial balance assertions! Do it for
    demos, will be very useful for making demos easier, not having to be so
    strict.

  - (parser) Add an option to the parser to not just ignore unparsed lines, more
    strict.


  - Beancount: Add a "lineno" format for journals that renders in "Emacs errors"
    compatible format, so we can easily jump in time throughout the input file
    instead of rendering a journal. Offer the option to list in reverse to.

  - (rendering) Journals should render in either order.


  - Use the same option on all tools for showing the timings, --verbose timings,
    maybe add it from the loader module.


  - Implement a report of Trades booked in the list of filtered transactions!
    Create this report, I removed the placeholder for it in the web app.


  - Make conversions report sum up to zero by adding a similar conversions
    entry as for the balance sheet.



  - Refine 'source' attribute on all directives: For .source, instead of '<...>'
    for the filename, we should use a scheme:..., like file://..., and
    plugin:beancount.... . This makes a lot more sense. The lineno still needs
    to be separate, we need that for sorting and prefer not to have it part of
    the string.


  - Add an option for spacing in the revamped reports.



  - (pad) Review the possibility of padding units held at cost:

      "The reason it fails is that there must have been units of those commodities
      held at cost before the pad date, and it is an error to pad commodities at
      cost, because Beancount has no way to know what the cost basis of those
      commodities should be."




  - When an error occurs while parsing a directive/transaction, add the ability
    to let the parser skip until the next directive and ignore the parsed
    transaction because of the error. Maybe this should be an exception
    mechanism, or just storing a flag that gets reset when the directive is
    completed. Not sure. This would be a more elegant way to deal with some
    errors.



  - You can implement the sign check for positions held-at-cost only when there
    are other of that same commodity held at cost in the inventory in the
    opposite sign. This should allow holding short positions yet still retain
    the benefit of the check for data entry errors.

    It also removes what for most people will appear as a limitation from the
    docs (although with experience you would realize that it is not much of a
    limitation at atll).





  - There's a fundamental question about which date to be used for pricing
    entries. This really would depend on the view. If this is a period view, the
    date of the last entry is most appropriate. If it is any other kind of view,
    the latest price is best. All the reports should be adjusted for this.




  - Idea: Allow sub-account names to include a special character, e.g., '#',
    (only one) that would indicate to the reporting facilities that, by default,
    the aggregation should be reported to the parent account. A "detail" or
    "verbose" switch could be used to trigger the detailing of subaccounts. For
    example,

       Expenses:Health:Medical:#Claims
       Expenses:Health:Medical:#PatientSavings
       Expenses:Health:Medical:#ClaimsPayments

    would be reported as

      Expenses:Health:Medical

    by default, but with the detailed switch, would be reported as

       Expenses:Health:Medical:Claims
       Expenses:Health:Medical:PatientSavings
       Expenses:Health:Medical:ClaimsPayments

    This could be used for various subaccounts actually. It's a nice way to
    guide reporting that does not complexify the semantics.




  - Register (with filter) should have "print" mode that also includes
    file:lineno so that we can make Emacs "jump" between the transactions in
    the order they appear.



  - (design) New inventory booking:
    1. for each posting, classify by currency
    2. for each posting at cost, classify whether position augmentation or reduction
    3. For position reductions, match against inventory
    4. Within currency groups, process interpolation, including those in
       position augmentations

    It should be possible to do something like this for cost basis adjustments:
       Assets:Account         -10 MSFT {34 USD}
       Assets:Account          10 MSFT {USD}
       Income:PnL             400 USD

    (See doc on Smarter Elision for a better version of this)


  - Brilliant idea!: Add Emacs functionality to run a special script that, given
    the filename and a line no (where the cursor is), will print the detail of
    the inventory _before_ the transaction, the transaction itself with all
    interpolated values inserted, and the inventory _after_ the transaction.
    You invoke this with the cursor on the transaction that you want to get
    debug output for. This would be powerful powerful for dealing with lots!!!


  - Deal with wash sales... complete doc, call MSSB to figure out if/how they
    adjust the cost basis of a future stock vesting event.



  - Idea: Add an option for triggering strict validation?

      option "processing" "strict" ; Plugins including the hardcore validation are run.

    Somehow making the hardcore validation into a plugin might be a good way to
    provide a strict mode.  Also, you could build a beancount.plugins.builtins
    module that defines the list of default plugins that gets run instead of
    having a list in the loader. This way the user could easily invoke it at
    any point in time.



  - (reports revamp) Write a generic test that simply enumerates all the
    reports and invokes them with their default values. This should extend
    automatically when new reports are created.


  - (trial balance) In order to zero out the trial balance perfectly, you could
    insert a conversion entry at the end of it, in the same way that I do for
    the balance sheet. There is no reason that this is any different; this
    should be done the same.



  - Build a 'events' report that will print out the current value of all events.





  - You need to create a unit test for @@ price conversions.

  - You need to unit-test for multiline notes... do they work as expected?




  (work on holdings)
  - Support output format "beancount" for holdings, use a single file instead of
    a holdings I/O file (merge holdings.csv + prices.beancount -> holdings.beancount)
    This would be much nicer.

  - Check holdings I/O by saving and reloading a list of holdings created from
    a set of entries (with sales, just to make sure).

  - In add_unrealized_gains(), convert to use our holdings aggregator.

  - Build a new category to portfolio to identify accountings holding
    "Uninvested Cash", which should be cash available to invest now.



  - (reports) We really do need to report on position reduction as TRADES. This
    is an important report to generate! This should be done separately from the
    improved inventory booking method.

    This report needs to include the long-term vs. short-term nature of those
    trades! The right way to do this is to run a separate plug-in that will
    add appropriate #long-term and #short-term tags or meta-data to those
    transactions, based on their booking dates..




  - (validation/performance) Optimize the performance of validations and bring
    all the HARDCORE_VALIDATIONS in by default.



  - (reports) Bring back the trades report into the mainline version, using
    inventory reductions.


  - Create a new report type: "days" that counts the days of any event in the
    filtered log.



  - Document args of C functions in the same way as Python's, perhaps using the
    new Python3 syntax definition thingamajig (I forget the name, there's a PEP).



  - Add the acquisition date to each Holding instance, so that short/long-term can be
    calculated for the lot.

  - Fetch the CSV holdings of each Holding and compute the full list of stocks I
    own from these ETFs in dollar value. Sort by larger to smaller. Also compute
    the industry with that. You need to write Vanguard download (harder, need to
    scrape), and iShares download (easier, CSV).


  - Move 'portfolio' and other experiments to be its own library, under the
    main source tree, validated and all.





  - In holdings: create the concept of a "composition" which can be associated
    to any holding, based on the (account, currency, cost-currency), and which
    is a vector of proportions to be normalized and associated to the holding.
    You should then be able to compute the sum total of all compositions. This
    should be a generalized concept, with the following applications:

    * Liquidity (how easy is it to get money out of this account?)
    * Taxability (pre-tax, roth, after-tax, usually 0 or 100%)
    * Sector, industry exposures
    * Currency exposure
    * ...





  - The creation of exceptions should be made easier: each error class should
    inherit from a base class that is able to accept an optional list of
    entries, that would automatically render the fileloc of each of those
    entries, and that would use the fileloc of the first entry in order to
    render the location of the error. If no entries are specified, an OPTIONAL
    fileloc= parameter should be provided to specify where the error occurs.
    This will make creating errors a lot easier and nicer.

    As part of this, we should also somehow produce a list of all possible
    errors with a lavish description.


  - Directive abstraction: Add directives should be able to enumerate they
    accounts. Maybe add a get_accounts() method to the base namedtuple or create
    a mixin. Remove getters.get_accounts() and getters.get_entry_accounts() if
    you have this, lots of code goes away, probably a good idea.

  - Try to run the tests using 'watchr', 'sniffer', 'autonose' or other such tool.



  - Look at Intuit's service for financial hub for financial data. Look for a
    developer account.

  - Do a presentation at meetup... Yodlee is in NY, might make sense.


  - New plugin: clean_payees, that processes the payee strings and cleans them
    up for display. How well can we do?

  - New plugin type: a kind of spreaded Pad directive, that creates multiple
    pads at regular intervals. This is to deal with smooth cash distributions or
    Google meals assignment. You should be able to specify the frequency and
    have it automatically insert a number of entries to spread the expense
    evenly. 'evenpad', 'multipad', 'distribution'? This should most definitely
    be a plugin.

  - I think if you relax the assumptions about having open and close accounts,
    those could even be moved to a plugin. Without this 'open_close' plugin,
    accounts would just get auto-created and no error output if they weren't.
    With the plugin, we would have current strict behavior. This means that
    non-plugin code that requires the full set of accounts from a list of
    entries would not be able to rely anymore on the presence of open entries,
    and so would the validation.

  - Put all the Pad into a single file as a plugin, same with Open Close, and
    Balance. Maybe we can organize those codes to be all localized in single
    files, and for many of these features, they can be implemented in
    self-contained plugins with all their codes together! openclose.py, pad.py,
    balance.py, etc. I think even 'event' directives can become those. And maybe
    a good way to disambiguate between ops adn plugins is just this... maybe ops
    is non-plugins, e.g. prices, summarize, etc.

  - Make the plugins able to register types with the parser... this should
    allow the parser to call back on the plugins to create the appropriate
    types... this means true extensibility throughout! This is a fantastic
    idea... do this after v2 ship.  Maybe they get parsed as a special "Unknown"
    directive that accepts a grab-bag of strings and tags and accounts and
    amounts and they get replaced by the plugins; whatever Unknown trickles
    through would generate a warning in the errors.

  - Setting the filename on options_map might help in making document
    processing alos as a plugin.




  (review types)
  - COOL! I can subclass the namedtuples!  Do this to make printing the
    postings and entries much easier.

      class Posting(_Posting):
          def __str__(self):
              return _Posting.__str__(self._replace(entry=None))

  - Also derive from namedtuple to provide a stable hash function instead of
    code in beancount.core.compare.

  - Can we make Inventory a subclass of 'list'?  That would be real nice, would
    make a lot of sense.



  - Prices: Write a script to output the timeline of required prices/rates in
    the database. Then use it to drive fetching a historical table of monthly or
    perhaps weekly exchange rates for USD/CAD, USD/AUD, EUR/USD since the
    beginning of my file. Make this script reusable.


  - Create an index page for all the possible reports, from the web page

  - plugin: Consider creating a plugin that would auto-create accounts not seen yet,
    for the purpose of making demos. Definitely must do.

  - parser: Make tags and payees "tagged strings", with their own data types.
    You can derive from str.

  - Rename "events" to "register"?  This makes a lot of sense.

  - Write doc about stages of life, "climbing the mountain."

  - Make the web application accept colons in URLs, and make the reports use
    them too, so that their names are the very same as those on the
    command-line.

  - Unrealized gains should not be added if the gain is zero.

  - In the 'print' report, add a comment at the end of each posting line with
    the balancing amount! This is an important debugging tool! Make this happen.

  - Make implicitly derived price directives generated by a transformation, as
    an explicit price directive.

  - (avg cost) To implement this, move all balancing to a stage after the
    parsing stage. Balancing the entries should be running right after parsing
    and will need to do a partial realization for the affected accounts only,
    for the postings with average cost. But in any case, all the balancing
    should move to a stage right after parsing and should not be an optional
    stage.

  - Remove legacy support for PIPE character in syntax, update cheatsheet.

  - For table rendering, move the actually formatting at rendering time. CSV
    files should have fractional values for percentages, txt and html should
    have % values.  I need to figure out a good solution for this.
    Maybe the thing to do is to move the field selection at rendering stage, or
    at least to have it at both.

  - Create special make target to run tests on my own large Ledger.
    This should bean-check, bean-roundtrip, bean-bake / scrape.

  - Hmmm... compare does not actually allow two identical entries in a file.
    Solve that, using a differentiator, such as the fileloc or file no, or
    something. Maybe while reading we should insert a version number in
    duplicate entries automatially? Not sure.

    Another solution would be to warn on duplicate entries!  Maybe we just
    don't allow these. It really wouldn't be much of a big deal. And this would
    be easy to implement as part of our load checks. They're more often than
    not errors.


  - Summarize Ledger's --limit --real --virtual --equity, etc. options.

  - Write a plugin to compute total tax/income


  - The balance sheet "close" problem - how do we specify closing at a
    particular point in time - can be solved by providing parameters to the
    report, e.g.

       balsheet:2014-01-01:2015-01-01
       income:2014-01-01:2015-01-01

    Of course, this needs conveniences. The period, if there is only a SINGLE
    ONE, should be interpreted as "from the beginning of this period to the
    ending of it (one over)". Otherwise, the meaning is the beginning of both.
    Here are other illustrative examples:

       balsheet  -> from BEGINNING OF TIME to NOW
       balsheet:2014  -> from 2014-01-01 to 2015-01-01  (most common)
       balsheet:2014-05  -> from 2014-05-01 to 2015-06-01
       balsheet:2014:2015-08  -> from 2014-01-01 to 2015-08-01

    The same goes for income.
    The nice thing is that I think we can now move the closing of entries
    within the report generation itself, instead of being at the top-level of
    the web app. This will be simpler and cleaner!



  (plugins)
    - Pad could be a plugin, definitely.

    - Balance checks could also be a plugin.

    - It should be possible to make the parser accept unknown directives that
      accept an arbitrary list of accounts and string parameters, like this:

        2014-06-01 unknown Assets:US:CreditCard "Something"




  (scripts)
  - bean-ledger: Write a script to convert to Ledger syntax. This should be
    easy!

      bean-convert -f FORMAT FILENAME

    * Convert to Ledger
    * Convert to HLedger
    * Convert to Penny

    Add an option to anonimify account names and perhaps some amounts as well.

  - bean-format or bean-align: Write a script to autoamtically align a region's
    transactions, or an entire file.

  - bean-query accounts: make a report that prints out just the chart of
    accounts using the list of parser entries, just the open entries,
    'bean-query accounts'

  - bean-query currency_dates: Write a script that will automatically fetch the
    dates I held various positions at cost for throughout the history and a list
    of weekly dates to fetch rates for. LedgerHub could use that to fetch all
    the prices it needs at reasonable intervals.





  - (code) Make Position into a namedtuple with hashing instead of just an
    object. See if we can remove its __hash__ method.

  - Also, look at all the objects in b.core.data, and see if you can override
    the hash function on them automatically in order to ignore the entry in
    postings, and the listness in entry.postings. It would be nice to be able
    to hash every directive type.

  - Does table.render_table support offsets for rendering regular tuples? It
    really should.


  - Check out bitbucket CGI interface w.r.t. linking to source code, is the
    newer hg better?  We should be able to link to specific lines in versions.

  - (idea) An interesting constraint would be to add an option not to allow any
    postings to any account that is not a leaf account.

  - (filter) Idea: For "virtual postings", you could mark certain tags to be
    excluded by default, to be included only explicitly. e.g. #virtual tag would
    have to be brought in by selecting it via "tag:virtual". Maybe a different
    prefix would be used to distinguish them, e.g. #virtual and %virtual,
    or #virtual and -#virtual; something like that.

  - (filter) Replace bean-holdings by "bean-query holdings", where "holdings"
    is just another type of report. All the reports from the view pages should
    be mirrored exactly in the command-line interface.

  - (high priority) Implement a debugging command in bean-doctor, that spits out
    the entries that were created from the input file, as it is being parsed.
    This should include auto-posting values, inserted price directives, and
    attached tags. This would be a powerful tool to help people debug problems
    with parsing, or not understanding its effects!




  - web: Don't render the full Inventory'es; instead, already render at cost and
    provide their full detail either by clicking on the transaction, which
    should render the full detail of an inventory (for debugging), or in a
    tooltip.

  - Write a script that will highlight some "payee vs tags vs subaccount"
    invariants:
    * Highlight payees that are always used with the same accounts
    * Same with tags

  - Write a script to align numbers... it has been too long and it's quite
    annoying indeed.

  - tree rendering: If a parent account has only a single subaccount and the
    parent account otherwise has no postings in its realization, render the
    account on a single line instead of two, e.g.

      Expenses                     Expenses
        Taxes                        Taxes
          US                           US
            TY2014                       TY2014
              State                        State:Google
                Google                     ...
              ...


  - Plan for integrating rendering and filtering between web/HTML and text
    versions:

    * Filtering: Should be done in a library used in common with the web server
      and a new tool, bean-query, which provides a command-line interface
      to trigger filter, e.g. filter by year, filter by tag, etc. The point is
      that the same code that does the filtering for views should be run from
      this command-line. The code that creates views perhaps should be moved to
      begin that library.

    * Rendering: The web reports, such as beacnount.web.journal,
      beancount.web.acctree, etc. should move to beancount.reports and have
      HTML and text versions of all these.

  - Implement --brief option on scripts.holdings, to be able to share, which
    renders only % holdings.

  - journal rendering: When multiple transactions occur in the same day, it
    may make sense not to render the balance amount until the last one. Test it
    out.


  - validation: We should check that entries created by plugins at some
    initialization point are pointing to the right parents (or maybe we should
    relax the need to set the parent and make that routine set it all at once:
    time this, it it's very small, do this on initialization and that makes it
    easier to write plugins for users and you can do away with entry_replace().)

  - bake: Make bake support curl if wget is not available. It should work with either,
    to relax dependencies.

  - Price entries should have an extra attribute to disambiguate between
    implicitly created prices, linking to the original transaction that created
    them, and explicitly created ones.

  - A table of price entries should be rendered under the price graph in the
    web interface.

  - Web interface: Instead of rendering inventories with the full contents in
    the journal, render the cost, and place the full inventory in a tooltip!

  - Here's how to improve booking against lots!

      "Dealing with average cost trading or cost basis readjustments (not implemented
      yet) involves joining together multiple lots and recreating new ones in a way
      that preserves the total cost in the inventory; with this data structure /
      model it's quite obvious how to implement them as basic operations on an
      inventory.

      I really like the simplicity of this and am wondering if we could make it even
      simpler.

      Automatic booking against an inventory, e.g. adding automatic FIFO or LIFO,
      would require having the date of each lot always inserted in the key of the
      inventory items (from the transaction, not from the lot-date field), along with
      special rules for selecting which lots a posting is allowed to modify,
      essentially ignoring the lot-date from the inventory if the posting does not
      specify it. This is partly why I'm considering making the "lot-date" compulsory
      and adding a "lot identifier" used to disambiguate booking against an inventory
      with multiple matching lots of the same cost with just differing dates, which
      would only be required if the posting constrains it to. One can imagine
      relaxing the matching rules between a posting and inventory further to allow
      one to just specify "-40 GOOG" above, without a cost, and if unambiguous, to
      allow it to just select the only lot that is available."

    Idea: Generalize lot-date to just a "lot" string. Doesn't have to be a date
    at all! It would also make the concept and usage intentions clearer I think.

  - Lot improvement: the lot specification on a reducing posting is only present
    to disambiguate which of the lots to reduce or match against. Maybe we
    should provide a different syntax when an expected reduction takes place,
    this would be allowed:

       (augment)
       2014-06-17 *
          Assets:US:Investing:GOOG    10 GOOG {523.45 USD / i-want-more}

       (reducing) All of the following should be allowed:
          Assets:US:Investing:GOOG    -7 GOOG ; possibly ambiguous
          Assets:US:Investing:GOOG    -7 GOOG [] ; possibly ambiguous
          Assets:US:Investing:GOOG    -7 GOOG [523.45 USD]
          Assets:US:Investing:GOOG    -7 GOOG [2014-06-17]
          Assets:US:Investing:GOOG    -7 GOOG [i-want-more]

    By enforcing a distinct syntax, the user is telling us that this leg is
    expected to reduce an existing position. This information is useful, in
    that it avoids possible mistakes. I like the explicitness of it.

    Sufficient debugging output should be provided from the "print" command to
    be able to identify which lot is being matched against and why. We need to
    provide more transparency into this.

  - FIFO or LIFO booking could be "enforced" simply by declaring the expected
    booking method of an account, and then issuing an error when explicit
    entries deviate from that method. This is an easy idea... would be very
    useful. The automatic method would only be used to resolve ambiguity! This
    is nice.

  - Implement a little plug-ins system that allows a user to insert a TAB in
    bean-web.

  - The Trial Balance page could be a good place to put all the accounts on the
    left and have two sets of columns: beginning of period -> end of period.

  - Implement a little plug-ins system that allows a user to insert a new tab in
    bean-web, with custom display.

  - In ledgerhub, use /usr/bin/strings as a last resort if all other PDF
    converters fail.

  - When we import, if a file was not detected, don't spit out an org text
    line. Still doesn't work.

  - In order to implement .txt output, you will need to decouple the web
    rendering and the generation of its included data. This will be
    great--ability to cut-and-paste any page into txt. format=txt, and we could
    still have the links clickable. Everything else would just be txt. A bit of
    a crazy idea, but it might work well and be simple. Maybe.

  - Bug: A transaction like this fails to parse; allow it:
      2014-02-22 * "Payee" |
        ..

  - Serving CSV files from the Documents page should not be via download, but
    rather rendered directly.

  - The documents web page should render by-month + date, and by-account + date.


  - DO implement output to text NOW for posting on the mailing list.

  - Add views for the last 5 days, one day only each day (for D.Clemente)

  - Add preliminary support for renaming root accounts, even if that means the
    option must come first in the file. Move the checks in the parser.

  - In rendering balance directives, don't render the amount in the "change"
    column; that is too confusing for some users, keep the change column for
    changes.


  - update activity: remove parent accounts with no child accounts.
  - update activity: this exhibits a bug in the table rendering, look for IVV,
    see TODO(blais) in acctree.py

  - Begin user documentation in earnest; we really need this soon.
  - Complete example file with income statement transactions.

  - URGENT - Provide some tooltip or help link from the main page to allow
    discoverability of what a "view" is.

  - URGENT - the level1/2 views are EmptyView's, you need to implement those!

  - Example files (suggestion from Daniel Clemente):

      > >   I think 2 files can be helpful:
      > >
      > >   1) A simple one, a „how to“ file with ~20 transactions, or better, from 1
      to 3 transactions for feature. To show the normal things like receiving a
      salary, getting money from ATM, wire transfer, pay the bills, … So that it does
      not scare people without experience in double accounting.
      > >   demo.beancount fits this place.
      > >
      > >   2) The big one (1 year, you said), to show off that beancount is powerful
      and is really used for long-term accounting. This one is the „inspirational“
      one, to make people say „I would like to do that!“.

  - beancount: GREAT IDEA: output a subset of transactions as a spreadsheet. You
    need to design a textual way to refer to a subset of transactions. Output in
    either directions, without currencies.


  - BUG! import this:
    documents/2013/Assets/CA/RBC/Checking/2013-11-13.ofx84423.qbo
    * The balance check at the end is incorrect
    * The statement are not organized by account; they are mixed together

  - Create a 3rd-party dependencies building script for Mac OSX users (fxt).

  (Cost Basis)
  - Cost basis issue: How do I take into account the commissions and fees
    adjustment on the cost basis for a position?
  - How do I take into account Wash Sale Adjustments to the cost basis?

  - entries_table() really should be called postings_table().

  - Complete parser tests
    * Modify the lexer to emit EOF and add that in the grammar rules for empty_line.
    * BUG: Don't crap out when you can't read the file; error should be reported
      like the other ones.

  - You need to validate the account name options (empty, or no :, use regex to constrain).

  - Move utility functions from bean-prices to a reusable place.

  - Have another script that takes that as input and spits out current positions
    in the market on a web page; CGI script, should be served on Furius. Update
    via a Mercurial repo push.

  - Render tags

  - IMPORTANT FEATURE: Text/XLS exports

  - IMPORTANT FEATURE: Flip balances for rendering

  - IMPORTANT FEATURE: Implement Average Booking for Vanguard & RBC Adjustment,
    with associated tests and syntax in the parser.
    Update for inventory.py:

      def average(self):
          """Merge all lots of the same currency together at their average cost.

          Returns:
            A new instance of Inventory, with all the positions of each currency
            merged together at cost, bringing all these positions at average cost.
          """
          logging.warn('FIXME: continue here, this will be needed to report positions')
          # FIXME: This is ill-defined, the grouping must also take into account the cost currency.

          units_map = defaultdict(Decimal)
          costs_map = defaultdict(Decimal)
          for position in self.positions:
              lot = position.lot

              cost_currency = lot.cost.currency if lot.cost else None
              key = (lot.currency, cost_currency)
              units_map[key] += position.number
              costs_map[key] += position.get_cost().number

          inventory = Inventory()
          for lotcost_currencies, units in units_map.items():
              lot_currency, cost_currency = lotcost_currencies
              cost_number = costs_map[lotcost_currencies]
              inventory.add(Amount(units, lot_currency),
                            Amount(cost_number, cost_currency),
                            allow_negative=True)

          return inventory


  - Render the OFX / QBO files in a <pre> tag, or figure out why the mimetype
    is incorrect and they don't render properly. Right now the default
    rendering of the browser is insufficient.

  - (IDEA) Why aren't we using the price on the first leg of this transaction?
    This is an interesting variation on the meaning of the price: it could mean
    either (a) the price of the lot, or (b) the conversion price of the cost of
    the lot. This would enable the following:

        2013-07-22 * "Bought some US investment in a CAD account"
          Assets:Investment:GOOG           50 GOOG {700 USD} @ 1.01 USD   ;; 35350 CAD
          Assets:Investment:Cash          -35359.95 CAD
          Expenses:Commissions                 9.95 CAD

  - (IDEA) In order to create suitable stock split entries that would look like
    this:

      2013-04-01 * "split 4:1"
        Assets:CA:ITrade:AAPL             -40 AAPL {{5483.09 USD}}
        Assets:CA:ITrade:AAPL             160 AAPL {{5483.09 USD}}

    You could easily add support for a directive that looks like this:

      2013-04-01 split Assets:CA:ITrade:AAPL  4:1  AAPL

    This would allow the user to do some processing specific to stock splits by
    processing the explicit stock split entries.

  - Include this in the user examples, + stock splits:

       2013-04-01 * "name change"

         Assets:CA:ITrade:AAPL             -40 AAPL {{5483.09 USD}}
         Assets:CA:ITrade:NEWAAPL             40 NEWAAPL {{5483.09 USD}}

       2013-04-01 * "spinoff"
         Assets:CA:ITrade:KRFT             -100 KRFT {{20000 USD}}
         Assets:CA:ITrade:KRFT              100 KRFT {{17000 USD}}
         Assets:CA:ITrade:FOO                20 FOO  {{ 3000 USD}}

  - Remove the parsing of "CHECK" at some point, that was just there for
    compatibility.

  - More testing:

       # FIXME: Test a conversion of shares with lot-date, e.g.:
       #
       #   2000-01-18 * Buy CRA
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA           4 "CRA1" {232.00 USD / 2000-01-18}
       #     Assets:CA:RBC-Investing:Taxable-CAD               -1395.43 CAD @ 0.665027984206 USD  ; cost
       #
       #   2000-02-22 * CRA Stock Split 2:1
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA          -4 "CRA1" {232.00 USD / 2000-01-18}
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA           8 CRA {116.00 USD / 2000-01-18}


  - Add a validation check, that when closing and account, its balance is empty/zero.

  - Render a journal as a detailed expense report, for a set of accounts
    (e.g., Expenses:*) pulling out amounts in various columns based on other
    expressions (e.g. Assets:Cash:Caroline).




  - Idea around documents: A link between a transaction to a document can be
    created by associating a document's checksum as the link of the
    transaction. If Beancount could associate them - and it could, it has
    access to the document files and the corpus of transactions - the web
    interface could insert a special link between the two. Maybe we could do
    the same thing with the filename as well.

  - A better idea to do this would be to allow specifying an explicit document
    directive, and finding document directives from files that are already
    specified should not re-create them. This way you can specify both the
    document and a transaction and use a common link as a natural way to
    associate them, e.g.:

       2014-06-20 document Income:US:Google:GSU "2014-06-20.google.0000000.pdf" ^ee63c6fc7aa6

       2014-06-20 * "GOOGLE INC       PAYROLL" | "Refund for fractional shares" ^ee63c6fc7aa6
         ...
         ...

  - Document finding from files should not create documents that have been
    explicitly specified in the ledger. Avoid duplication! This is an important
    fix to make, that will allow both to co-exist together.






  - Implement beancount.plugins.tag_pending as a general feature of links...
    this ought to be built-in by default, this is a great idea.


  - (prices) When attempting a conversion in holdings, if the rate isn't
    available directly, you should always attempt to value it indirectly via
    USD or EUR.

  - Maybe the builder should have a 'filename' state that only gets changed here
    and there instead of getting that fileloc argument passed in every time on
    every rule. Maybe we just always get the fileloc from the parser.c as in
    NUMBER. I think it might make the parser more efficient too... try it out,
    do timings, see how much it improves parsing performance.

  - See if you replace BUILD()'s PyObject_CallMethod to this how much faster it
    gets: "Note that if you only pass PyObject * args, PyObject_CallMethodObjArgs() is a
    faster alternative."
    https://docs.python.org/3/c-api/object.html


  - Allow short sales eventually. This should already work if all that you do is
    selectively suppress the validation check that verifies that a position at
    cost may not go negative. We could selectively suppress it by adding a flag
    to the open directive associated with an account, or maybe adding some
    special syntax in the cost specification that allows us to do this.



  - Create Inventory.from_string() and simplify a lot of the tests with it.


  - Inventory._add() only gets called with allow_negative=False in very few
    places; replace the error it return from an exception to just a return code.

  - Simplify all tests by using their from_string() converters. All
    constructors should accept a single string, and that should call
    from_string() automatically, Amount, Position, Inventory, etc.




  - Create a new directive for balance that checks for the complete balance.
    Ideas for syntax:

      2014-06-20 balance      Assets:Some:Account    10 GOOG, 640.40 USD   FULL
      2014-06-20 balance      Assets:Some:Account    [10 GOOG, 640.40 USD]
      2014-06-20 balance      Assets:Some:Account    <10 GOOG, 640.40 USD>
      2014-06-20 balance*     Assets:Some:Account    10 GOOG, 640.40 USD
      2014-06-20 full_balance Assets:Some:Account    10 GOOG, 640.40 USD

    Maybe we should define a general syntax for input'ing an Inventory object,
    that could be read at parsing time.


  - Create a command in bean-doctor which lists all of the lots and their
    changes for a particular account. This is meant to be a debugging tool for
    booking algorithms. The rendering should be clear and detailed.




  - Implement a "fuzzing" input generator, that will output a very large input
    file with all possible kinds of combinations, to see where Beancount hits
    its limits and perhaps bring up some bugs from input I haven't thought of.
    This is easy and fruitful.


  - Replace gviz by some other library that does not require you to be online.


  - Consider whether we can actually remove posting.entry (I think it is only
    used in the realization) and thus make it easy to create transactions
    programmatically.


  - (performance) Profile the web pages, if account_link() is high, provide an
    explicit cache for each unique view. (We had to remove this when we
    simplified the function using build_url for adding tests.)

  - (performance) Implement the stable hashing function in C and reinstall the
    validate_hash test.

  - (performance) Implement inventories in C and reinstall the
    validate_check_balances test.

  - (performance) Don't pass in the FILE_LINE_ARGS on function calls, these
    should be part of the context of the parser, should be gettable only on
    demand.

  - Can I use Py_RETURN_NONE in order to incref and assign, in the lexer,
    instead of doing it in two steps?



  - Add an optional parameter to the loaddoc() and parsedoc() decorators to
    have them automatically check for expected no-errors.


  - Add the acquisition date of each lot to each Holding, and it should be
    output at that date by print_holdings as well.



  - In order to relax the constraint that you may not add negativ units at
    cost, we could only disallow under certain circumstances:

    * An account has received units in the opposite direction
    * If the posting cross the zero boundary. Maybe starting from zero in
      either direction could be fine.

  - Idea: You could add a further constraint property to an account name: that
    the amounts may never be allowed to balance to a particular sign. This
    could be useful to avoid data entry mistakes. You could even write a doc
    just focused on all features designed to avoid data entry mistakes.



  - Idea: Relax checks for negative values: from docs

      "PLEASE NOTE! In a future version of Beancount, we will relax this constraint
      somewhat. We will allow an account to hold a negative number of units of a
      commodity if and only if there are no other units of that commodity held in the
      account. Either that, or we will allow you to mark an account has having no
      such constraints at all."

  - You could make the narrations for padding and summarization transactions
    specifiable via options.

  - Silence BrokenPipeError errors from bottle using wsgiref. You could use
    CherryPy, which doesn't suffer from that, or just... fix it and silence
    them.


  - Do support rendering options to invert the amounts of the minus accounts.
    This is an important feature.


  - (sanity check for conversions) Insert a validation check when transferring
    amounts to the balance sheet that the implied rate of the conversion entries
    is within certain bounds of the price, for each pair of commodities (find a
    way). These bounds should be proportional to the variance of the price. This
    would just provide an extra amount of good fuzzy feeling, knowing for sure
    that my solution to the conversions problem is always meaningful and
    correct.


  - (plugin/validation) Consider a strict validation plugin that kicks off
    errors when amounts are posted to accounts which have children. Basically,
    make it possible to disallow postings on accounts with children.






  - (parser) Make a version of C's beancount.core._parser.parse() that parses a
    string directly, instead of our current solution which involves writing to a
    temporary file. This may be faster and avoid leaking test beancount contents
    to a temp file by accident:

      PyObject* parse(PyObject *self, PyObject *args, PyObject* kwds)
      /* FIXME: Make a version of this which takes a string as input! For
       * unit-testing... */

  - (parser) Support enabling flex debugging in beancount.core._parser.parse(),
    using "yyset_debug(int bdebug)".


  - Interesting idea: Maybe instead of returning errors, "errors" could simply
    become "Error" directives and be inserted into the flow, and picked up by
    the various rendering routines in different ways?!?  I love this. One less
    thing to return. Hmmm ponder it seriously.

  - Remove support for legacy, PIPE, Not needed.

  - Require Python 3.4 and introduce Enum's where relevant.



  - Support in test_utils.capture('stdout', 'stderr') as (stdout, stderr).
    Replace all nested code that is inconvenient.



** Refactoring: Holding to Position

  - I think there's a way to simplify holdings: you can probably remove the
    "Holding" type and replace that with a Posting, which really, is much like a
    Holding, it has an account and a position, and a price.... That would
    normalize Holding quite a bit, even if it means we end up adding a few
    unused slots to Posting. I'm happy to do that! Simplify simplify simplify...
    always.


** File Input as Environment Variable

  - It might be really nice if all the commands would accept an environment
    variable for the default file to use, if set. This means that the Beancount
    filename could be an option like in Ledger and HLedger, e.g. with -f. It
    *IS* true that in almost all cases I'm using the one, same input file for
    all the programs, that is, the concept of a "default" is quite common.

    This should probably go in before the first release because it has highly
    visible impact on all the bean-query commands.


** Prepare for Plugins Revamp

  I recently teased out that many of the basic functions can be implemented as
  individual stages of transformations on the list of directives. This started
  out as a way to add plugins by adding a custom transformation stage, but now
  I see that if I can make the parser able to consume generic syntax that might
  allow extensions, and to allow these plugins to specify new directive types
  for extensions, I might be able to shove a *lot* of the existing
  functionality into nice isolated plugin modules. Even functionality as basic
  as Balance checks.  I'm not going to to do this in the first release, but I
  want to set the stage for it.
** Precision

  - (precision) FIXME: The better way to render numbers at the end would be to
    let the user specify a desired rendering precision for each currency. Deal
    with this throughout better.

       "Hmm, that's right, I should probably set a maximum precision for rendering
       numbers which require more digits than the default of 2. This is an
       interesting one: I need to do something a bit more thorough about precision; 2
       is not appropriate for everything either. I need to figure out a way to let a
       user specify a desired rendering precision for each currency...
       (probably via some options, unfortunately). In the meantime, I've made it so
       that the max number of digits rendered is 5.

       There's also the issue of setting the max digits during arithmetic operations,
       which should also not be 28. I'll deal with that later."

  - Automatically detect precision of each currency based on usage in file:

      (Idea from Daniel Clemente): "You could use auto-detection: for each
      currency, use the maximum number of decimals that the input file used. E.g.
      if user writes 351.64 PLN, 151.1 PLN, 155 PLN, then use 2 decimals.
      Alternatively, use "the most common" number of decimals. If 90% transactions
      have 3 decimals, 5% have 4, 5% have 0, use 3."


** Padding documentation from email

  - Put this in the docs to explain "pad"

     > > Ok, restarted example, let's say you begin
     > > accounting in dec 2013, you'll have this:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >
     > > eventually, moving forward, you'll get to 2014:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >   2014-12-06 * ...
     > >
     > > Allright, now you decide you like this, and you
     > > want to enter statements before you started.
     > > You find your paper statement for november, and
     > > fill in:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   ; here you insert
     > >   2013-11-04 balance
     > >   2013-11-08 * ...
     > >   2013-11-18 * ...
     > >   ...
     > >   ; this is what was there previously
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >   2014-12-06 * ...
     > >
     > > Great. Now, notice how the balance for
     > > 2013-11-04 is probably different than that of
     > > 2013-12-04. If instead of a pad directive you
     > > had added a manual adjustment, you'd have to
     > > change it here. This is the beauty of the pad
     > > directive: it automatically does it for you.
     > >
     > > Now, let's keep going backward in time. You dig
     > > around your records, you find September's
     > > statement, but you cannot find the statement
     > > for October, maybe it's lost, or somewhere
     > > else. Fine! You insert a pad directive to
     > > account for those missing transactions:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >
     > >   2013-09-04 balance
     > >   2013-09-05 * ...
     > >   ... september transactions
     > >   2013-09-30 * ...
     > >   2013-10-04 balance
     > >
     > >   ; padding for missing October statement,
     > > where is my statement?
     > >   2013-10-04 pad
     > >   2013-11-04 balance
     > >
     > >   ... november transactions
     > >   2013-11-08 * ...
     > >   2013-11-18 * ...
     > >   ...
     > >   2013-12-04 balance
     > >
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >
     > >   2014-12-06 * ...
     > >
     > > This is the full example.

Improve this bit:

    >   But the detailed explanation cannot be found. There's only one phrase: „Think
    >   of the Equity account as something from the past that you had to give up in
    >   order to obtain the beginning snapshot of the Assets + Liabilities balance.“
    >
    > Great comment. I'll improve this.

 More user comments:

    >   After doing my research, I found about debits and credits, which in Beancount
    >   you represent with positive numbers and negative numbers respectively. I
    >   found that having a name for each group of accounts helps me to think of them
    >   at the same time, e.g. Liabilities+Equity+Income as part of a common thing,
    >   instead of having to research each of it independently.
    >   In the documentation you start speaking about numbers, then about signs, then
    >   about grouping the accounts. Maybe it's better to go top-down and start
    >   saying that there are two types of account (usually +, usually -) and then
    >   divide each group further.
    >
    > I will change that, thanks for the comment.


* Core
** General

  - Make all imports outside of packages import from the package root, and have
    the package export those symbols explicitly.

** Inventory

  - inventory: rename get_cost() vs. get_cost_position(). Swap them, change all
    the code that needs be changed.

  - Inventory: Implement a test for Inventory.get_amounts() with multiple lots of the same
    currency; they really should have been aggregated.

*** Book at Average Price

  - Inventory: Implement averaging of lots in order to report positions nicely.

  - We should create a syntax and method for booking to the average value.
    Figure out how many units of each position to remove in order to obtain the
    average sale price. This way the user could potentially switch methods.

*** Making adjustments of capital

  - Figure out how to make these kinds of adjustments:

      My name is Ian and I will help you with profit/loss and book value reporting.
      2013-04-19 RTC RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 RETURN OF CAPITAL ADJUSTMENT TO BOOK COST $60.71
      2013-04-25 ADJ RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 NOTIONAL DISTRIBUTION ADJUSTMENT TO BOOK VALUE $2,963.13
      Before you make accounting entries, it is a good idea to understand the underlying transactions.

      ETFs such as XSP, make distributions throughout the year, however they do not know the composition of the income distributed until
      after year end when the trust completes their tax return. When the income in the trust from dividends, capital gains, and income
      are not sufficient to account for all the distributions, the excess distribution is classified as 'return of capital'. Return of
      capital (ROC) is simply some of the capital you paid to buy the fund being returned to you. The ROC amounts are not taxable and
      you deduct them from your XSP book value. The XSP deduction for 2012 is C$60.71 and should be deducted from your book value in
      your April 2013 statement.

      Notional dividends result from the exchange traded fund (ETF) realizing capital gains and/or dividend income then reinvesting the
      gains/dividends in some other security(ies). No cash or reinvested units were distributed to investors but they still have to pay
      tax on the gains/dividends realized within the ETF. When a notional dividend is made, the dividend is included in income and the
      amount of the notional dividend is added to the book value of the underlying security. So you end up paying tax on the dividend up
      front and get a reduced capital gain or increased capital loss when you eventually sell the ETF.

      In your XSP example, if you held the ETF in a taxable account, the notional dividend would be fully taxable as C$2,963.13 income
      for your 2012 return. Your book value would increase by C$2,963.13.

      The book value of XSP for 4,100 units in your March 2013 statement was C$57,127.11. The return of capital reduces your book value
      and the notional dividend increases it so your book value at the end of April 2013 would be C$57,127.11 - C$60.71 (return of
      capital) + C$2,963.13 (notional dividend) = C$60,029.53.


*** Lots

  - Matching on Inventory Lots should be *loose*: try to match automatically
    against the most SPECIFIC lots.

         (AAPL, 18.45, nil) -> +1
         (AAPL, 17.93, nil) -> +1
         (AAPL, nil, nil)   -> -1    ... should choose any of the inventory

    Also, maybe the inventory's date should be filled in automatically by the
    parser... just an idea. Maybe date doesn't have to be allowed to be nil.


*** Original Idea Description for Integrating the Cost Basis in Beancount

  - Every account carries a cost basis.

  - You can have posting with or without a cost-basis.

  - If the posting has a cost-basis posting, the cost-basis is used to balance the
    transaction.

  - As you sum up the postings in the account, keep track of the full inventory as

      (commodity, cost) -> quantity

    As a special case, "cost" can be null. This is the case where there is no cost
    tracking for this commodity item. We maintain the full inventory of positions
    with a cost basis in the account; as a default case, the cost is null.

  - BALANCE CHECK: When balancing a transaction, if an amount has an associated
    cost basis, use the cost basis instead of the actual amount to balance.

  - INVENTORY CHECK: When a position is modified in the inverse direction,
    require a cost to book against. If no cost is specified, it just degrades to
    decrease from the bucket of commodities with a null cost (it all works out!)

  - ZERO CHECK: Insure that the quantity can never be negative for any bucket.

  - Optional extended check syntax: You could extend the @check syntax to include
    the cost, so that technically you could check that there are a specific number

  2013-03-01 * buy
    Assets:Checking        10 GOOG # 700 USD
    Assets:Investment     -7000 USD

  2013-03-15 * sell
    Assets:Checking       -10 GOOG # 700 USD @ 800 USD
    Income:RealizedPnL    -1000 USD
    Assets:Investment      8000 USD


  Syntax

  Test: Items of the same kind with and without cost basis
  Test: Multiple items of different types with a cost basis in the same account

** Realization

  - You need to convert some of TestRealization to TestCheck.

  - Whether an account shows up in a particular Ledger (realization) really only
    should depend on whether the account was open during the period (we now have
    account open/close dates... let's use them instead of a heuristic!).
    Create a routine to figure out if an account was open during a specific
    time period?

*** Average Price Booking

  - You now HAVE to implement average price tracking... not an option. Thanks
    to Vanguard #$(*#(*$.

** Prices

  - There should be a corresponding view/presentation for rendering information
    that we have about prices.

  - Build helpers tools for users to create their own scripts that will allow
    you to spit out a list of prices for the price DB.

  - Include directives will be necessary for update, because it will enable
    including the file of prices only. The prices should be in beancount
    language too, this should all be a single file format.

* Filtering
** Beancount reorg

  - Remove subaccounts for TMobile and employer once we have filtering working
    out nicely. Same with RedSquare electricity. Same with Employer subaccounts
    for taxes.

      Payees are just like tags!


** Views

  - Replace all views by filtering queries... the root page should still have
    convenient links to various preset views, like the last five years, but
    these links should be implemented using the filtering query feature!
    Maybe it's worth allowing the user to specify common queries in the options
    map, and provide links to them. Do this, and try removing some of my
    subaccounts to simplify the accounts-trees somewhat.

  - The root page should feature a prominent input form that allows the user to
    specify a query! This input needs live at the very root

  - (views) You should be able to filter to all transactions related to some
    account, e.g. Immigration

  - IMPORTANT! Try to let through some of the non-transaction entries in the
    view filtering. We obviously cannot let through balance entries, but
    documents yes, depending on the type of filtering. We should do our best to
    let all the entries carry through.

** Filtering dimensions (Old Notes)

  - By Country

    - You should be able to look at only accounts with a particular pattern (and
      their other legs), e.g. *:CA:*

    - You perhaps should flag all the transactions that have a particular unit
      (e.g. CAD)

  - By Account Prefix

    - Specify a single account, and automatically select all the other accounts
      which are linked by any transaction in this account; generate a balance
      sheet from this list of accounts. e.g. Expenses:Trading, Income:PnL,
      Assets:Trading.

  - By Amount Size

    - I'd love a way to filter down a journal by omitting all the small
      items and keeping just the larger ones, to get an automatic
      overview of the large amounts in a long series of transactions.
      All the small amounts could be lumped together under a special
      entry.

  - By Institution

  - By Country

  - By Tag

  - By Payee

    * You should be able to click on a payee to view its transactions.

  - By Date

    - You should be able to click on dates and see all postings around that date
      too, e.g. +/- 10 days. Another simple and useful filter.

  - By Event (defines a period)

    - "How much did I make during the period of this event", e.g. while I was
      working at CompanyX, while I was in school at UniversityY. This provides
      two dates, generate a view for them:

        /view/event

      This could sum up all the entries for all the internals where the event's
      value was the same.

  - By Currency/Cost-Currency

      You could then possibly compute the IRR around that commodity...


** Custom dimensions

  - From discussion:

       | (digression not about virtual postings but answers auxiliary questions about
       | them)
       |
       | Now this points to a more general idea that I've been pondering for a while:
       | these "accounts" can often be seen as a set of flat dimensions, the fact that
       | they have a hierarchy can get in the way. I tend to have accounts that look
       | like this:
       |
       |   TYPE:COUNTRY:INSTITUTION:ACCOUNT:SUBACCOUNT
       |
       | like this, for example:
       |
       |   Assets:US:HSBC:Checking
       |   Assets:CA:RBC:Savings
       |
       | For these four dimensions, I actually like having most accounts (Assets,
       | Liabilities and Income) specify them in this order. This does not always make
       | sense though, especially for expense accounts; for those you wouldn't really
       | want to have a COUNTRY dimension at the root. You want the general category
       | only, so I'll have, for example:
       |
       |   Expenses:Food:Restaurant
       |   Expenses:Food:Grocery
       |
       | but sometimes the dimensions get inverted too, like in my recent change about
       | how to track taxation:
       |
       |   Expenses:Taxes:US:TY2014:Google:Federal
       |   Expenses:Taxes:US:TY2014:Google:StateNY
       |   Expenses:Taxes:US:TY2014:Google:CityNYC
       |   ...
       | Here the "institution" is Google, and shows deeper in the hierarchy.
       | Finally, you often do want to have multiple types for the same or similar
       | accounts, for instance, to track gains and dividends income from a particular
       | investment account, you want a mirror of most of the dimensions except for the
       | assets bit:
       |
       |   Assets:US:ETrade:IRA -> Income:US:ETrade:IRA
       |
       | For instance:
       |
       |   Assets:US:ETrade:IRA:Cash
       |   Income:US:ETrade:IRA:Dividends
       |
       | You see what I'm getting at... these components really operate more like a
       | database table with values possibly NULL, e.g.,
       |
       |   type     country  institution  account   category
       |   -------- -------- ------------ --------- -----------
       |   Assets   US       HSBC         Checking  NULL
       |   Assets   CA       RBC          Savings   NULL
       |   Assets   US       ETrade       IRA       Cash
       |   Income   US       ETrade       IRA       Dividends
       |   Expenses NULL     NULL         Food      Restaurant
       |   Expenses NULL     NULL         Food      Grocery
       |
       | Having to order your account components in a hierarchy forces you to
       | decide how you want to report on them, a strict order of grouping from
       | top to bottom.
       | So I've been thinking about an experiment to rename all accounts according to
       | dimensions, where the ordering of the components would not matter. These two
       | would point to the same bucket, for example (changing the syntax slightly),
       |
       |   Expenses|Taxes|US|TY2014|Google|Federal
       |   Expenses|US|Google|Taxes|TY2014|StateNY
       |
       | You could then display reports (again, the usual reports, balance sheet,
       | income statement, journals) for "the subset of all transactions which has one
       | posting in an account in <set>" where <set> is defined by values on a list of
       | dimensions, a bit like a WHERE clause would do.
       |
       | Now, now, now... this would be a bit radical, now wouldn't it? Many of these
       | accounts do point to real accounts whose postings have to be booked exactly,
       | and I'm a bit worried about the looseness that this could introduce. One and
       | only one account name for a particular account is a nice property to have.
       |
       | So what can we do to select across many dimensions while still keeping
       | hierarchical account names?
       |
       | The first thing I did in Beancount is to create views for all unique account
       | component names. For example, if the following account exists:
       |
       |   Assets:US:ETrade:IRA
       |
       | You will see four "view" links at the root of the Beancount web page:
       |
       |   Assets
       |   US
       |   ETrade
       |   IRA
       |
       | Clicking on the link selects all the transactions with a posting with an
       | account where that component appears. (Views provide access to all the reports
       | filtered by a subset of transactions.) You can click your way to any journal
       | or report for that subset of transactions. This exists in HEAD today. You can
       | draw all the reports where a particular component appears, e.g., "Google", as
       | in "Income:US:Google:Salary" and "Expenses:Taxes:US:TY2014:Google:Federal".
       |
       | But this does not define "dimensions." It would be nice to group values for
       | these components by what kind of thing they are, e.g., a bank, an instution, a
       | country, a tax year, etc, without regard for their location in the account
       | name. A further experiment will consist in the following:  again assuming
       | unique "account component names" (which is not much of a constraint to
       | require, BTW, at least not in my account names), allow the user to define
       | dimensions by declaring a list of component names that form this dimension.
       | Here's how this would look, with the previous examples (new syntax):
       |
       |   dimension employer  Google,Autodesk,Apple
       |   dimension bank      HSBC,RBC,ETrade
       |   dimension country   US,CA,AU
       |   dimension taxyear   TY2014,TY2013,TY2012,TY2011,TY2010
       |   dimension type      Assets,Liabilities,Equity,Income,Expenses (implicit?)
       |
       | You could then say something like "show me trial balance for all transactions
       | with posting accounts where bank is not NULL group by bank" and you would
       | obtain mini-hierarchies for each group of accounts (by bank, across all other
       | dimensions).
       |
       | (With the state of my current system, I could probably code this as a
       | prototype in a single day.)
       |
       | Addtionally, accounts have currency constraints and a history of postings
       | which define a set o currencies used in them. More selection can be done with
       | this (e.g., show me all transactions with postings that credit/debit CAD
       | units).
       |
       | IMHO, all you're trying to do with these virtual accounts is aggregate with
       | one less dimension, you want to remove the real account and group by community
       | project. My claim is that there are ways to do that without giving up o the
       | elegant balancing rules of the DE system.

    In ealtion to this... these "dimensions", could they just become other
    dimensions in the filtering language?

      component:Google

      employer:Google
      bank:RBC
      country:US

    You can then break down by those, like a GROUP BY clause, and generate
    reports that have those as root accounts, or separate breakdowns.


** Tags used as dimensions

  - If you had tags as key-value pairs, those could be used as well:

      2014-05-21 * ...
        #employer:Google

    Searching for:

      tag:employer=Google

    This is another dimension in the same filtering language.


** Language
https://docs.google.com/document/d/1d88MkHqxiVdF8XSQBT1QQpOKEOt6OC1P9ZoF3u86DwI/

* Operations
** Validation

  - Write a dedicated routine to check the following invariant:

        # Handle sanity checks when the check is at the beginning of the day.
        check_is_at_beginning_of_day = parser.SORT_ORDER[Check] < 0
        ...
        if check_is_at_beginning_of_day:
            # Note: Check entries are assumed to have been sorted to be before any
            # other entries with the same date. This is supposed to be done by the
            # parser. Verify this invariant here.
            if isinstance(entry, (Check, Open)):
                assert entry.date > prev_date, (
                    "Invalid entry order: Check or Open directive before transaction.",
                    (entry, prev_entry))
            else:
                prev_entry = entry
                prev_date = entry.date

  -  Sanity check: Check that all postings of Transaction entries point to their
     actual parent.

  - (validation) In addition to the Check/Open before-constraint, check that
    the entries are always sorted. Add this sanity check.

  - The default validation should check the invariant that Open and Check
    directives come before any Transaction.

  - Validation: Everywhere we have a filter of entries to entries, we should be
    able to apply a check that the total balances before and the total balances
    after should have the very same value.

  - In validate.py: differentiate between the case of an entry appearing too
    early before an Open directive, and an entry appearing for an account that
    simply just doesn't exist.

  - Auto-detect and warn on likely duplicate transactions within the file.

** Conversions

  - TODO: Try it out in Ledger, see how they deal with it.

  - Make the conversions entry use a price of zero, to maintain the invariants
    for sanity checks, something like this:

       YYYY-MM-DD * "Annul conversions at end of period"
         Equity:Conversions        -56383 CAD @ 0 CONV
         Equity:Conversions        +67000 USD @ 0 CONV


** Open/Close

  - You must issue an error if you close an account that's got a non-zero
    balance!

** Padding

  - Idea: Padding entries could be extended a tiny bit in order to
    automatically calculate the cash distribution entries, e.g., like this:

      2014-03-04 pad Asset:Cash  Expenses:Restaurant    60%
      2014-03-04 pad Asset:Cash  Expenses:Alcohol       40%

      2014-04-04 pad Asset:Cash  Expenses:Restaurant    70%
      2014-04-04 pad Asset:Cash  Expenses:Alcohol       30%

      2014-05-04 pad Asset:Cash  Expenses:Restaurant    70%
      2014-05-04 pad Asset:Cash  Expenses:Alcohol       30%

    This is a great idea, is in line with the general meaning of pad entries
    (implicit 100%) and would add a much desired feature.

  - Add tests for all the cases of realization padding.

** Locations

  - @location really should just convert into a generic event "location", just
    as address and school should; they're just events with forward fill...
    Serve this at:

       http://localhost:8080/20120101/20130101/events/location/days

  - Add a "reason" field for @location, and display as trips, with
    some sort of meaning to them. Ok, this contradicts the previous idea.



** Payee Elision / Auto-Account Leaf Name

  - About the discrepancy between the concept of "Payee" and a superfluous lead
    account, e.g. Internet:TimeWarner, which typically contains only
    transactions from that payee: maybe we can elide the account name if it
    contains only a single payee, or perhaps a warning may be issued? I don't
    know.

    Basically, it would be nice to be able to have multiple payees in the same
    category over time (e.g. Electricity, Internet) but to be able to separate
    them somehow, without having to put the payee into the name. This is a
    little fuzzy, and I'm not sure how to do it, because the imported payee
    names are often not very clear and often truncated as well.

      Have you ever thought that Payees often end up functioning like an extra
    subaccount? I've come to realize that for Payees that only ever touch a
    single account, the line is really fuzzy there. I've been entertaining the
    idea of automatically creating subaccounts for payees like that.



* Parser
** Errors

  - We need to gather errors in a single place and report them like the others;
    right now I'm catching them in sum_to_date() and writing using the logging
    module; but they really should be trickled up with the rest.

  - Syntax errors currently have no location... this is unacceptable. Write an
    automated test, check for all kinds of errors, in the lexer, in the parser,
    in the Python. (Just work with the line number, we don't really need
    character position.) Test everything with automated tests.

  - 'lineno' is incorrect, it points to the next entry, not the previous one,
    fix this bug! This is really annoying.

  - Set a correct filename in grammar.y

  - Errors from the parser and others should all be accumulated in one place,
    so that we do all the reporting at the very top level.

  - Don't raise error exceptions anywhere; log everything to an error
    handler/accumulator class instead, and skip to the next entry/declaration.
  - Propagate exception from Python(?)

  - Problematic transactions (!) should spit something of color on stdout, they
    should not be forgotten so easily.

  - When using @@ the signs should match; warn if they don't

  - Bug: Invalid account names should only be reported once.

*** Lexer Level Errors

  - When an error occurs, skip the lexer to the next empty line and recommence.

** Make the Parser Reentrant

  - Make the parser reentrant [2014-08-02]. This is _not_ a difficult task.

    * Follow this:
      http://www.lemoda.net/c/reentrant-parser/
      http://flex.sourceforge.net/manual/Extra-Data.html
      to remove all globals from my lexer and make it truly reentrant and free of globals.

    * You need to add unit tests that check the correctness of line numbers on
      parsed directives and errors.

    * You need to remove the get_yylineno and get_yyfilename accessors.

    * You need to make the parser reentrant, by add this directive to the grammar:

         %parse-param { PyObject* builder}

      You also need to redefine yyerror() accordingly. I've done it and it
      works, it's simple, it's a 20 minute change:
      http://www.gnu.org/software/bison/manual/html_node/Parser-Function.html

    * You also need to make the lexer reentrant:
      http://flex.sourceforge.net/manual/Reentrant-Overview.html#Reentrant-Overview

         %option reentrant

      (I haven't tried this yet.)

    * Most of the "real" work involved is in removing the globals for lineno and
      filename.

    * Make sure the performance does not degrade as a result of doing this.


** Options

  - FIXME: We need to parse the options using the same argparse parser....

  - Remove the globals kludge in beancount/core/account.py, and weave the
    necessary AccountTypes instance all over the place.


** Syntax

  - You should support a payee with no description! This generates a parser
    error right now.

  - Allow '$' as currency symbol, don't translate to anything, it can just
    stand on its own as a unique kind of currency, it doesn't matter, no
    changes anywhere. Also add the Euro, GBP and yen symbols.

  - The syntax should support multiline strings naturally...

  - For Links vs. Tags: dont impose an order, parse as tags_or_links.
    Right now the order is tags_list and links_list.

  - You should accept commas in the input; simply ignore their value.

  - Add 1/rate syntax for prices (and anything... really, why not).
    Convert at parsing time.


*** Parser Testing

  - Support a mode for the lexer to spit out its results on stdout, so that we
    can cross-check with parsers in other languages.

*** Includes

  - With the new format... support includes, it makes a lot more sense to do
    that now! People want this too.

  - Idea: an include directive should have a "prefix" option, to add a prefix to
    all accounts from the included file.

*** Sensible Syntax for Lots

  - Consider making the lot syntax like this:

       -4 {GOOG @ 790.83 USD}

    instead of:

       -4 GOOG {790.83 USD}

    It's actually a lot more accurate to what's going on...

** Performance

  - Implement "D" in C, it's worth it. This should make a substantial difference.

  - Test using the empty case of list parsing to create the initial empty lists
    instead of the conditional in Parser.handle_list() and measure, to see if
    there is a significant difference in parsing performance.

  - Parser performance: try not calling back to builder for simple types that
    just return their value; measure the difference, it may be worth it, and we
    wouldn't lose much of flexibility, especially for the lexer types, which are
    aplenty.

  - Write the builder object in C... it won't change very much anymore, and
    that's probably simple enough.

  - Check the performance of D(). I suspect improving this routine
    could have a dramatic effect on performance.

** Documents

  - Write a proposal for implementing a transformation on a specific set of
    transactions, that supports capital gains with commission taken into
    account.

  - Can we automatically add a ^LINK to the document directive in order to
    associate a PDF with a document?!? -> For trade tickets. Maybe let the
    modules provide a import_link() function on the associated PDF files?
    (This is related to ^64647f10b2fd)

  - Adding the ability for links on document directives was also requested on
    the ledger-cli mailing list.

        On Sat, Apr 26, 2014 at 6:18 AM, Esben Stien <b0ef@esben-stien.name> wrote:

        "Craig Earls" <enderw88@gmail.com> writes:
         The first use in ledger-cli is to link each transaction to a document,
        which is pretty important in accounting;)

        Well no, not exactly. The thing you do in importing financial data is basically
        to funnel transactions from all of your statements from all your institutions
        in a single place in a single format with a single set of accounts, so that you
        can do reporting with a view of everything you have. Having support for a
        per-transaction link to a particular document is generally unnecessary--you can
        easily find the corresponding document by date if you need to.

        In order to associate a unique ID with a particular transaction, in Beancount
        you can use a "link" which is like a special kind of tag. I think Ledger has a
        similar feature, per-post ("tag"?). It looks like this in Beancount:

          2013-04-06 * "Invoice to Metropolis for job well done, waiting for payment."
          ^metropolis-invoice-103
             ...
             ...

        The "^...." bit is a link. You can have multiple links per transactions. The
        web interface can show you all transactions with the same link in a separate
        list (under the /link/.... URL).

        Separately, there is a "document" directive that allows you to associate a
        document with an account, e.g.

          2014-01-01 document  Expenses:Electricity
          "/path/to/filename/ConEdison-2013-12.pdf"

        Documents don't have to be declared that way explicitly: you can also tell
        Beancount about a root directory where it will find documents automatically and
        create the document entries for you. The files just have to be organized in a
        directory hierarchy mirrorring the account names exactly, and files must begin
        with "YYYY-MM-DD" to provide a date for the document. That's a simple
        convention. LedgerHub is able to move files that it recognizes to such a file
        hierarchy, so after you import the data, you file the files into e.g. a local
        git repo with all your statemetns, and your document entries show up in the
        registers. It's also a nice way to organize all your statements, so if you need
        to bring something up for e.g. a tax audit, you quickly know where to find it.

        Those two features are not related at the moment... but I think I'll add the
        ability to have links on document directives. That seems like an effective way
        one could associate a particular pdf document (given a declaration) with a list
        of transactions. You click on the link, see all the transactions + the
        document, and you can click on the document itself to see the detail. Seems
        like a legit idea.


  - Auto-doc from directories of files should ignore files already associated
    via an explicit documents directive; just ignore files with the same
    absolute name.

** Testing

  - Allow file objects to parse() and dump_lexer(). This should use fdopen() or
    whatever else to get this job done at the parser level.

  - You need to clean up the memory of the strings created; call free() on each
    string in the rules.

  - Add a unit test for pushtag/poptag errors.
  - Add unittests for tags, pushtag/poptag


** Dated Postings

  - In order to create multiple similar transactions at many dates in one
    syntax' entry, you could allow overriding the date on each posting, e.g.:

       2013-04-01 * Blah di bla
         2013-01-01  Grocery          10 USD
         2013-02-01  Grocery          10 USD
         2013-03-01  Grocery          10 USD
         Cash

    This would create three transactions, with these dates:

        date           aux-date
        2013-01-01     2013-04-01     10 / 3.33
        2013-02-01     2013-04-01     ...
        2013-03-01     2013-04-01     ...

    Could be a nice way to make distributed transactions.

  - Move 'effective date' to the postings in my input file, using the dated
    postings feature.


  - Another idea would be to make @pad able to pad for a percentage of the
    total, so that we're able to use @pad instead of "distribution of expenses"
    entries.


** Tags as Key-Values / Metadata

  - (reports) Implement account rendering ordering properly. Use meta-data on
    Open directives (maybe).

  - One idea Ledger uses well is the ability to associate key-values meta-data
    to transaction objects, a-la-Common Lisp. See the --pivot feature. It seems
    a bit superfluous at the moment, but may be useful in order to provide the
    ability to implement custom aggregations eventually, instead of using the
    strings. Maybe the payee could be a special case of this, e.g payee="value"

    (From mailing-list):

      Take this example:

      2011-01-01 * Opening balance
          Assets:Cash                               25.00 GBP
          Equity:Opening balance                   -25.00 GBP

      2011-02-01 * Sell to customer AAA
          ; Customer: AAA
          ; Invoice: 101
          Assets:Receivables                        10.00 GBP
          Income:Sale                              -10.00 GBP

      2011-02-02 * Sell to customer BBB
          ; Customer: BBB
          ; Invoice: 102
          Assets:Receivables                        11.00 GBP
          Income:Sale                              -11.00 GBP

      2011-02-03 * Sell to customer AAA
          ; Customer: AAA
          ; Invoice: 103
          Assets:Receivables                        12.00 GBP
          Income:Sale                              -12.00 GBP

      2011-02-03 * Money received from customer AAA for invoice 101
          ; Customer: AAA
          ; Invoice: 101
          Assets:Cash                               10.00 GBP
          Assets:Receivables                       -10.00 GBP

      Now you can see how much each customer owes you:

      ledger -f d bal assets:receivables --pivot Customer
                 23.00 GBP  Customer
                 12.00 GBP    AAA:Assets:Receivables
                 11.00 GBP    BBB:Assets:Receivables
      --------------------
                 23.00 GBP

      And you can see which invoices haven't been paid yet:

      ledger -f d bal assets:receivables --pivot Invoice
                 23.00 GBP  Invoice
                 11.00 GBP    102:Assets:Receivables
                 12.00 GBP    103:Assets:Receivables
      --------------------
                 23.00 GBP


  - Is it worthwhile to allow tags to become types and have values, like in
    Ledger? I'm not sure that's so useful, but it would provide a more powerful
    mechanism for selecting subsets of transactions.

  - If you add tags with values, you could define some special tags, like
    'document', which could automatically try to find the corresponding
    document in the repository and insert a link to it in the web page. I
    already have a managed stash of document filenames... something like this:

      2014-05-20 * "Invoice from Autodesk"
        #document: 2014-05-20.autodesk.invoice200.pdf
        Income:US:Autodesk  -3475.20 USD
        Assets:US:Checking

    A document filename that does not get resolved could spit out a warning in
    order to keep the file tidy. This is a nice idea... perhaps nicer than just
    insert entries for documents, an actual link. Not sure if it would make that
    much of a difference though. Something to ponder.


* Plugins
** Wash Sales

  - (script) Write a script to check whether an account's trades are subject to
    the wash sale rule (I need this for Google stock):

      "An Internal Revenue Service (IRS) rule that prohibits a taxpayer from
    claiming a loss on the sale or trade of a security in a wash sale. The rule
    defines a wash sale as one that occurs when an individual sells or trades a
    security at a loss, and within 30 days before or after this sale, buys a
    “substantially identical” stock or security, or acquires a contract or
    option to do so. A wash sale also results if an individual sells a security,
    and the spouse or a company controlled by the individual buys a
    substantially equivalent security."

    The wash sales amount should be reported in an account, and should be
    calculated as a plugin.

** Strict Unused Pad Directives

  - The validation check that pushes an error on unused pad directives should
    be moved to a plugin, that should be optional. There is rationale for
    allowing to keep unused pad directives. Don't be so strict, Martin.


** Link Trades

  - Create a plugin that will link together all reducing transactions
    automatically. When a transaction reduces a position, both transactions
    should have a common unique link. This can all get done in a plugin!


** Capital Gain Without Cost

  - Implement the proposal for putting the capital gain in the cost as a plugin
    that transforms the relevant transactions, those tagged as such. This will
    require some loosening of the booking method in order to make it easier to
    disambiguate a sale, and some good debugging tools as well.

    You could automatically look for the right amounts by looking at the signs.
    I think you could automate a lot of it.


** Auto-Link Booking Transactions

  - Automatically create a link between transactions that book each other.
    I'm not sure how I'm going to implement that - perhaps in the lot matching,
    a hash to the original entry will be kept in the lot - but we should be
    able to update the links to all the transactions that book together.

    This will be a great debugging tool as well... a very powerful idea that
    can be implemented entirely in a plug-in.


** Unrealized Gain

  - Find a way to pass in a plug-specific option via the file.

  - Unrealized capital gains could be inserted automatically into special
    sub-accounts, based on the current price and the cost-basis of particular
    accounts. This could be inserted automatically! e.g.

        DATE check Assets:US:Ameritrade:AAPL       10 AAPL {200 USD}

        DATE price AAPL  210 USD

      Assets:US:Ameritrade:AAPL                    2000 USD
      Assets:US:Ameritrade:AAPL:Gains               100 USD

    The "Gains" subaccount could be inserted automatically if the price differs
    from the cost basis... this would be a clever way to represent this! We
    could even do this by inserting a transaction automatically with an
    offsetting account... actually this would be the RIGHT way to do this!

      We need an option to designate which subaccount leaf to create all
      the new transactions for:

        %option account_unrealized  "Unrealized"

        2013-05-23 A "Booking unrealized gains for AAPL"
          Assets:US:Ameritrade:AAPL:Unrealized              230.45 USD
          Income:Unrealized                                -230.45 USD

      By doing this, the reporting does not have anything to do... it can choose
      to report positions at cost or in held units, and whether the gains are
      included or not entirely depends on whether these transactions have been
      inserted in or not.


** Strict Average Cost Inventory Booking Checker

  - Build a plugin that will check that accounts with average cost inventory
    booking method only have such reductions in them:

    https://docs.google.com/document/d/1F8IJ_7fMHZ75XFPocMokLxVZczAhrBRBVN9uMhQFCZ4/edit#heading=h.m74dwkjzqojh

      "Another approach would be to not enforce these aggregations, but to provide a
      plugin that would check that for those accounts that are marked as using the
      average cost inventory booking method by default, that only such bookings
      actually take place."

   This is, of cource, to be implemented only after implementing support for
   the average cost inventory booking method.


** Tip Calculator

  - Write another example plugin that splits "Expenses:Restaurant" legs into
    two two postings: "Expenses:Restaurant x 83%" and "Expenses:Tips x 17%".


** Vacation Cap Date

  - Make an plugin that computes the precise date at which my vacation will cap
    (240 VACHR) base on an account.


** Budget

  - Implement a plugin with budget constraints, as an example.


** Auto-Remove, Auto-Pad

  - Add a auto-remove-unused part of the auto_accounts plugin,
    that automatically removes Open directives for unused accounts. This is
    useful for demos and such.

  - Write a plugin that automatically inserts a padding directive for accounts
    with no open directive and with a balance check.


** Strict Signs Checker

  - Write a plugin that enables a check that all postings' amounts are of the
    correctly allowed sign, e.g. Expenses should almost always be a positive
    amount, Income a negative one, Assets can be both, also Liabilities. If an
    amount is posted in the contra direction, this should trigger a warning,
    unless the transaction is flag with a particular character, or some special
    tag is present.


** FBAR

  - Automatically compute the maximum account values of foreign accounts for
    the FBAR filing.


** After-Tax Balance Sheet

  - Ha... I think you just gave me a fun idea!  I'll write a plugin in Beancount
    that automatically adds a "future tax expense" entry to offset pre-tax money
    for the balance sheet, e.g. if I have a 401k account with a value of say
    100,000 USD in it, it would automatically insert an entry at the latest day
    like this:

      2014-07-03 F "Taxes to be paid on distributions."
        Expenses:Taxes:Federal        27000 USD
        Expenses:Taxes:StateNY         8000 USD
        Liabilities:FutureTaxesOnDistirbutiosn  -35000 USD

    This would make the balance sheet reflect only post-tax money, and thus be more
    meaningful.
    If I want to see post-tax money, I'll just enable the plugin from a
    command-line option.
    I'd have to find some generic way to identify which accounts are pre-tax
    somehow.



** Payees as Subaccounts

  - Create a plugin that will define subaccounts for payees within accounts and
    modify all the transactions accordingly. This would be a great way to kick
    the tires on this idea without affecting the rest of the system.

      Expenses:Electricity:ConEdison
      Expenses:Phone:TMobile
      Expenses:Groceries:WholeFoodsMarket
      Expenses:Groceries:UnionMarket

  - Should we define some notion of the default level for aggregation, per
    account? For example, in Expenses:Electricity:ConEdison, the default level
    of aggregation should be Expenses:Electricity. If we define that, using
    subaccounts should not bother us much.


** Dashboard

  Add the following to the portfolio dashboard:
  - PnL since yesterday, one week ago, two weeks ago, one month ago, three months ago
  - Current portfolio breakdowns
  - Cash report
  - A listing of short-term lots vs. long-term lots
  - Schedule of lots to become long-term in the near future
  - Returns (computed correctly, over many periods)

  From email to fxt:

    I want to build an investment dashboard, that would contain:

    - List of holdings, with various rollups (see the different aggregations of
      holdings reports)
    - Rollups of holdings against various types (e.g., Stocks vs. Bonds)
    - P/L since the morning or for the last day, over the last week, last two
      weeks, last month, last quarter, last year.
    - Report of uninvested cash and the detail of where it is
    - A listing of short-term vs. long-term lots, and a schedule of which lots are
      going to switch from short-term to long-term in the near future (to avoid
      selecting those for sale)
    - Returns, as computed by my prototype of our ideas during the bicycle trip
    - Automatically refresh current prices if run intra-day

    This script would run every hour on a crontab and generate static HTML files
    that I could access from my phone to make investment decisions and monitor
    gains/losses during the day. I'm certain you would appreciate having such a
    thing too. I want to integrate the code I already have out of
    beancount/experiments and start moving all this stuff to the
    beancount.dashboard.* and add unit tests and make it work on the tutorial file.
    This should make it easy for others to use.



* Tools
** Emacs Support

  - Set the comment-syntax; currently it thinks it's '# '

  - In the new mode, we need to recreate a function that will mark a posting as
    valid (replace '!' by '*').


* Reports
** Warnings

  - You should have _some_ way to highlight accounts with either failing checks
    in them, or '!' on their postings or transactions in the balance sheet
    and/or trial balance.

  - Perhaps we want to produce a report of all transactions with a highlight on
    them.

** Balance Sheet

  - (web) We really need to reorder the accounts in a way that is more
    sensible... it's annoying to see the accounts I care about at the top of
    the page. Cash, Points, AU, should be at the bottom... I wonder if there's
    a nice heuristic. Last updated date? I think that would be good enough.

  - We need to figure out how to order the accounts on the balsheet; I want the
    most relevant near the top. Sorting accounts: compute a score made up of

    * nb. txns from the last 3 months
    * nb. checks from the last 3 months (weighted more heavily)
    * line-no of Open directive in the file.
    * last updated date.

** Capital Statement

  - Implement the Capital Statement report

** Cash Flow Statement


** Statement of Retained Earnings

  - This is possible; search online for examples, makes sense that we should
    have one, it's really, really simple to do.

** Account Linkage Report

  - Generate a Graphviz link of all the interaccount transactions that are
    larger than a certain amount.

    Generate a graph for the main kinds of account
    interchanges, by looking at the most significant transactions
    between the accounts. For example, ignore transactions which are
    too small in absolute value, or whose total is too small a portion
    of the total.

    Fun little project: Create a graphviz output from a Ledger, where
    transactions above a certain amount would generate a link between
    accounts. Note:  the threshold could be either for single
    transactions, or for aggregate amounts (absolute value).

** HTML Rendering

  - Rendering: When you collapse a parent account, its aggregate amount should
    render, and disappear when not collapsed.

  - Numbers should align to the right.

  - USD and CAD should be aggregated in their own columns for balance sheet and
    income statements. These should be specified from the command-line.

  - All entries should have collapsing a-la-JavaScript, along with
    collapse/reveal all buttons. All JS.

  - If the software is finally fast enough in Go, render RESTful on the fly for
    any date:

    * REST:  /balsheet/20121231/
    * REST:  /income/20121231/20131231/

    This way, you could have any year on the same run. No need to restart, even
    have a menu with all the years, and perhaps even some of the latest months.

  - It would be really nice to render the line numbers to the source in the HTML

  - (Performance) Implement buffered output for faster response using a separate
    thread and an iterator that yields from app.write when the data buffer is
    large enough.

  - Postings that have a "!" flag should have at least their
    background red.

  - You should more explicitly state the beginning and ending period
    on each statement pages (it is super important information).
    Just below the title.



** Excel Output

  - Find good ways to transfer data to an Excel spreadsheet. A link to download
    a file should be supported.


** Credits and Debits Rendering

  - Color the background of numbers with an inverted sign (e.g. payments in a
    liability account) differently! There should be modes to rendering balance
    sheets and income statements with inverted amounts, and it should all be
    done client-side. When amounts are rendered as credits/debits, color their
    background distinctly, so that it's obvious what kind of sign convention is
    in use.


** Links to Source

  - The new format code should keep and optionally render the source file/line
    of any transaction, and allow clicking to get to the source line in the
    rendering.

  - Maybe there should be a script that can take a report specification and
    output a list of emacs-compatible links to the entries, interspersed with
    the text format rendering! You could go "next-error" to go through the
    entries in time order, emacs taking you there one-by-one.

** Multi-Period Reports

  - One kind of report that would be GREAT is a single grid with all income accounts
    on the left with year by year on the horizontal. An overview of all the
    years. Same with month-by-month report.


** CSV Reports / Text Reports

 - Using an intermediate data structure, produce text and csv / xls reports,
   downloadable from the web front-end, or even generatable directly. All of
   this reporting infrastructure should be reusable, ideally.

  - A text rendering of the balance sheet / income statement would be
    _very_ useful for collaboration/communication with others. Add a link to
    download a text version of any report. This would be made easy if we only
    have a few distinct types of reports.

** Plots / Time-Series

  - Create a command to extract time series for any account, as a csv file. You
    could then easily use this for plotting!

  - Generate graphs of account amounts over time
  - Include average amounts, average delta amount

** List of Positions

  - Given a list of entries, you should be able to extract a list of positions
    at any point in time. Provide this as a simple function that can just be
    reused.

  - The list of positions should provide a way to check the purchase price of
    each position.

  - Positions should attempt to fetch current values using this:
    http://www.google.com/ig/api?stock=RGAGX


** Maximum Values Report

  - You should report a trial-balance -like listing of the minimum and maximum
    values of all the accounts.

** Event Reports

  - We should be able to count the days of each event type.

** Distribution of Expenses and Income

  - Add a pie chart to visualize the constitution of the Income Statement for
    Expenses and Income.

** Summary Reports

  - To create custom views, for example, weekly summaries, you could
    convert the ledger into another ledger, where entries would have
    been replaced by summary entries instead, and all the other
    functionalities would still work.

** Financial Ratio Analysis

  - Add these: http://www.csun.edu/~bjc20362/Controlling-2.pdf

** Budgeting / Goals

  - We could easily add features for budgeting, e.g. somehow set goals and then
    report on the difference between actual and the goal, and project in the
    future according to rate, e.g.:

       ;; Check that the total for this position between 2013-06-01 and 2013-12-31 < 800 USD
       2013-12-31 goal  Expenses:US:Restaurant  2013-06-01  < 800 USD

       ;; Check that the balance of this account on 2013-12-31 is >= 1000 USD
       2013-12-31 goal  Assets:Savings  >= 1000 USD


** Trades

  - You should be able to report on all booked trades during a period,
    especially with the new booking algorithm, this will be useful.
    Create a new report type for this.

* Web Interface
** Programmable View

  - GREAT IDEA! Have a web form that you can input a view filtering expression,
    e.g.  year:2014 component:Google
    to have that year's transactions made with this component. Encode the
    results in a unique string that you can decode and create a corresponding
    view of the subset selected by the expression. You can then view any of the
    reports for that subset! This means we can then get rid of many of the root
    page's links automatically, yet still provide all the opportunities... this
    is the way to go, and would best mirror the command-line capabilities.

** Error reporting

  - We really need to list all the '!' entries somewhere; they should be
    annoying.

  - In the balance sheet or trial balance, mark accounts that have errors in
    red, or add a little red start next to them.

  - Implement basic error reporting page from the list of errors.

** Debits and Credits

  - The new balance sheets should be able to invert the numbers (and then they
    should get rendered differently). Basically, every number shown should be
    either in signed or cr/dr format. We should be able to switch between the
    two at render time. This should work across all number-rendering routines
    everywhere--do this centrally.

  - In the balance sheet and income statement, we need to render the amounts
    inverted (and in a slightly different style).

** Links

  - Serve links on: /link/LINK, this needs to be implemented; render a nice
    "link" href on the description somehow, use a fancy unicode char (no
    graphics).

  - (web) Render links to the right of descriptions, and the link href link
    should actually render a page of the related linked entries.

** Single-View Server

  - Idea: for condo & baking files into a zip file: allow serving only one
    ledger realization.

    * One option is to use the same base/root straing as for the web URL:

         http://localhost:8080/byyear/2013/...

      serve_one_ledger(getledger('byyear/2013'), port=8080)
      --realization='byyear/2013'

    This would serve only that realization, and not others. This way I could
    bake only this one in a zip file. This would be useful.

** Code Org

  - (web) Move table rendering functions into their own files, smaller files.

** Aesthetics

  - In the entries table HTML, highlight the relevant posting leg somehow, maybe
    use a '>>' marker, or make it bold. Something. (Bold is too much, use >>.)

  - Render "as of YYYY-MM-DD" under the title for Balance Sheet, and "from
    YYYY-MM-DD to YYYY-MM-DD" under the title for Income Statement


  - Answer to favicon.ico request.

  - Add an option to render the entries table upwards, not just downwards.

  - Use that beautiful new font (Roboto) from Tactile in the new rendering.
    Totally worth it. Use the nice Lucida-like font for numbers, like in
    TurboTax.


*** JavaScript / Client-Side Interaction

  - Render balance sheet/ income statement cells with two numbers for parent
    nodes, so that when you collapse a node, all the amounts of its children sum
    up automatically and display in its cell. You should have a consistent
    report regardless of whether nodes are collapsed or not. This will require
    some JavaScript effort.

  - Implemented a JavaScript cursor in JS. J, K up down. SPC = toggle.

  - In Journal view, pressing 'C' should toggle displaying the checks on and off.

** Trial Balance

  - We should have a nicer way to tell what accounts need to be updated.
    Highlight them red if they haven't been updated in more a month
    (configurable).
    Put the last updated date in the balance sheet or perhaps the trial balance
    page. Should be easy; we don't need a dedicated page for this.

  - Do we need a dedicated page for listing all documents? This page could
    include documents without a date, could be rendered as a tree-table, with
    the list of each document in the corresponding account. Maybe that's
    overkill. DK.

  - Shove more information in the Trial Balance page, info about errors, documents, etc.

** Multi-Year

  - A multi-year report is a global report.

** Source

  - The source page should take a special '?line=ddd' parameter that will
    scroll the page to the transaction at that line.

** Conversions

  - Render the Conversions amount at the bottom of the Conversions page...

* Export
** HTML Export as File

  - Test "bean-bake" with the v2, it doesn't appear to work.

** XML

  - Output to a structured XML format, some people are finding that useful to
    build other visualizations. In order to test this completely, do a
    round-trip test.  The code should live in beancount.parser, parallel to the
    existing code there.


** Ledger

  - Export the compatible subset to Ledger format, so you can compare the
    reports. This should be done from a tool called "bean-convert".


** Visualizations
*** TreeMaps

  - You just *have* to generate TreeMaps of the Expenses and Assets subtrees:
    http://bost.ocks.org/mike/treemap/


** Portfolio tracking softwares

  - You should be able to export to input files or APIs for websites that track
    portfolios for you, such as Google Finance and Yahoo and others. Use the
    list of holdings as input. This should perhaps just be another report name.

* Documentation
** Challenges

  - Document those below which I'm already able to do, and those which require
    new features to be able to be done, move them into a separate appendix,
    with explanations on how to do it.

**** Cash vs. Accrual Accounting

Of course a real accountant would just do this: (accrual based accounting)

2014-05-19 * "Booking tithe”
 Expenses:Tithe     300 USD
 Liabilities:Tithe     -300 USD

2014-05-20 * “Paying tithe”
  Liabilities:Tithe      300 USD
  Assets:Checking  -300 USD

But this records the expense on a different day than when you actually paid it.
That would be a problem if, for example, you live in the US and wanted to claim
a tax deduction for the tithe, in which case you must claim the deduction for
the year the tithe was actually paid (cash based accounting).

This is indeed the right solution to this! Accumulate a liability as you go,
and resolve it with real transactions later on.

This case keeps coming back again and again, of wanting to do accrual
accounting but wanting to do cash declarations. I think we need to have a long
and separate discussion about cash vs accrual accounting and for sure we can
come up with a creative solution that solves this problem.



**** Can I generate a nice year-on-year summary of income and expenses?

  - Including RSP contribs, like my bu spreadsheet that I crafted manually? Can
    I do that? That would be awesome!

**** Maximum Balance

  - Can I compute the maximum value of each account at the end of every year
    (for foreign assets decl.) This would be useful for FBAR / FATCA
    declarations.

**** Complete Return (IRR) on Condo

  - Challenge: Can I compute IRR return on my condo accurately?
    TODO: Add benefits received as an Income, as transactions.
    You should be able to compute the IRR of any Ledger!

**** Taxation Rate

  - Challenge: Can I automatically compute my taxation rate for every year?

**** List of Assets

  - Challenge: Can I obtain a list of my assets at any time?

**** Make a report of currency exposure

  - For a particular balance sheet, report the total currency exposure of the
    ledger. This should be a very simple report, probably in the form of a pie
    chart.  Maybe this pie chart should be located in the capital report
    (possibly makes sense).

**** Capital Gains

  - Capital gains should not count commissions nor on the buy nor on the
    sell side. How do we book them like this?  Can we count this somehow
    automatically? Misc accounts? Not sure.

**** Inflation Adjusted Balance Sheets and Charts

  - It would be AWESOME to look at a balance sheets from the past but
    inflation-adjusted for any date... Answer this question easily:

      "What was I making in 2010 in today's dollar terms?"

  - How would I produce an inflation adjusted version of some charts. Maybe all
    charts should have that option?

**** Statement of Assets (for Will)

  - In order to have someone else be able to take care of your business, you
    should be able to produce a list of the accounts open at the end of the
    period, with the account ids and balances. This should be printable and
    storable, for someone else to take care of your things in case you die.


**** Compare common costs using constant TMV

  - Look at average meal 10 years ago, average electricity, etc. things that
    should be equal, and correct for the time-value-of-money, compare prices
    today with prices then. Maybe come up with some kind of constant unit that
    I can convert everything to.

**** GIFI Reporting

  - You could write a script to automatically fill this form:
    http://www.cra-arc.gc.ca/E/pub/tg/rc4088/rc4088-12e.pdf

      "With Beancount, one thing that would be doable _outside_ of Beancount, as
    a separate script, is to associate a set of accounts to these GIFI codes and
    automatically generate the forms."


** Change List

- Implemented in Python 3, from scratch.

- Internal data structures are more functional, immutable, allowing you to more
  easily create scripts that use the in-memory data. Overall, the new code is
  way simpler and much easier to understand because of this. It's actually
  become dead simple.

- New, simplified, and more consistent (and rigid) syntax will make it possible
  to add more features in the future, and to have parsers in other languages too
  (e.g. Go).

- Booking trades with capital gain tracking should now work.

- The new parser is written in C, so it is much much faster, and future changes
  will be easier

- The new web server fixes annoying rendering issues.

  * Balance sheet amounts can now reported in terms of book values.
  * Debit accounts can now be rendered with positive numbers (color-coded).
  * The internal data structure changes are much more general, and allow, for
    instance, creating a balance sheet at any point in time. In particular, you
    can have a balance sheet at the beginning and end of an exercise.

- Some internal design flaws were fixed, like checks on filtered ledgers showing
  up from incorrect periods.

- Various outputs to text, csv, and xls are now supported for easier sharing.

- The input file is monitored by the server, and can be automatically reloaded.
  This makes it easier to just start the web server, then edit the file to
  update what you need.

- There is no need to specify a filter period anymore; the interface is able to
  realize any required periods, and the GUI provides access to most common
  cross-sections (all, by year, by tag, by payee, transactions with bookings,
  etc.). You should be able to just specify the GUI.

- Client-side javascript has been added for a neater, more compact rendering of
  journals.

- New scripts to extract a list of current positions at any time, and global
  summaries over many years or months.


** Presentation Material

  - Use impress.js to built a visualization of the DE method

  - Record a video, that's an easy way to explain how this works.

  - IDEA!!!  Use drawings a-la-ThinkBig or whatever it is. This will be the
    perfect medium for this. Mix it with video. Start writing a detailed script.

  - Begin with a USB key in hand. "On this 8 GB USB key, I have all of 8 years
    history of financial transactions in my life. Every single price paid that
    went recorded into an account it these.
