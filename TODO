-*- mode: org -*-
beancount: TODO
* Requirements for Shipping 1.0

  - Complete full unittests coverage (as per find-missing-tests.py).
    Remaining (to be processed in this order):

       src/python/beancount/parser/documents.py               INCOMPLETE


     src/python/beancount/parser/lexer_test.py              MISSING

       Create an automated test for the lexer as well.

     src/python/beancount/ops/summarize.py                  INCOMPLETE
     src/python/beancount/ops/pad.py                        INCOMPLETE
     src/python/beancount/ops/validation.py                 INCOMPLETE

     src/python/beancount/ops/check.py                      INCOMPLETE

       Rename this file to balance to match the directive?
       Not sure. Another file is named that way.

     src/python/beancount/web/acctree.py                    MISSING
     src/python/beancount/web/journal.py                    MISSING

     src/python/beancount/web/bottle_utils.py               MISSING

     src/python/beancount/web/views.py                      MISSING
     src/python/beancount/web/gviz.py                       MISSING


     src/python/beancount/loader.py                               INCOMPLETE

  - balance.py -> autofill.py, check.py -> balance.py





  - Move report to UI: networth, holdings rolled by currency
    Reconcile web UI with the list of reports.



  - Look at deps for beancount.core.realization and move it upstream where it
    makes sense, maybe ops.






  - Prices:
     Fetch and save a historical table of monthly exchange rates for USD/CAD, USD/AUD, EUR/USD since 2000
     ledgerhub-fetch-prices is borked, outputs Nones
  - You also have to complete ledgerhub's code to correctly extract various
    prices... many broken extractors there, but that's a different story.




  - Rename/simplify function names in beancount.core.account (see FIXMEs)
  - Implement account.split() and perhaps remove references to
    split(account.sep) everywhere.




  - Add emacs configuration to highlight beyond 90 in this specific project,
    that does not use the fringe.
  - We really do need a little function that will align a paragraph's
    currencies automatically.





  - Check that an account without an Open directive has one that gets
    automatically inserted for it in addition to the error that gets generated.





  - web: Render a table of prices, in case there are only a few price points.
    We should also have a report type for prices.

  - Merge Holdings tab into Shareholder's Equity, less tabs, similar report.
    Complete the equity value page with prices.py, render the rates used to that page.





  - Build a more complete and representative of reality example file, bake, and
    share on ledger-cli

  - Begin an examples files, create links to all docs from README, even if incomplete
  - Convert all documentation to a GDoc
  - Create cookbook





  - Add a test for --view option.



  - BUG: MSSB documents aren't found... fix FIXMEs in documents.py



  - Clean up the interface of loader.load(), it's ugly.
  - Implement all the missing global pages.
  - All errors should be displayed in an overlay




  - Fix all docstrings re. Account instance, artifacts of having had an Account object.

  - Configure and run a clean pylint on the entire codebase.
  - Add all docstrings with args Google-style.
  - Fix all FIXMEs everywhere.
  - Add __author__ to all files?

  (depends)
  - Write a new command to bean-doctor that checks the dependencies dynamically
    and reports on them, with versions if possible, for reporting bugs:
    etc/check-depends.py, do this for 1.0, or better: bean-doctor 'depends'

  - bake: Spit out a nice error if wget is not installed/available.

  - Review all the code and make all creation of Decimal objects use to_decimal
    instead of Decimal, for consistency.
  - Alias to_decimal to 'D' and replace everywhere.

  - There have been some rare, but occurring few instances of really odd syntax
    making the parser ignore some transactions silently; this is not
    acceptable. Attempt to reproduce this again (not obvious, problems have all
    been fixed I think) and implement better error checking if possible.

    Reproduction hints: before eeea4b4d5605, a transaciton line with no strings
    at all, e.g. a line starting with "YYYY-MM-DD * ", would entirely ignore
    a transaction. Find a way to trigger an error on this.

    Other examples that bring up this problem (pre eeea4b4d5605):

      This parses wrong and silently--fix it:
      2014-04-20 * "Money from CC" ^610fa7f17e7a #trip-montreal-april-2014

      This works okay:
      2014-04-20 * "Money from CC" #trip-montreal-april-2014 ^610fa7f17e7a

  - Make sure all exceptions do NOT end with a period, nor do any of the
    logging.*() calls.

  - Install flake8, PyChecker, pep8 after pylint passes, run all of them.





  - Add a test for this (somewhere else): If something like this occurs, which
    price should appear in the prices database? This should trigger a warning that
    no price directive is inserted (this is what it should do: don't insert a
    price in this case, because we don't know which):

      2014-01-15 *
        Income:Misc
        Assets:Account1      1 HOUSE {100 USD}
        Liabilities:Account1 1 HOUSE {101 USD}
        Equity:Account1      1 HOUSE {102 USD}
        Expenses:Account1    1 HOUSE {103 USD}
        Income:Account1      1 HOUSE {104 USD}

    Also, deal with multiple implied price points added from different
    transactions on the same day... instead of just taking the later one, drop
    the price points? But this breaks an assumptin in add_unrealized_gains()
    which assumes that a price point will always be available if the unit is
    held at cost. Make a decision.










  - "Position with lots goes negative" should output an error message and be caught, because if it is run by the web
    server, it serves no page. Needs to be integrated like all the other error messages:

      127.0.0.1 - - [22/May/2014 21:51:14] "GET /view/year/2014/income HTTP/1.1" 500 762
      Traceback (most recent call last):
        File "/usr/local/lib/python3.3/dist-packages/bottle.py", line 783, in _handle
          return route.call(**args)
      ...
        File "/home/blais/p/beancount/src/python/beancount/core/inventory.py", line 65, in __init__
          self.add_position(position)
        File "/home/blais/p/beancount/src/python/beancount/core/inventory.py", line 260, in add_position
          return self._add(new_position.number, new_position.lot, allow_negative)
        File "/home/blais/p/beancount/src/python/beancount/core/inventory.py", line 298, in _add
          raise ValueError("Position with lots goes negative: {}".format(self))
      ValueError: Position with lots goes negative: Inventory(-2.00 PUMP {20.00 USD})




  - Review usage of @parsedoc vs. @loaddoc, maybe we should be more thorough
    about that and use @loaddoc in more places, as it performs data validation.
lugins
  - Maybe all the decorators for docstring parsers should be moved to a
    dedicated module. That would make sense.




  - COOL! I can subclass the namedtuples!  Do this to make printing the
    postings and entries much easier.

      class Posting(_Posting):
          def __str__(self):
              return _Posting.__str__(self._replace(entry=None))

  - Also derive from namedtuple to provide a stable hash function instead of
    code in beancount.core.compare.

  - Can we make Inventory a subclass of 'list'?  That would be real nice, would
    make a lot of sense.




  - Parsing this does not fail; it really should, this is a bug:
      "2013-04-01 balance Assets:Bank:Checking   555.00 CAD.11"

  - Convert to_decimal to 'D' everywhere... this is an important and nice convenience.

  - Make sure you can parse Amounts with space between the - sign and the number:
    "- 20 USD" kicks an error.



  - Documentation:

    * Beancount: document "choices": subaccounts vs tags vs payees, postings at
      leaves only or not,... Have a section to discuss these choices in the
      documentation.





  - Review deps once more before shipping and make attempts to simplify depgraph.
    Candidates for review:

      beancount.parser.documents
      beancount.core.realization
      beancount.ops.*
      beancount.plugins.*

  - Remove adding the unrealized gains for v2 from the loader in order to
    simplify the interface. Remove the option even. This will be reintroduced
    via a plugin in a further release. This is the right thing to do! Plugins
    will be aplenty.


  - Bug with unrealized - add a unit test, ensure this does not break it:

       2012-03-01 open Assets:US:Ameritrade:IRA:Cash                                   USD
       2012-03-01 open Income:US:Ameritrade:IRA:Interest                               USD
       2012-03-01 open Income:US:Ameritrade:IRA:Dividend                               USD
       2012-03-01 open Assets:US:Ameritrade:IRA:MMDA1                                  USD

       2012-03-01 open Assets:US:Ameritrade:IRA:HDV                                    HDV

       2012-11-17 balance  Assets:US:Ameritrade:IRA:Cash    0 USD


       2013-04-11 * "Bought 56 HDV @ 67.119" ^9849248919
          Assets:US:Ameritrade:IRA:HDV                                    56.00 HDV {67.119 USD}
          Expenses:Financial:Commissions                                           9.99 USD
          Assets:US:Ameritrade:IRA:Cash                                       -3768.65 USD

       2014-06-05 * "Sold 56 HDV @ 74.3003" ^11687887452
         Assets:US:Ameritrade:IRA:HDV                                     -56.00 HDV {74.3003 USD}
         Expenses:Financial:Commissions                                           9.99 USD
         Assets:US:Ameritrade:IRA:Cash                                         4150.73 USD
         Expenses:Financial:Fees                                                  0.10 USD






  - Put all the Pad into a single file as a plugin, same with Open Close, and
    Balance. Maybe we can organize those codes to be all localized in single
    files, and for many of these features, they can be implemented in
    self-contained plugins with all their codes together! openclose.py, pad.py,
    balance.py, etc. I think even 'event' directives can become those. And maybe
    a good way to disambiguate between ops adn plugins is just this... maybe ops
    is non-plugins, e.g. prices, summarize, etc.

         Documents is totally a plugin/transformer, and the dependency picture
         doesn't warrant it being within the parser.
         Could this move to a plugins directory? Yes.
         (This is clearly a transformation. Either ops or plugins.)

  - Make the plugins able to register types with the parser... this should
    allow the parser to call back on the plugins to create the appropriate
    types... this means true extensibility throughout! This is a fantastic
    idea... do this after v2 ship.  Maybe they get parsed as a special "Unknown"
    directive that accepts a grab-bag of strings and tags and accounts and
    amounts and they get replaced by the plugins; whatever Unknown trickles
    through would generate a warning in the errors.





* Current / Misc / To Be Classified

  - Create an index page for all the possible reports, from the web page

  - plugin: Consider creating a plugin that would auto-create accounts not seen yet,
    for the purpose of making demos. Definitely must do.

  - parser: Make tags and payees "tagged strings", with their own data types.
    You can derive from str.

  - Rename "events" to "register"?  This makes a lot of sense.

  - Write doc about stages of life, "climbing the mountain."

  - Make the web application accept colons in URLs, and make the reports use
    them too, so that their names are the very same as those on the
    command-line.

  - Unrealized gains should not be added if the gain is zero.

  - In the 'print' report, add a comment at the end of each posting line with
    the balancing amount! This is an important debugging tool! Make this happen.

  - Make implicitly derived price directives generated by a transformation, as
    an explicit price directive.

  - (avg cost) To implement this, move all balancing to a stage after the
    parsing stage. Balancing the entries should be running right after parsing
    and will need to do a partial realization for the affected accounts only,
    for the postings with average cost. But in any case, all the balancing
    should move to a stage right after parsing and should not be an optional
    stage.

  - Produce a currency exposure view by aggregating holdings to cost-currency,
    and then include OANDA hedging position.

  - Remove legacy support for PIPE character in syntax, update cheatsheet.

  - For table rendering, move the actually formatting at rendering time. CSV
    files should have fractional values for percentages, txt and html should
    have % values.  I need to figure out a good solution for this.
    Maybe the thing to do is to move the field selection at rendering stage, or
    at least to have it at both.

  - Create special make target to run tests on my own large Ledger.
    This should bean-check, bean-roundtrip, bean-bake / scrape.

  - Hmmm... compare does not actually allow two identical entries in a file.
    Solve that, using a differentiator, such as the fileloc or file no, or
    something. Maybe while reading we should insert a version number in
    duplicate entries automatially? Not sure.

    Another solution would be to warn on duplicate entries!  Maybe we just
    don't allow these. It really wouldn't be much of a big deal. And this would
    be easy to implement as part of our load checks. They're more often than
    not errors.


  - Summarize Ledger's --limit --real --virtual --equity, etc. options.

  - Write a plugin to compute total tax/income


  - The balance sheet "close" problem - how do we specify closing at a
    particular point in time - can be solved by providing parameters to the
    report, e.g.

       balsheet:2014-01-01:2015-01-01
       income:2014-01-01:2015-01-01

    Of course, this needs conveniences. The period, if there is only a SINGLE
    ONE, should be interpreted as "from the beginning of this period to the
    ending of it (one over)". Otherwise, the meaning is the beginning of both.
    Here are other illustrative examples:

       balsheet  -> from BEGINNING OF TIME to NOW
       balsheet:2014  -> from 2014-01-01 to 2015-01-01  (most common)
       balsheet:2014-05  -> from 2014-05-01 to 2015-06-01
       balsheet:2014:2015-08  -> from 2014-01-01 to 2015-08-01

    The same goes for income.
    The nice thing is that I think we can now move the closing of entries
    within the report generation itself, instead of being at the top-level of
    the web app. This will be simpler and cleaner!



  (plugins)
  - Should we extend the syntax to allow the specification of loader plugins?
    That might be an interesting idea... e.g.

      plugin "beancount.plugins.forecast"

    This is a powerful idea... means everyone could have their own little
    custom mod function. We could provide a set of standard and useful ones.
    And we would have to validate the produced entries to death, just to make
    sure all the invariants are respected.

    - Adding the unrealized gains should be a loader plugin! This is an obvious
      one. Make this before the release, in order to simplify the loader()
      interface as much as possible.

    - Pad could be a plugin, definitely.

    - Check could also be a plugin.

    - It should be possible to make the parser accept unknown directives that
      accept an arbitrary list of accounts and string parameters, like this:

        2014-06-01 unknown Assets:US:CreditCard "Something"




  (scripts)
  - bean-ledger: Write a script to convert to Ledger syntax. This should be easy!

  - bean-format or bean-align: Write a script to autoamtically align a region's
    transactions, or an entire file.

  - bean-query accounts: make a report that prints out just the chart of
    accounts using the list of parser entries, just the open entries,
    'bean-query accounts'

  - bean-query currency_dates: Write a script that will automatically fetch the
    dates I held various positions at cost for throughout the history and a list
    of weekly dates to fetch rates for. LedgerHub could use that to fetch all
    the prices it needs at reasonable intervals.





  - (code) Make Position into a namedtuple with hashing instead of just an
    object. See if we can remove its __hash__ method.

  - Also, look at all the objects in b.core.data, and see if you can override
    the hash function on them automatically in order to ignore the entry in
    postings, and the listness in entry.postings. It would be nice to be able
    to hash every directive type.

  - Does table.render_table support offsets for rendering regular tuples? It
    really should.

  - (reports) Implement account rendering ordering properly.

  - Check out bitbucket CGI interface w.r.t. linking to source code, is the
    newer hg better?  We should be able to link to specific lines in versions.

  - (idea) An interesting constraint would be to add an option not to allow any
    postings to any account that is not a leaf account.

  - (filter) Idea: For "virtual postings", you could mark certain tags to be
    excluded by default, to be included only explicitly. e.g. #virtual tag would
    have to be brought in by selecting it via "tag:virtual". Maybe a different
    prefix would be used to distinguish them, e.g. #virtual and %virtual,
    or #virtual and -#virtual; something like that.

  - (filter) Replace bean-holdings by "bean-query holdings", where "holdings"
    is just another type of report. All the reports from the view pages should
    be mirrored exactly in the command-line interface.

  - (high priority) Implement a debugging command in bean-doctor, that spits out
    the entries that were created from the input file, as it is being parsed.
    This should include auto-posting values, inserted price directives, and
    attached tags. This would be a powerful tool to help people debug problems
    with parsing, or not understanding its effects!




  - web: Don't render the full Inventory'es; instead, already render at cost and
    provide their full detail either by clicking on the transaction, which
    should render the full detail of an inventory (for debugging), or in a
    tooltip.

  - Write a script that will highlight some "payee vs tags vs subaccount"
    invariants:
    * Highlight payees that are always used with the same accounts
    * Same with tags

  - Write a script to align numbers... it has been too long and it's quite
    annoying indeed.

  - tree rendering: If a parent account has only a single subaccount and the
    parent account otherwise has no postings in its realization, render the
    account on a single line instead of two, e.g.

      Expenses                     Expenses
        Taxes                        Taxes
          US                           US
            TY2014                       TY2014
              State                        State:Google
                Google                     ...
              ...


  - Plan for integrating rendering and filtering between web/HTML and text
    versions:

    * Filtering: Should be done in a library used in common with the web server
      and a new tool, bean-query, which provides a command-line interface
      to trigger filter, e.g. filter by year, filter by tag, etc. The point is
      that the same code that does the filtering for views should be run from
      this command-line. The code that creates views perhaps should be moved to
      begin that library.

    * Rendering: The web reports, such as beacnount.web.journal,
      beancount.web.acctree, etc. should move to beancount.reports and have
      HTML and text versions of all these.

  - Implement --brief option on scripts.holdings, to be able to share, which
    renders only % holdings.

  - journal rendering: When multiple transactions occur in the same day, it
    may make sense not to render the balance amount until the last one. Test it
    out.


  - validation: We should check that entries created by plugins at some
    initialization point are pointing to the right parents (or maybe we should
    relax the need to set the parent and make that routine set it all at once:
    time this, it it's very small, do this on initialization and that makes it
    easier to write plugins for users and you can do away with entry_replace().)

  - bake: Make bake support curl if wget is not available. It should work with either,
    to relax dependencies.

  - Price entries should have an extra attribute to disambiguate between
    implicitly created prices, linking to the original transaction that created
    them, and explicitly created ones.

  - A table of price entries should be rendered under the price graph in the
    web interface.

  - Web interface: Instead of rendering inventories with the full contents in
    the journal, render the cost, and place the full inventory in a tooltip!

  - Here's how to improve booking against lots!

      "Dealing with average cost trading or cost basis readjustments (not implemented
      yet) involves joining together multiple lots and recreating new ones in a way
      that preserves the total cost in the inventory; with this data structure /
      model it's quite obvious how to implement them as basic operations on an
      inventory.

      I really like the simplicity of this and am wondering if we could make it even
      simpler.

      Automatic booking against an inventory, e.g. adding automatic FIFO or LIFO,
      would require having the date of each lot always inserted in the key of the
      inventory items (from the transaction, not from the lot-date field), along with
      special rules for selecting which lots a posting is allowed to modify,
      essentially ignoring the lot-date from the inventory if the posting does not
      specify it. This is partly why I'm considering making the "lot-date" compulsory
      and adding a "lot identifier" used to disambiguate booking against an inventory
      with multiple matching lots of the same cost with just differing dates, which
      would only be required if the posting constrains it to. One can imagine
      relaxing the matching rules between a posting and inventory further to allow
      one to just specify "-40 GOOG" above, without a cost, and if unambiguous, to
      allow it to just select the only lot that is available."

    Idea: Generalize lot-date to just a "lot" string. Doesn't have to be a date
    at all! It would also make the concept and usage intentions clearer I think.

  - Implement a little plug-ins system that allows a user to insert a TAB in
    bean-web.

  - The Trial Balance page could be a good place to put all the accounts on the
    left and have two sets of columns: beginning of period -> end of period.

  - Implement a little plug-ins system that allows a user to insert a new tab in
    bean-web, with custom display.

  - In ledgerhub, use /usr/bin/strings as a last resort if all other PDF
    converters fail.

  - When we import, if a file was not detected, don't spit out an org text
    line. Still doesn't work.

  - In order to implement .txt output, you will need to decouple the web
    rendering and the generation of its included data. This will be
    great--ability to cut-and-paste any page into txt. format=txt, and we could
    still have the links clickable. Everything else would just be txt. A bit of
    a crazy idea, but it might work well and be simple. Maybe.

  - Bug: A transaction like this fails to parse; allow it:
      2014-02-22 * "Payee" |
        ..

  - Serving CSV files from the Documents page should not be via download, but
    rather rendered directly.

  - The documents web page should render by-month + date, and by-account + date.


  - DO implement output to text NOW for posting on the mailing list.

  - Add views for the last 5 days, one day only each day (for D.Clemente)

  - Add preliminary support for renaming root accounts, even if that means the
    option must come first in the file. Move the checks in the parser.

  - In rendering balance directives, don't render the amount in the "change"
    column; that is too confusing for some users, keep the change column for
    changes.


  - update activity: remove parent accounts with no child accounts.
  - update activity: this exhibits a bug in the table rendering, look for IVV,
    see TODO(blais) in acctree.py

  - Begin user documentation in earnest; we really need this soon.
  - Complete example file with income statement transactions.

  - URGENT - Provide some tooltip or help link from the main page to allow
    discoverability of what a "view" is.

  - URGENT - the level1/2 views are EmptyView's, you need to implement those!

  - Example files (suggestion from Daniel Clemente):

      > >   I think 2 files can be helpful:
      > >
      > >   1) A simple one, a „how to“ file with ~20 transactions, or better, from 1
      to 3 transactions for feature. To show the normal things like receiving a
      salary, getting money from ATM, wire transfer, pay the bills, … So that it does
      not scare people without experience in double accounting.
      > >   demo.beancount fits this place.
      > >
      > >   2) The big one (1 year, you said), to show off that beancount is powerful
      and is really used for long-term accounting. This one is the „inspirational“
      one, to make people say „I would like to do that!“.

  - beancount: GREAT IDEA: output a subset of transactions as a spreadsheet. You
    need to design a textual way to refer to a subset of transactions. Output in
    either directions, without currencies.


  - BUG! import this:
    documents/2013/Assets/CA/RBC/Checking/2013-11-13.ofx84423.qbo
    * The balance check at the end is incorrect
    * The statement are not organized by account; they are mixed together

  - Create a 3rd-party dependencies building script for Mac OSX users (fxt).

  (Cost Basis)
  - Cost basis issue: How do I take into account the commissions and fees
    adjustment on the cost basis for a position?
  - How do I take into account Wash Sale Adjustments to the cost basis?

  - entries_table() really should be called postings_table().

  - Complete parser tests
    * Modify the lexer to emit EOF and add that in the grammar rules for empty_line.
    * BUG: Don't crap out when you can't read the file; error should be reported
      like the other ones.

  - You need to validate the account name options (empty, or no :, use regex to constrain).

  - Move utility functions from bean-prices to a reusable place.

  - Teasing out groups:
    - Can we move documents.py to ops? Look at that.
    - Can core.getters move to ops.getters?

  - Have another script that takes that as input and spits out current positions
    in the market on a web page; CGI script, should be served on Furius. Update
    via a Mercurial repo push.

  - Render tags

  - IMPORTANT FEATURE: Text/XLS exports

  - IMPORTANT FEATURE: Flip balances for rendering

  - IMPORTANT FEATURE: Implement Average Booking for Vanguard & RBC Adjustment,
    with associated tests and syntax in the parser.
    Update for inventory.py:

      def average(self):
          """Merge all lots of the same currency together at their average cost.

          Returns:
            A new instance of Inventory, with all the positions of each currency
            merged together at cost, bringing all these positions at average cost.
          """
          logging.warn('FIXME: continue here, this will be needed to report positions')
          # FIXME: This is ill-defined, the grouping must also take into account the cost currency.

          units_map = defaultdict(Decimal)
          costs_map = defaultdict(Decimal)
          for position in self.positions:
              lot = position.lot

              cost_currency = lot.cost.currency if lot.cost else None
              key = (lot.currency, cost_currency)
              units_map[key] += position.number
              costs_map[key] += position.get_cost().number

          inventory = Inventory()
          for lotcost_currencies, units in units_map.items():
              lot_currency, cost_currency = lotcost_currencies
              cost_number = costs_map[lotcost_currencies]
              inventory.add(Amount(units, lot_currency),
                            Amount(cost_number, cost_currency),
                            allow_negative=True)

          return inventory

  - Do we need to insert Open entries for the equity accounts described in
    options? I think we could safely plop that at the very beginning of the
    entries list in the parser.

  - Render the OFX / QBO files in a <pre> tag, or figure out why the mimetype
    is incorrect and they don't render properly. Right now the default
    rendering of the browser is insufficient.

  - (IDEA) Why aren't we using the price on the first leg of this transaction?
    This is an interesting variation on the meaning of the price: it could mean
    either (a) the price of the lot, or (b) the conversion price of the cost of
    the lot. This would enable the following:

        2013-07-22 * "Bought some US investment in a CAD account"
          Assets:Investment:GOOG           50 GOOG {700 USD} @ 1.01 USD   ;; 35350 CAD
          Assets:Investment:Cash          -35359.95 CAD
          Expenses:Commissions                 9.95 CAD

  - (IDEA) In order to create suitable stock split entries that would look like
    this:

      2013-04-01 * "split 4:1"
        Assets:CA:ITrade:AAPL             -40 AAPL {{5483.09 USD}}
        Assets:CA:ITrade:AAPL             160 AAPL {{5483.09 USD}}

    You could easily add support for a directive that looks like this:

      2013-04-01 split Assets:CA:ITrade:AAPL  4:1  AAPL

    This would allow the user to do some processing specific to stock splits by
    processing the explicit stock split entries.

  - Include this in the user examples, + stock splits:

       2013-04-01 * "name change"

         Assets:CA:ITrade:AAPL             -40 AAPL {{5483.09 USD}}
         Assets:CA:ITrade:NEWAAPL             40 NEWAAPL {{5483.09 USD}}

       2013-04-01 * "spinoff"
         Assets:CA:ITrade:KRFT             -100 KRFT {{20000 USD}}
         Assets:CA:ITrade:KRFT              100 KRFT {{17000 USD}}
         Assets:CA:ITrade:FOO                20 FOO  {{ 3000 USD}}

  - Remove the parsing of "CHECK" at some point, that was just there for
    compatibility.

  - More testing:

       # FIXME: Test a conversion of shares with lot-date, e.g.:
       #
       #   2000-01-18 * Buy CRA
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA           4 "CRA1" {232.00 USD / 2000-01-18}
       #     Assets:CA:RBC-Investing:Taxable-CAD               -1395.43 CAD @ 0.665027984206 USD  ; cost
       #
       #   2000-02-22 * CRA Stock Split 2:1
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA          -4 "CRA1" {232.00 USD / 2000-01-18}
       #     Assets:CA:RBC-Investing:Taxable-CAD:CRA           8 CRA {116.00 USD / 2000-01-18}


  - Add a validation check, that when closing and account, its balance is empty/zero.

  - Render a journal as a detailed expense report, for a set of accounts
    (e.g., Expenses:*) pulling out amounts in various columns based on other
    expressions (e.g. Assets:Cash:Caroline).


  - Idea around documents: A link between a transaction to a document can be
    created by associating a document's checksum as the link of the
    transaction. If Beancount could associate them - and it could, it has
    access to the document files and the corpus of transactions - the web
    interface could insert a special link between the two. Maybe we could do
    the same thing with the filename as well.

  - Implement beancount.plugins.tag_pending as a general feature of links...
    this ought to be built-in by default, this is a great idea.


  - (prices) When attempting a conversion in holdings, if the rate isn't
    available directly, you should always attempt to value it indirectly via
    USD or EUR.

  - Maybe the builder should have a 'filename' state that only gets changed here
    and there instead of getting that fileloc argument passed in every time on
    every rule. Maybe we just always get the fileloc from the parser.c as in
    NUMBER. I think it might make the parser more efficient too... try it out,
    do timings, see how much it improves parsing performance.

  - See if you replace BUILD()'s PyObject_CallMethod to this how much faster it
    gets: "Note that if you only pass PyObject * args, PyObject_CallMethodObjArgs() is a
    faster alternative."
    https://docs.python.org/3/c-api/object.html


** Precision

  - (precision) FIXME: The better way to render numbers at the end would be to
    let the user specify a desired rendering precision for each currency. Deal
    with this throughout better.

       "Hmm, that's right, I should probably set a maximum precision for rendering
       numbers which require more digits than the default of 2. This is an
       interesting one: I need to do something a bit more thorough about precision; 2
       is not appropriate for everything either. I need to figure out a way to let a
       user specify a desired rendering precision for each currency...
       (probably via some options, unfortunately). In the meantime, I've made it so
       that the max number of digits rendered is 5.

       There's also the issue of setting the max digits during arithmetic operations,
       which should also not be 28. I'll deal with that later."

  - Automatically detect precision of each currency based on usage in file:

      (Idea from Daniel Clemente): "You could use auto-detection: for each
      currency, use the maximum number of decimals that the input file used. E.g.
      if user writes 351.64 PLN, 151.1 PLN, 155 PLN, then use 2 decimals.
      Alternatively, use "the most common" number of decimals. If 90% transactions
      have 3 decimals, 5% have 4, 5% have 0, use 3."


** Padding documentation from email
   CLOCK: [2014-01-19 Sun 14:49]

  - Put this in the docs to explain "pad"

     > > Ok, restarted example, let's say you begin
     > > accounting in dec 2013, you'll have this:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >
     > > eventually, moving forward, you'll get to 2014:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >   2014-12-06 * ...
     > >
     > > Allright, now you decide you like this, and you
     > > want to enter statements before you started.
     > > You find your paper statement for november, and
     > > fill in:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >   ; here you insert
     > >   2013-11-04 balance
     > >   2013-11-08 * ...
     > >   2013-11-18 * ...
     > >   ...
     > >   ; this is what was there previously
     > >   2013-12-04 balance
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >   2014-12-06 * ...
     > >
     > > Great. Now, notice how the balance for
     > > 2013-11-04 is probably different than that of
     > > 2013-12-04. If instead of a pad directive you
     > > had added a manual adjustment, you'd have to
     > > change it here. This is the beauty of the pad
     > > directive: it automatically does it for you.
     > >
     > > Now, let's keep going backward in time. You dig
     > > around your records, you find September's
     > > statement, but you cannot find the statement
     > > for October, maybe it's lost, or somewhere
     > > else. Fine! You insert a pad directive to
     > > account for those missing transactions:
     > >
     > >   2010-01-01 open
     > >   2010-01-01 pad
     > >
     > >   2013-09-04 balance
     > >   2013-09-05 * ...
     > >   ... september transactions
     > >   2013-09-30 * ...
     > >   2013-10-04 balance
     > >
     > >   ; padding for missing October statement,
     > > where is my statement?
     > >   2013-10-04 pad
     > >   2013-11-04 balance
     > >
     > >   ... november transactions
     > >   2013-11-08 * ...
     > >   2013-11-18 * ...
     > >   ...
     > >   2013-12-04 balance
     > >
     > >   2013-12-08 * ...
     > >   2013-12-11 * ...
     > >   2013-12-17 * ...
     > >   2013-12-22 * ...
     > >   2013-12-29 * ...
     > >   2014-01-02 * ...
     > >   2014-12-04 balance
     > >
     > >   2014-12-06 * ...
     > >
     > > This is the full example.

Improve this bit:

    >   But the detailed explanation cannot be found. There's only one phrase: „Think
    >   of the Equity account as something from the past that you had to give up in
    >   order to obtain the beginning snapshot of the Assets + Liabilities balance.“
    >
    > Great comment. I'll improve this.

 More user comments:

    >   After doing my research, I found about debits and credits, which in Beancount
    >   you represent with positive numbers and negative numbers respectively. I
    >   found that having a name for each group of accounts helps me to think of them
    >   at the same time, e.g. Liabilities+Equity+Income as part of a common thing,
    >   instead of having to research each of it independently.
    >   In the documentation you start speaking about numbers, then about signs, then
    >   about grouping the accounts. Maybe it's better to go top-down and start
    >   saying that there are two types of account (usually +, usually -) and then
    >   divide each group further.
    >
    > I will change that, thanks for the comment.


* Core
** General

  - Make all imports outside of packages import from the package root, and have
    the package export those symbols explicitly.

** Inventory

  - inventory: rename get_cost() vs. get_cost_position(). Swap them, change all
    the code that needs be changed.

  - Inventory: Implement a test for Inventory.get_amounts() with multiple lots of the same
    currency; they really should have been aggregated.

*** Book at Average Price

  - Inventory: Implement averaging of lots in order to report positions nicely.

  - We should create a syntax and method for booking to the average value.
    Figure out how many units of each position to remove in order to obtain the
    average sale price. This way the user could potentially switch methods.

*** Making adjustments of capital

  - Figure out how to make these kinds of adjustments:

      My name is Ian and I will help you with profit/loss and book value reporting.
      2013-04-19 RTC RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 RETURN OF CAPITAL ADJUSTMENT TO BOOK COST $60.71
      2013-04-25 ADJ RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 NOTIONAL DISTRIBUTION ADJUSTMENT TO BOOK VALUE $2,963.13
      Before you make accounting entries, it is a good idea to understand the underlying transactions.

      ETFs such as XSP, make distributions throughout the year, however they do not know the composition of the income distributed until
      after year end when the trust completes their tax return. When the income in the trust from dividends, capital gains, and income
      are not sufficient to account for all the distributions, the excess distribution is classified as 'return of capital'. Return of
      capital (ROC) is simply some of the capital you paid to buy the fund being returned to you. The ROC amounts are not taxable and
      you deduct them from your XSP book value. The XSP deduction for 2012 is C$60.71 and should be deducted from your book value in
      your April 2013 statement.

      Notional dividends result from the exchange traded fund (ETF) realizing capital gains and/or dividend income then reinvesting the
      gains/dividends in some other security(ies). No cash or reinvested units were distributed to investors but they still have to pay
      tax on the gains/dividends realized within the ETF. When a notional dividend is made, the dividend is included in income and the
      amount of the notional dividend is added to the book value of the underlying security. So you end up paying tax on the dividend up
      front and get a reduced capital gain or increased capital loss when you eventually sell the ETF.

      In your XSP example, if you held the ETF in a taxable account, the notional dividend would be fully taxable as C$2,963.13 income
      for your 2012 return. Your book value would increase by C$2,963.13.

      The book value of XSP for 4,100 units in your March 2013 statement was C$57,127.11. The return of capital reduces your book value
      and the notional dividend increases it so your book value at the end of April 2013 would be C$57,127.11 - C$60.71 (return of
      capital) + C$2,963.13 (notional dividend) = C$60,029.53.


*** Lots

  - Matching on Inventory Lots should be *loose*: try to match automatically
    against the most SPECIFIC lots.

         (AAPL, 18.45, nil) -> +1
         (AAPL, 17.93, nil) -> +1
         (AAPL, nil, nil)   -> -1    ... should choose any of the inventory

    Also, maybe the inventory's date should be filled in automatically by the
    parser... just an idea. Maybe date doesn't have to be allowed to be nil.


*** Original Idea Description for Integrating the Cost Basis in Beancount

  - Every account carries a cost basis.

  - You can have posting with or without a cost-basis.

  - If the posting has a cost-basis posting, the cost-basis is used to balance the
    transaction.

  - As you sum up the postings in the account, keep track of the full inventory as

      (commodity, cost) -> quantity

    As a special case, "cost" can be null. This is the case where there is no cost
    tracking for this commodity item. We maintain the full inventory of positions
    with a cost basis in the account; as a default case, the cost is null.

  - BALANCE CHECK: When balancing a transaction, if an amount has an associated
    cost basis, use the cost basis instead of the actual amount to balance.

  - INVENTORY CHECK: When a position is modified in the inverse direction,
    require a cost to book against. If no cost is specified, it just degrades to
    decrease from the bucket of commodities with a null cost (it all works out!)

  - ZERO CHECK: Insure that the quantity can never be negative for any bucket.

  - Optional extended check syntax: You could extend the @check syntax to include
    the cost, so that technically you could check that there are a specific number

  2013-03-01 * buy
    Assets:Checking        10 GOOG # 700 USD
    Assets:Investment     -7000 USD

  2013-03-15 * sell
    Assets:Checking       -10 GOOG # 700 USD @ 800 USD
    Income:RealizedPnL    -1000 USD
    Assets:Investment      8000 USD


  Syntax

  Test: Items of the same kind with and without cost basis
  Test: Multiple items of different types with a cost basis in the same account

** Smarter elision

  - It would be nice extra feature to allow the user to at least specify the
    currency when a posting's amount is elided; this would constraint the
    elision, and further allow multiple postingsto be elided, like this:

     2013-07-05 * "COMPANY INC PAYROLL"
       Assets:US:TD:Checking                                    USD
       Income:US:Company:GroupTermLife                   -25.38 USD
       Income:US:Company:Salary                        -5000.00 USD
       Assets:US:Vanguard:Cash                           540.00 USD
       Assets:US:Federal:IRAContrib                     -540.00 IRAUSD
       Expenses:Taxes:US:Federal:IRAContrib                     IRAUSD
       Assets:US:Company:Vacation                          4.62 VACHR
       Income:US:Company:Vacation                               VACHR


** Realization

  - You need to convert some of TestRealization to TestCheck.

  - Whether an account shows up in a particular Ledger (realization) really only
    should depend on whether the account was open during the period (we now have
    account open/close dates... let's use them instead of a heuristic!).
    Create a routine to figure out if an account was open during a specific
    time period?

*** Average Price Booking

  - You now HAVE to implement average price tracking... not an option. Thanks
    to Vanguard #$(*#(*$.

** Prices

  - There should be a corresponding view/presentation for rendering information
    that we have about prices.

  - Build helpers tools for users to create their own scripts that will allow
    you to spit out a list of prices for the price DB.

  - Include directives will be necessary for update, because it will enable
    including the file of prices only. The prices should be in beancount
    language too, this should all be a single file format.

* Filtering
** Beancount reorg

  - Remove subaccounts for TMobile and employer once we have filtering working
    out nicely. Same with RedSquare electricity. Same with Employer subaccounts
    for taxes.

      Payees are just like tags!


** Views

  - Replace all views by filtering queries... the root page should still have
    convenient links to various preset views, like the last five years, but
    these links should be implemented using the filtering query feature!
    Maybe it's worth allowing the user to specify common queries in the options
    map, and provide links to them. Do this, and try removing some of my
    subaccounts to simplify the accounts-trees somewhat.

  - The root page should feature a prominent input form that allows the user to
    specify a query! This input needs live at the very root

  - (views) You should be able to filter to all transactions related to some
    account, e.g. Immigration

  - IMPORTANT! Try to let through some of the non-transaction entries in the
    view filtering. We obviously cannot let through balance entries, but
    documents yes, depending on the type of filtering. We should do our best to
    let all the entries carry through.

** Filtering dimensions (Old Notes)

  - By Country

    - You should be able to look at only accounts with a particular pattern (and
      their other legs), e.g. *:CA:*

    - You perhaps should flag all the transactions that have a particular unit
      (e.g. CAD)

  - By Account Prefix

    - Specify a single account, and automatically select all the other accounts
      which are linked by any transaction in this account; generate a balance
      sheet from this list of accounts. e.g. Expenses:Trading, Income:PnL,
      Assets:Trading.

  - By Amount Size

    - I'd love a way to filter down a journal by omitting all the small
      items and keeping just the larger ones, to get an automatic
      overview of the large amounts in a long series of transactions.
      All the small amounts could be lumped together under a special
      entry.

  - By Institution

  - By Country

  - By Tag

  - By Payee

    * You should be able to click on a payee to view its transactions.

  - By Date

    - You should be able to click on dates and see all postings around that date
      too, e.g. +/- 10 days. Another simple and useful filter.

  - By Event (defines a period)

    - "How much did I make during the period of this event", e.g. while I was
      working at CompanyX, while I was in school at UniversityY. This provides
      two dates, generate a view for them:

        /view/event

      This could sum up all the entries for all the internals where the event's
      value was the same.

  - By Currency/Cost-Currency

      You could then possibly compute the IRR around that commodity...


** Custom dimensions

  - From discussion:

       | (digression not about virtual postings but answers auxiliary questions about
       | them)
       |
       | Now this points to a more general idea that I've been pondering for a while:
       | these "accounts" can often be seen as a set of flat dimensions, the fact that
       | they have a hierarchy can get in the way. I tend to have accounts that look
       | like this:
       |
       |   TYPE:COUNTRY:INSTITUTION:ACCOUNT:SUBACCOUNT
       |
       | like this, for example:
       |
       |   Assets:US:HSBC:Checking
       |   Assets:CA:RBC:Savings
       |
       | For these four dimensions, I actually like having most accounts (Assets,
       | Liabilities and Income) specify them in this order. This does not always make
       | sense though, especially for expense accounts; for those you wouldn't really
       | want to have a COUNTRY dimension at the root. You want the general category
       | only, so I'll have, for example:
       |
       |   Expenses:Food:Restaurant
       |   Expenses:Food:Grocery
       |
       | but sometimes the dimensions get inverted too, like in my recent change about
       | how to track taxation:
       |
       |   Expenses:Taxes:US:TY2014:Google:Federal
       |   Expenses:Taxes:US:TY2014:Google:StateNY
       |   Expenses:Taxes:US:TY2014:Google:CityNYC
       |   ...
       | Here the "institution" is Google, and shows deeper in the hierarchy.
       | Finally, you often do want to have multiple types for the same or similar
       | accounts, for instance, to track gains and dividends income from a particular
       | investment account, you want a mirror of most of the dimensions except for the
       | assets bit:
       |
       |   Assets:US:ETrade:IRA -> Income:US:ETrade:IRA
       |
       | For instance:
       |
       |   Assets:US:ETrade:IRA:Cash
       |   Income:US:ETrade:IRA:Dividends
       |
       | You see what I'm getting at... these components really operate more like a
       | database table with values possibly NULL, e.g.,
       |
       |   type     country  institution  account   category
       |   -------- -------- ------------ --------- -----------
       |   Assets   US       HSBC         Checking  NULL
       |   Assets   CA       RBC          Savings   NULL
       |   Assets   US       ETrade       IRA       Cash
       |   Income   US       ETrade       IRA       Dividends
       |   Expenses NULL     NULL         Food      Restaurant
       |   Expenses NULL     NULL         Food      Grocery
       |
       | Having to order your account components in a hierarchy forces you to
       | decide how you want to report on them, a strict order of grouping from
       | top to bottom.
       | So I've been thinking about an experiment to rename all accounts according to
       | dimensions, where the ordering of the components would not matter. These two
       | would point to the same bucket, for example (changing the syntax slightly),
       |
       |   Expenses|Taxes|US|TY2014|Google|Federal
       |   Expenses|US|Google|Taxes|TY2014|StateNY
       |
       | You could then display reports (again, the usual reports, balance sheet,
       | income statement, journals) for "the subset of all transactions which has one
       | posting in an account in <set>" where <set> is defined by values on a list of
       | dimensions, a bit like a WHERE clause would do.
       |
       | Now, now, now... this would be a bit radical, now wouldn't it? Many of these
       | accounts do point to real accounts whose postings have to be booked exactly,
       | and I'm a bit worried about the looseness that this could introduce. One and
       | only one account name for a particular account is a nice property to have.
       |
       | So what can we do to select across many dimensions while still keeping
       | hierarchical account names?
       |
       | The first thing I did in Beancount is to create views for all unique account
       | component names. For example, if the following account exists:
       |
       |   Assets:US:ETrade:IRA
       |
       | You will see four "view" links at the root of the Beancount web page:
       |
       |   Assets
       |   US
       |   ETrade
       |   IRA
       |
       | Clicking on the link selects all the transactions with a posting with an
       | account where that component appears. (Views provide access to all the reports
       | filtered by a subset of transactions.) You can click your way to any journal
       | or report for that subset of transactions. This exists in HEAD today. You can
       | draw all the reports where a particular component appears, e.g., "Google", as
       | in "Income:US:Google:Salary" and "Expenses:Taxes:US:TY2014:Google:Federal".
       |
       | But this does not define "dimensions." It would be nice to group values for
       | these components by what kind of thing they are, e.g., a bank, an instution, a
       | country, a tax year, etc, without regard for their location in the account
       | name. A further experiment will consist in the following:  again assuming
       | unique "account component names" (which is not much of a constraint to
       | require, BTW, at least not in my account names), allow the user to define
       | dimensions by declaring a list of component names that form this dimension.
       | Here's how this would look, with the previous examples (new syntax):
       |
       |   dimension employer  Google,Autodesk,Apple
       |   dimension bank      HSBC,RBC,ETrade
       |   dimension country   US,CA,AU
       |   dimension taxyear   TY2014,TY2013,TY2012,TY2011,TY2010
       |   dimension type      Assets,Liabilities,Equity,Income,Expenses (implicit?)
       |
       | You could then say something like "show me trial balance for all transactions
       | with posting accounts where bank is not NULL group by bank" and you would
       | obtain mini-hierarchies for each group of accounts (by bank, across all other
       | dimensions).
       |
       | (With the state of my current system, I could probably code this as a
       | prototype in a single day.)
       |
       | Addtionally, accounts have currency constraints and a history of postings
       | which define a set o currencies used in them. More selection can be done with
       | this (e.g., show me all transactions with postings that credit/debit CAD
       | units).
       |
       | IMHO, all you're trying to do with these virtual accounts is aggregate with
       | one less dimension, you want to remove the real account and group by community
       | project. My claim is that there are ways to do that without giving up o the
       | elegant balancing rules of the DE system.

    In ealtion to this... these "dimensions", could they just become other
    dimensions in the filtering language?

      component:Google

      employer:Google
      bank:RBC
      country:US

    You can then break down by those, like a GROUP BY clause, and generate
    reports that have those as root accounts, or separate breakdowns.


** Tags used as dimensions

  - If you had tags as key-value pairs, those could be used as well:

      2014-05-21 * ...
        #employer:Google

    Searching for:

      tag:employer=Google

    This is another dimension in the same filtering language.


** Language

  - Example: a-la-Google

      type:Open, type:Price, etc.
      year:2014
      date:2014-05-20
      component:US
      -component:US
      payee:MetroCard  # should be a regexp, not exact
      tag:trip-israel
      amount:>400.00
      currency:USD
      link:7e4116fadbb4
      narration:Deposit
      event:location:New York  <- like dates, but from events!


* Operations
** Validation

  - Write a dedicated routine to check the following invariant:

        # Handle sanity checks when the check is at the beginning of the day.
        check_is_at_beginning_of_day = parser.SORT_ORDER[Check] < 0
        ...
        if check_is_at_beginning_of_day:
            # Note: Check entries are assumed to have been sorted to be before any
            # other entries with the same date. This is supposed to be done by the
            # parser. Verify this invariant here.
            if isinstance(entry, (Check, Open)):
                assert entry.date > prev_date, (
                    "Invalid entry order: Check or Open directive before transaction.",
                    (entry, prev_entry))
            else:
                prev_entry = entry
                prev_date = entry.date

  -  Sanity check: Check that all postings of Transaction entries point to their
     actual parent.

  - Add a special option to set the EPSILON for the check.

      option "check_precision"  "0.01"

    Note: Maybe this check is per-currency, maybe different currencies need
    different precisions.

  - (validation) In addition to the Check/Open before-constraint, check that
    the entries are always sorted. Add this sanity check.

  - The default validation should check the invariant that Open and Check
    directives come before any Transaction.

  - Validation: Everywhere we have a filter of entries to entries, we should be
    able to apply a check that the total balances before and the total balances
    after should have the very same value.

  - In validate.py: differentiate between the case of an entry appearing too
    early before an Open directive, and an entry appearing for an account that
    simply just doesn't exist.

  - Auto-detect and warn on likely duplicate transactions within the file.

** Conversions

  - TODO: Try it out in Ledger, see how they deal with it.

  - Make the conversions entry use a price of zero, to maintain the invariants
    for sanity checks, something like this:

       YYYY-MM-DD * "Annul conversions at end of period"
         Equity:Conversions        -56383 CAD @ 0 CONV
         Equity:Conversions        +67000 USD @ 0 CONV


** Open/Close

  - You must issue an error if you close an account that's got a non-zero
    balance!

** Padding

  - Idea: Padding entries could be extended a tiny bit in order to
    automatically calculate the cash distribution entries, e.g., like this:

      2014-03-04 pad Asset:Cash  Expenses:Restaurant    60%
      2014-03-04 pad Asset:Cash  Expenses:Alcohol       40%

      2014-04-04 pad Asset:Cash  Expenses:Restaurant    70%
      2014-04-04 pad Asset:Cash  Expenses:Alcohol       30%

      2014-05-04 pad Asset:Cash  Expenses:Restaurant    70%
      2014-05-04 pad Asset:Cash  Expenses:Alcohol       30%

    This is a great idea, is in line with the general meaning of pad entries
    (implicit 100%) and would add a much desired feature.

  - Add tests for all the cases of realization padding.

** Locations

  - @location really should just convert into a generic event "location", just
    as address and school should; they're just events with forward fill...
    Serve this at:

       http://localhost:8080/20120101/20130101/events/location/days

  - Add a "reason" field for @location, and display as trips, with
    some sort of meaning to them. Ok, this contradicts the previous idea.



** Payee Elision / Auto-Account Leaf Name

  - About the discrepancy between the concept of "Payee" and a superfluous lead
    account, e.g. Internet:TimeWarner, which typically contains only
    transactions from that payee: maybe we can elide the account name if it
    contains only a single payee, or perhaps a warning may be issued? I don't
    know.

    Basically, it would be nice to be able to have multiple payees in the same
    category over time (e.g. Electricity, Internet) but to be able to separate
    them somehow, without having to put the payee into the name. This is a
    little fuzzy, and I'm not sure how to do it, because the imported payee
    names are often not very clear and often truncated as well.

      Have you ever thought that Payees often end up functioning like an extra
    subaccount? I've come to realize that for Payees that only ever touch a
    single account, the line is really fuzzy there. I've been entertaining the
    idea of automatically creating subaccounts for payees like that.



* Parser
** Errors

  - We need to gather errors in a single place and report them like the others;
    right now I'm catching them in sum_to_date() and writing using the logging
    module; but they really should be trickled up with the rest.

  - Syntax errors currently have no location... this is unacceptable. Write an
    automated test, check for all kinds of errors, in the lexer, in the parser,
    in the Python. (Just work with the line number, we don't really need
    character position.) Test everything with automated tests.

  - 'lineno' is incorrect, it points to the next entry, not the previous one,
    fix this bug! This is really annoying.

  - Set a correct filename in grammar.y

  - Errors from the parser and others should all be accumulated in one place,
    so that we do all the reporting at the very top level.

  - Don't raise error exceptions anywhere; log everything to an error
    handler/accumulator class instead, and skip to the next entry/declaration.
  - Propagate exception from Python(?)

  - Problematic transactions (!) should spit something of color on stdout, they
    should not be forgotten so easily.

  - When using @@ the signs should match; warn if they don't

  - Bug: Invalid account names should only be reported once.

*** Lexer Level Errors

  - When an error occurs, skip the lexer to the next empty line and recommence.

** Options

  - FIXME: We need to parse the options using the same argparse parser....

  - Remove the globals kludge in beancount/core/account.py, and weave the
    necessary AccountTypes instance all over the place.


** Syntax

  - You should support a payee with no description! This generates a parser
    error right now.

  - Allow '$' as currency symbol, don't translate to anything, it can just
    stand on its own as a unique kind of currency, it doesn't matter, no
    changes anywhere. Also add the Euro, GBP and yen symbols.

  - The syntax should support multiline strings naturally...

  - For Links vs. Tags: dont impose an order, parse as tags_or_links.
    Right now the order is tags_list and links_list.

  - You should accept commas in the input; simply ignore their value.

  - Add 1/rate syntax for prices (and anything... really, why not).
    Convert at parsing time.


*** Parser Testing

  - Support a mode for the lexer to spit out its results on stdout, so that we
    can cross-check with parsers in other languages.

*** Includes

  - With the new format... support includes, it makes a lot more sense to do
    that now! People want this too.

  - Idea: an include directive should have a "prefix" option, to add a prefix to
    all accounts from the included file.

*** Sensible Syntax for Lots

  - Consider making the lot syntax like this:

       -4 {GOOG @ 790.83 USD}

    instead of:

       -4 GOOG {790.83 USD}

    It's actually a lot more accurate to what's going on...

** Performance

  - Test using the empty case of list parsing to create the initial empty lists
    instead of the conditional in Parser.handle_list() and measure, to see if
    there is a significant difference in parsing performance.

  - Parser performance: try not calling back to builder for simple types that
    just return their value; measure the difference, it may be worth it, and we
    wouldn't lose much of flexibility, especially for the lexer types, which are
    aplenty.

  - Write the builder object in C... it won't change very much anymore, and
    that's probably simple enough.

** Documents

  - Can we automatically add a ^LINK to the document directive in order to
    associate a PDF with a document?!? -> For trade tickets. Maybe let the
    modules provide a import_link() function on the associated PDF files?
    (This is related to ^64647f10b2fd)

  - Adding the ability for links on document directives was also requested on
    the ledger-cli mailing list.

        On Sat, Apr 26, 2014 at 6:18 AM, Esben Stien <b0ef@esben-stien.name> wrote:

        "Craig Earls" <enderw88@gmail.com> writes:
         The first use in ledger-cli is to link each transaction to a document,
        which is pretty important in accounting;)

        Well no, not exactly. The thing you do in importing financial data is basically
        to funnel transactions from all of your statements from all your institutions
        in a single place in a single format with a single set of accounts, so that you
        can do reporting with a view of everything you have. Having support for a
        per-transaction link to a particular document is generally unnecessary--you can
        easily find the corresponding document by date if you need to.

        In order to associate a unique ID with a particular transaction, in Beancount
        you can use a "link" which is like a special kind of tag. I think Ledger has a
        similar feature, per-post ("tag"?). It looks like this in Beancount:

          2013-04-06 * "Invoice to Metropolis for job well done, waiting for payment."
          ^metropolis-invoice-103
             ...
             ...

        The "^...." bit is a link. You can have multiple links per transactions. The
        web interface can show you all transactions with the same link in a separate
        list (under the /link/.... URL).

        Separately, there is a "document" directive that allows you to associate a
        document with an account, e.g.

          2014-01-01 document  Expenses:Electricity
          "/path/to/filename/ConEdison-2013-12.pdf"

        Documents don't have to be declared that way explicitly: you can also tell
        Beancount about a root directory where it will find documents automatically and
        create the document entries for you. The files just have to be organized in a
        directory hierarchy mirrorring the account names exactly, and files must begin
        with "YYYY-MM-DD" to provide a date for the document. That's a simple
        convention. LedgerHub is able to move files that it recognizes to such a file
        hierarchy, so after you import the data, you file the files into e.g. a local
        git repo with all your statemetns, and your document entries show up in the
        registers. It's also a nice way to organize all your statements, so if you need
        to bring something up for e.g. a tax audit, you quickly know where to find it.

        Those two features are not related at the moment... but I think I'll add the
        ability to have links on document directives. That seems like an effective way
        one could associate a particular pdf document (given a declaration) with a list
        of transactions. You click on the link, see all the transactions + the
        document, and you can click on the document itself to see the detail. Seems
        like a legit idea.


  - Auto-doc from directories of files should ignore files already associated
    via an explicit documents directive; just ignore files with the same
    absolute name.

** Testing

  - Allow file objects to parse() and dump_lexer(). This should use fdopen() or
    whatever else to get this job done at the parser level.

  - You need to clean up the memory of the strings created; call free() on each
    string in the rules.

  - Add a unit test for pushtag/poptag errors.
  - Add unittests for tags, pushtag/poptag

** Dated Postings

  - In order to create multiple similar transactions at many dates in one
    syntax' entry, you could allow overriding the date on each posting, e.g.:

       2013-04-01 * Blah di bla
         2013-01-01  Grocery          10 USD
         2013-02-01  Grocery          10 USD
         2013-03-01  Grocery          10 USD
         Cash

    This would create three transactions, with these dates:

        date           aux-date
        2013-01-01     2013-04-01     10 / 3.33
        2013-02-01     2013-04-01     ...
        2013-03-01     2013-04-01     ...

    Could be a nice way to make distributed transactions.

  - Move 'effective date' to the postings in my input file, using the dated
    postings feature.


  - Another idea would be to make @pad able to pad for a percentage of the
    total, so that we're able to use @pad instead of "distribution of expenses"
    entries.


** Tags as Key-Values / Metadata

  - One idea Ledger uses well is the ability to associate key-values meta-data
    to transaction objects, a-la-Common Lisp. See the --pivot feature. It seems
    a bit superfluous at the moment, but may be useful in order to provide the
    ability to implement custom aggregations eventually, instead of using the
    strings. Maybe the payee could be a special case of this, e.g payee="value"

    (From mailing-list):

      Take this example:

      2011-01-01 * Opening balance
          Assets:Cash                               25.00 GBP
          Equity:Opening balance                   -25.00 GBP

      2011-02-01 * Sell to customer AAA
          ; Customer: AAA
          ; Invoice: 101
          Assets:Receivables                        10.00 GBP
          Income:Sale                              -10.00 GBP

      2011-02-02 * Sell to customer BBB
          ; Customer: BBB
          ; Invoice: 102
          Assets:Receivables                        11.00 GBP
          Income:Sale                              -11.00 GBP

      2011-02-03 * Sell to customer AAA
          ; Customer: AAA
          ; Invoice: 103
          Assets:Receivables                        12.00 GBP
          Income:Sale                              -12.00 GBP

      2011-02-03 * Money received from customer AAA for invoice 101
          ; Customer: AAA
          ; Invoice: 101
          Assets:Cash                               10.00 GBP
          Assets:Receivables                       -10.00 GBP

      Now you can see how much each customer owes you:

      ledger -f d bal assets:receivables --pivot Customer
                 23.00 GBP  Customer
                 12.00 GBP    AAA:Assets:Receivables
                 11.00 GBP    BBB:Assets:Receivables
      --------------------
                 23.00 GBP

      And you can see which invoices haven't been paid yet:

      ledger -f d bal assets:receivables --pivot Invoice
                 23.00 GBP  Invoice
                 11.00 GBP    102:Assets:Receivables
                 12.00 GBP    103:Assets:Receivables
      --------------------
                 23.00 GBP


  - Is it worthwhile to allow tags to become types and have values, like in
    Ledger? I'm not sure that's so useful, but it would provide a more powerful
    mechanism for selecting subsets of transactions.

  - If you add tags with values, you could define some special tags, like
    'document', which could automatically try to find the corresponding
    document in the repository and insert a link to it in the web page. I
    already have a managed stash of document filenames... something like this:

      2014-05-20 * "Invoice from Autodesk"
        #document: 2014-05-20.autodesk.invoice200.pdf
        Income:US:Autodesk  -3475.20 USD
        Assets:US:Checking

    A document filename that does not get resolved could spit out a warning in
    order to keep the file tidy. This is a nice idea... perhaps nicer than just
    insert entries for documents, an actual link. Not sure if it would make that
    much of a difference though. Something to ponder.


* Tools
** Scripts

  - Build some common pandas.DataFrame command-line exporting routine;
    basically, a new script should be able to load a ledger, filter some
    entries, and build a DataFrame of some kind, and then with some COMMON
    OPTIONS provide the ability to generate an output file in either string,
    csv, excel, or html format.

    The point is, the option to generate the output should all be the same.

** Emacs Support

  - Set the comment-syntax; currently it thinks it's '# '

  - In the new mode, we need to recreate a function that will mark a posting as
    valid (replace '!' by '*').

  - A new ledger mode should have functions to

    * Automatically indent postings sensibly (for the amounts)
    * Automatically align lines with currency numbers

* Reports
** Warnings

  - You should have _some_ way to highlight accounts with either failing checks
    in them, or '!' on their postings or transactions in the balance sheet
    and/or trial balance.

  - Perhaps we want to produce a report of all transactions with a highlight on
    them.

** Total Net Worth Report

  - balsheet: For Equity, separately report the total net worth in terms of EACH
    of the operating currencies, using the latest prices.

** General Rendering

  - You should insert thousand-commas everywhere... no, really.... This should
    be in the same routine that renders amounts by account type, with a sign
    possibly inverted.

** Balance Sheet

  - (web) We really need to reorder the accounts in a way that is more
    sensible... it's annoying to see the accounts I care about at the top of
    the page. Cash, Points, AU, should be at the bottom... I wonder if there's
    a nice heuristic. Last updated date? I think that would be good enough.

  - We need to figure out how to order the accounts on the balsheet; I want the
    most relevant near the top. Sorting accounts: compute a score made up of

    * nb. txns from the last 3 months
    * nb. checks from the last 3 months (weighted more heavily)
    * line-no of Open directive in the file.
    * last updated date.

** Capital Statement

  - Implement the Capital Statement report

** Cash Flow Statement


** Statement of Retained Earnings

  - This is possible; search online for examples, makes sense that we should
    have one, it's really, really simple to do.

** Account Linkage Report

  - Generate a Graphviz link of all the interaccount transactions that are
    larger than a certain amount.

    Generate a graph for the main kinds of account
    interchanges, by looking at the most significant transactions
    between the accounts. For example, ignore transactions which are
    too small in absolute value, or whose total is too small a portion
    of the total.

    Fun little project: Create a graphviz output from a Ledger, where
    transactions above a certain amount would generate a link between
    accounts. Note:  the threshold could be either for single
    transactions, or for aggregate amounts (absolute value).

** HTML Rendering

  - Rendering: When you collapse a parent account, its aggregate amount should
    render, and disappear when not collapsed.

  - Numbers should align to the right.

  - USD and CAD should be aggregated in their own columns for balance sheet and
    income statements. These should be specified from the command-line.

  - All entries should have collapsing a-la-JavaScript, along with
    collapse/reveal all buttons. All JS.

  - If the software is finally fast enough in Go, render RESTful on the fly for
    any date:

    * REST:  /balsheet/20121231/
    * REST:  /income/20121231/20131231/

    This way, you could have any year on the same run. No need to restart, even
    have a menu with all the years, and perhaps even some of the latest months.

  - It would be really nice to render the line numbers to the source in the HTML

  - (Performance) Implement buffered output for faster response using a separate
    thread and an iterator that yields from app.write when the data buffer is
    large enough.

  - Postings that have a "!" flag should have at least their
    background red.

  - You should more explicitly state the beginning and ending period
    on each statement pages (it is super important information).
    Just below the title.



** Excel Output

  - Find good ways to transfer data to an Excel spreadsheet. A link to download
    a file should be supported.


** Credits and Debits Rendering

  - Color the background of numbers with an inverted sign (e.g. payments in a
    liability account) differently! There should be modes to rendering balance
    sheets and income statements with inverted amounts, and it should all be
    done client-side. When amounts are rendered as credits/debits, color their
    background distinctly, so that it's obvious what kind of sign convention is
    in use.


** Links to Source

  - The new format code should keep and optionally render the source file/line
    of any transaction, and allow clicking to get to the source line in the
    rendering.

  - Maybe there should be a script that can take a report specification and
    output a list of emacs-compatible links to the entries, interspersed with
    the text format rendering! You could go "next-error" to go through the
    entries in time order, emacs taking you there one-by-one.

** Multi-Period Reports

  - One kind of report that would be GREAT is a single grid with all income accounts
    on the left with year by year on the horizontal. An overview of all the years.

** CSV Reports / Text Reports

 - Using an intermediate data structure, produce text and csv / xls reports,
   downloadable from the web front-end, or even generatable directly. All of
   this reporting infrastructure should be reusable, ideally.

  - A text rendering of the balance sheet / income statement would be
    _very_ useful for collaboration/communication with others. Add a link to
    download a text version of any report. This would be made easy if we only
    have a few distinct types of reports.

** Plots / Time-Series

  - Create a command to extract time series for any account, as a csv file. You
    could then easily use this for plotting!

  - Render this with gviz (you have to learn it at work anyway).

  - Generate graphs of account amounts over time
  - Include average amounts, average delta amount

** List of Positions

  - Given a list of entries, you should be able to extract a list of positions
    at any point in time. Provide this as a simple function that can just be
    reused.

  - The list of positions should provide a way to check the purchase price of
    each position.

  - Positions should attempt to fetch current values using this:
    http://www.google.com/ig/api?stock=RGAGX


** Maximum Values Report

  - You should report a trial-balance -like listing of the minimum and maximum
    values of all the accounts.

** Event Reports

  - We should be able to count the days of each event type.

** Distribution of Expenses and Income

  - Add a pie chart to visualize the constitution of the Income Statement for
    Expenses and Income.

** Summary Reports

  - To create custom views, for example, weekly summaries, you could
    convert the ledger into another ledger, where entries would have
    been replaced by summary entries instead, and all the other
    functionalities would still work.

** Financial Ratio Analysis

  - Add these: http://www.csun.edu/~bjc20362/Controlling-2.pdf

** Budgeting / Goals

  - We could easily add features for budgeting, e.g. somehow set goals and then
    report on the difference between actual and the goal, and project in the
    future according to rate, e.g.:

       ;; Check that the total for this position between 2013-06-01 and 2013-12-31 < 800 USD
       2013-12-31 goal  Expenses:US:Restaurant  2013-06-01  < 800 USD

       ;; Check that the balance of this account on 2013-12-31 is >= 1000 USD
       2013-12-31 goal  Assets:Savings  >= 1000 USD


* Web Interface
** Programmable View

  - GREAT IDEA! Have a web form that you can input a view filtering expression,
    e.g.  year:2014 component:Google
    to have that year's transactions made with this component. Encode the
    results in a unique string that you can decode and create a corresponding
    view of the subset selected by the expression. You can then view any of the
    reports for that subset! This means we can then get rid of many of the root
    page's links automatically, yet still provide all the opportunities... this
    is the way to go, and would best mirror the command-line capabilities.

** Error reporting

  - We really need to list all the '!' entries somewhere; they should be
    annoying.

  - In the balance sheet or trial balance, mark accounts that have errors in
    red, or add a little red start next to them.

  - Implement basic error reporting page from the list of errors.

** Debits and Credits

  - The new balance sheets should be able to invert the numbers (and then they
    should get rendered differently). Basically, every number shown should be
    either in signed or cr/dr format. We should be able to switch between the
    two at render time. This should work across all number-rendering routines
    everywhere--do this centrally.

  - In the balance sheet and income statement, we need to render the amounts
    inverted (and in a slightly different style).

** Links

  - Serve links on: /link/LINK, this needs to be implemented; render a nice
    "link" href on the description somehow, use a fancy unicode char (no
    graphics).

  - (web) Render links to the right of descriptions, and the link href link
    should actually render a page of the related linked entries.

** Single-View Server

  - Idea: for condo & baking files into a zip file: allow serving only one
    ledger realization.

    * One option is to use the same base/root straing as for the web URL:

         http://localhost:8080/byyear/2013/...

      serve_one_ledger(getledger('byyear/2013'), port=8080)
      --realization='byyear/2013'

    This would serve only that realization, and not others. This way I could
    bake only this one in a zip file. This would be useful.

** Code Org

  - (web) Move table rendering functions into their own files, smaller files.

** Aesthetics

  - In the entries table HTML, highlight the relevant posting leg somehow, maybe
    use a '>>' marker, or make it bold. Something. (Bold is too much, use >>.)

  - Render "as of YYYY-MM-DD" under the title for Balance Sheet, and "from
    YYYY-MM-DD to YYYY-MM-DD" under the title for Income Statement


  - Answer to favicon.ico request.

  - Add an option to render the entries table upwards, not just downwards.

  - Use that beautiful new font (Roboto) from Tactile in the new rendering.
    Totally worth it. Use the nice Lucida-like font for numbers, like in
    TurboTax.


*** JavaScript / Client-Side Interaction

  - Render balance sheet/ income statement cells with two numbers for parent
    nodes, so that when you collapse a node, all the amounts of its children sum
    up automatically and display in its cell. You should have a consistent
    report regardless of whether nodes are collapsed or not. This will require
    some JavaScript effort.

  - Implemented a JavaScript cursor in JS. J, K up down. SPC = toggle.

  - In Journal view, pressing 'C' should toggle displaying the checks on and off.

** Search

  - IDEA: Render the transactions into an in-memory SQL database, and provide
    an interface to query it and report results in a table, in the web UI.

** Trial Balance

  - We should have a nicer way to tell what accounts need to be updated.
    Highlight them red if they haven't been updated in more a month
    (configurable).
    Put the last updated date in the balance sheet or perhaps the trial balance
    page. Should be easy; we don't need a dedicated page for this.

  - Do we need a dedicated page for listing all documents? This page could
    include documents without a date, could be rendered as a tree-table, with
    the list of each document in the corresponding account. Maybe that's
    overkill. DK.

  - Shove more information in the Trial Balance page, info about errors, documents, etc.

** Multi-Year

  - A multi-year report is a global report.

** Source

  - The source page should take a special '?line=ddd' parameter that will
    scroll the page to the transaction at that line.

** Conversions

  - Render the Conversions amount at the bottom of the Conversions page...

* Export
** HTML Export as File

  - Test "bean-bake" with the v2, it doesn't appear to work.

** Ledger

  - Export the compatible subset to Ledger format, so you can compare the reports.

** SQL Export

  - Write a script to load the data into an SQL database.


* Documentation
** Users's Manual

  - Include the nice diagram made for DGreenberg, we need a 3D version of it.

  - Defining your accounts
    - Basic structures: *:Country:Institution:SubAccounts
    - "When and why to put accounts together under a single subaccount?"
      - When it makes sense to sum the total together.
        e.g. IRA employer contribution and your own contribution.

  - Checks
    - Checks work for subaccount balances too (add joint account example)

  - Document the fact that the conversions problem occurs

    * Because we don't reduce to a single "home" currency, and
    * That if you do all your work in a single currency with accounts with
      costs, the value will always be zero, and
    * Explain that currency trading accounts have little to do with this,
      because they are contained, and all in and out flows are in a single
      currency (the base currency of the account). The differences can be
      accounted like positions in financial assets, with corresponding PnLs.


  - Under "About Credits & Debits" - this is where you should write about how
    flows are relative to a boundary around the holder of the accounts.


*** Unrealized Gain

  - Unrealized capital gains could be inserted automatically into special
    sub-accounts, based on the current price and the cost-basis of particular
    accounts. This could be inserted automatically! e.g.

        DATE check Assets:US:Ameritrade:AAPL       10 AAPL {200 USD}

        DATE price AAPL  210 USD

      Assets:US:Ameritrade:AAPL                    2000 USD
      Assets:US:Ameritrade:AAPL:Gains               100 USD

    The "Gains" subaccount could be inserted automatically if the price differs
    from the cost basis... this would be a clever way to represent this! We
    could even do this by inserting a transaction automatically with an
    offsetting account... actually this would be the RIGHT way to do this!

      This could be done as a simple filter function:

        entries = add_unrealized(entries)

      We would need an option to designate which subaccount leaf to create all
      the new transactions for:

        %option account_unrealized  "Unrealized"

        2013-05-23 A "Booking unrealized gains for AAPL"
          Assets:US:Ameritrade:AAPL:Unrealized              230.45 USD
          Income:Unrealized                                -230.45 USD

      By doing this, the reporting does not have anything to do... it can choose
      to report positions at cost or in held units, and whether the gains are
      included or not entirely depends on whether these transactions have been
      inserted in or not.


** Design Doc

  - INVARIANT: All the entries lists are assumed to be sorted by date
    everywhere.

  - INVARIANT: All Check and Open entries are always at the beginning of a new
    date in a list of entries.

  - Describe and document the data structures in a language-independent way,
    this is really important.  I have a really nice subset by now.

** Developer Documentation

  - Add nosetests, pylint to tools required for development

  - Document the realization process, need that large zoom-out graphic that
    shows closing, and opening balances.

  - Add a "team project" as an example use case, or even an example file.

  - Look at GnuCash for some of the reports... some good ideas maybe? I could
    perhaps learn a few things, it looks informed.

  - Start documentation so you have a place to put all these ideas.
    Set it up using Sphinx, or something else.

  - Consider serving the user's manual directly from the web interface.

  - Do some serious thinking about payees vs. subaccounts vs. tags w.r.t. to
    named tags.

** Cookbook

  - Write a series of real-life problems solved. This should be really much
    more helpful than boring docs.

  - The examples should be drawn from the demo file; the demo file should be
    rewritten, with multiple years, and with good templates for most of the
    important operations that can take place.

  - Add loft4530 IRR calculation as an example of a custom application script

*** Transfers Between Accounts
*** mortgage, buying a home
*** capital gains (note about how to do commissions)
*** cie expenses, the way I'm doing it.
*** misc, e.g. credit card
*** stock splits
*** Tracking IRA or RSP Contributions
**** Option 1

2012-10-15 * Contribution 1 to RSP
  Assets:Checking                           -2500 CAD
  Assets:Bank1:RSP                           2500 CAD
  Liabilities:PendingContributions          -2500 RSPCAD
  Expenses:RSPContrib                        2500 RSPCAD

2012-11-15 * Contribution 2 to RSP
  Assets:Checking                           -1500 CAD
  Assets:Bank1:RSP                           1500 CAD
  Liabilities:PendingContributions          -1500 RSPCAD
  Expenses:RSPContrib                        1500 RSPCAD

2013-04-30 * Filing Taxes
  Assets:Receivable                           800 CAD
  Expenses:Taxes                             -800 CAD
  Assets:RSPContrib                         -3500 RSPCAD  ; Not claiming all
  Liabilities:PendingContributions          +4000 RSPCAD
  Assets:RSPContrib:Unclaimed                 500 RSPCAD

2013-05-15 * Paying Taxes - Receiving Amount Due
  Assets:Checking                             800 CAD
  Assets:Receivable                          -800 CAD
  Assets:RSPContrib                          1200 RSPCAD
  Income:RSPContrib                         -1200 RSPCAD


Two RSP investment accounts:

  Assets:Bank1:RSP
  Assets:Bank1:RSP

An account to hold maximum RSP contributions allowed:

  Assets:RSPContrib

How much I've contributed to RSPs in total:

  Expenses:RSPContrib

How much my maximum contributions have increased from the governement as a
result of paying taxes:

  Income:RSPContrib

Pending contributions for this year, some of which to be claimed on my tax filing:

  Liabilities:PendingContributions

Unused RSP contributions made, carried forward to future years:

  Assets:RSPContrib:Unclaimed

**** Option 2 (favourite)

2012-10-15 * Contribution 1 to RSP
  Assets:Checking                           -2500 CAD
  Assets:Bank1:RSP                           2500 CAD
  Assets:RSPContrib:MaxDeductible           -2500 RSPCAD
  Assets:RSPContrib:Contributed              2500 RSPCAD

2012-11-15 * Contribution 2 to RSP
  Assets:Checking                           -1500 CAD
  Assets:Bank1:RSP                           1500 CAD
  Assets:RSPContrib:MaxDeductible           -1500 RSPCAD
  Assets:RSPContrib:Contributed              1500 RSPCAD

2013-04-30 * Filing Taxes
  Assets:Receivable                           800 CAD
  Expenses:Taxes                             -800 CAD
  Assets:RSPContrib:Contributed             -3500 RSPCAD  ; Not claiming all
  Expenses:RSPContrib                       +3500 RSPCAD

2013-05-15 * Paying Taxes - Receiving Amount Due
  Assets:Checking                             800 CAD
  Assets:Receivable                          -800 CAD
  Assets:RSPContrib:MaxDeductible            1200 RSPCAD
  Income:RSPContrib                         -1200 RSPCAD

Two RSP investment accounts:

  Assets:Bank1:RSP
  Assets:Bank1:RSP

An account to hold maximum RSP contributions allowed:

  Assets:RSPContrib:MaxDeductible

Pending unused contributions for this year, some of which to be claimed on my
tax filing:

  Assets:RSPContrib:Contributed

How much I've contributed to RSPs in total:

  Expenses:RSPContrib

How much my maximum contributions have increased from the governement as a
result of paying taxes:

  Income:RSPContrib



** Challenges

  - Document those below which I'm already able to do, and those which require
    new features to be able to be done, move them into a separate appendix,
    with explanations on how to do it.

**** Cash vs. Accrual Accounting

Of course a real accountant would just do this: (accrual based accounting)

2014-05-19 * "Booking tithe”
 Expenses:Tithe     300 USD
 Liabilities:Tithe     -300 USD

2014-05-20 * “Paying tithe”
  Liabilities:Tithe      300 USD
  Assets:Checking  -300 USD

But this records the expense on a different day than when you actually paid it.
That would be a problem if, for example, you live in the US and wanted to claim
a tax deduction for the tithe, in which case you must claim the deduction for
the year the tithe was actually paid (cash based accounting).

This is indeed the right solution to this! Accumulate a liability as you go,
and resolve it with real transactions later on.

This case keeps coming back again and again, of wanting to do accrual
accounting but wanting to do cash declarations. I think we need to have a long
and separate discussion about cash vs accrual accounting and for sure we can
come up with a creative solution that solves this problem.



**** Can I generate a nice year-on-year summary of income and expenses?

  - Including RSP contribs, like my bu spreadsheet that I crafted manually? Can
    I do that? That would be awesome!

**** Maximum Balance

  - Can I compute the maximum value of each account at the end of every year
    (for foreign assets decl.) This would be useful for FBAR / FATCA
    declarations.

**** Complete Return (IRR) on Condo

  - Challenge: Can I compute IRR return on my condo accurately?
    TODO: Add benefits received as an Income, as transactions.
    You should be able to compute the IRR of any Ledger!

**** Taxation Rate

  - Challenge: Can I automatically compute my taxation rate for every year?

**** List of Assets

  - Challenge: Can I obtain a list of my assets at any time?

**** Make a report of currency exposure

  - For a particular balance sheet, report the total currency exposure of the
    ledger. This should be a very simple report, probably in the form of a pie
    chart.  Maybe this pie chart should be located in the capital report
    (possibly makes sense).

**** Capital Gains

  - Capital gains should not count commissions nor on the buy nor on the
    sell side. How do we book them like this?  Can we count this somehow
    automatically? Misc accounts? Not sure.

**** Inflation Adjusted Balance Sheets and Charts

  - It would be AWESOME to look at a balance sheets from the past but
    inflation-adjusted for any date... Answer this question easily:

      "What was I making in 2010 in today's dollar terms?"

  - How would I produce an inflation adjusted version of some charts. Maybe all
    charts should have that option?

**** Statement of Assets (for Will)

  - In order to have someone else be able to take care of your business, you
    should be able to produce a list of the accounts open at the end of the
    period, with the account ids and balances. This should be printable and
    storable, for someone else to take care of your things in case you die.


** Change List

- Implemented in Python 3, from scratch.

- Internal data structures are more functional, immutable, allowing you to more
  easily create scripts that use the in-memory data. Overall, the new code is
  way simpler and much easier to understand because of this. It's actually
  become dead simple.

- New, simplified, and more consistent (and rigid) syntax will make it possible
  to add more features in the future, and to have parsers in other languages too
  (e.g. Go).

- Booking trades with capital gain tracking should now work.

- The new parser is written in C, so it is much much faster, and future changes
  will be easier

- The new web server fixes annoying rendering issues.

  * Balance sheet amounts can now reported in terms of book values.
  * Debit accounts can now be rendered with positive numbers (color-coded).
  * The internal data structure changes are much more general, and allow, for
    instance, creating a balance sheet at any point in time. In particular, you
    can have a balance sheet at the beginning and end of an exercise.

- Some internal design flaws were fixed, like checks on filtered ledgers showing
  up from incorrect periods.

- Various outputs to text, csv, and xls are now supported for easier sharing.

- The input file is monitored by the server, and can be automatically reloaded.
  This makes it easier to just start the web server, then edit the file to
  update what you need.

- There is no need to specify a filter period anymore; the interface is able to
  realize any required periods, and the GUI provides access to most common
  cross-sections (all, by year, by tag, by payee, transactions with bookings,
  etc.). You should be able to just specify the GUI.

- Client-side javascript has been added for a neater, more compact rendering of
  journals.

- New scripts to extract a list of current positions at any time, and global
  summaries over many years or months.


** Presentation Material

  - Use impress.js to built a visualization of the DE method

  - Record a video, that's an easy way to explain how this works.

  - IDEA!!!  Use drawings a-la-ThinkBig or whatever it is. This will be the
    perfect medium for this. Mix it with video. Start writing a detailed script.

  - Begin with a USB key in hand. "On this 8 GB USB key, I have all of 8 years
    history of financial transactions in my life. Every single price paid that
    went recorded into an account it these.
