-*- mode: org -*-
beancount: TODO
* Current

  - Remove all "unittest.main()" I used on the train; install nosetests on mac box

  - Complete design doc
  - Complete core tests


  - Complete parser tests
    * Modify the lexer to emit EOF and add that in the grammar rules for empty_line.
    * BUG: Parser errors should not throw exceptions... we need to recover from
      these gracefully, skipping to the next entry (delete partially parsed entries).
    * BUG: Don't crap out when you can't read the file; error should be reported
      like the other ones.

  - You need to validate the account name options (empty, or no :, use regex to constrain).



  - Implement all the missing global pages.




  - Rename "check" to "test/balance/verify/assert" (see what Ledger calls it these days)
  - Implement average booking and associated syntax

  - Move bean-trial reorder() function to realization.py
  - Move utility functions from bean-prices to a reusable place.

  - Teasing out groups:
    - Can we move documents.py to ops? Look at that.
    - Can core.getters move to ops.getters?

  - Before we start importing, validate that the importer modules all have a
    CONFIG, import_file and import_date functions.  This will help thirdparty
    implementors.

  - Render the OFX / QBO files in a <pre> tag, or figure out why the mimetype
    is incorrect and they don't render properly.


  - Have another script that takes that as input and spits out current positions
    in the market on a web page; CGI script, should be served on Furius. Update
    via a Mercurial repo push.

    * Move the price fetching utilities somewhere it can be reused by others;
      move code from bean-prices.


  - IMPORTANT FEATURE: Text/XLS exports
  - IMPORTANT FEATURE: Flip balances for rendering
  - IMPORTANT FEATURE: Auto-categorization
  - IMPORTANT FEATURE: Implement Average Booking for Vanguard & RBC Adjustment

  - Convert all the importers to use the DateIntervalTicker.

  - Render tags and links


  - BUG: A posting with a following line that has some whitespace on it fails
    with a parsing error... this should not be the case. Review what happened,
    fix this now.

  - (import) We need to be able to invert the input (this is easy, conversion
    only, could be applied across any importer)

  - Do we need to insert Open entries for the equity accounts described in
    options? I think we could safely plop that at the very beginning of the
    entries list in the parser.

* Core
** General

  - Clean up: add unit tests for everything, and docstrings everywhere.
    This new version will be really, really clean!

  - Clean up code: remove all significant codes from __init__.py files.

  - Fix all FIXMEs everywhere.

  - Run pylint on the entire codebase.

  - Make all imports outside of packages import from the package root, and have
    the package export those symbols explicitly.

  - (cleanup) Create an account_join() function in account.py to remove ':' everywhere.

** Inventory

  - inventory: rename get_cost() vs. get_cost_position(). Swap them, change all
    the code that needs be changed.

  - Inventory: Implement a test for Inventory.get_amounts() with multiple lots of the same
    currency; they really should have been aggregated.

*** Book at Average Price

  - Inventory: Implement averaging of lots in order to report positions nicely.

  - We should create a syntax and method for booking to the average value.
    Figure out how many units of each position to remove in order to obtain the
    average sale price. This way the user could potentially switch methods.

*** Making adjustments of capital

  - Figure out how to make these kinds of adjustments:

      My name is Ian and I will help you with profit/loss and book value reporting.
      2013-04-19 RTC RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 RETURN OF CAPITAL ADJUSTMENT TO BOOK COST $60.71
      2013-04-25 ADJ RR -- XSP -- ISHARES S&P 500 INDEX FUND (CAD-HEDGED) 2012 NOTIONAL DISTRIBUTION ADJUSTMENT TO BOOK VALUE $2,963.13
      Before you make accounting entries, it is a good idea to understand the underlying transactions.

      ETFs such as XSP, make distributions throughout the year, however they do not know the composition of the income distributed until
      after year end when the trust completes their tax return. When the income in the trust from dividends, capital gains, and income
      are not sufficient to account for all the distributions, the excess distribution is classified as 'return of capital'. Return of
      capital (ROC) is simply some of the capital you paid to buy the fund being returned to you. The ROC amounts are not taxable and
      you deduct them from your XSP book value. The XSP deduction for 2012 is C$60.71 and should be deducted from your book value in
      your April 2013 statement.

      Notional dividends result from the exchange traded fund (ETF) realizing capital gains and/or dividend income then reinvesting the
      gains/dividends in some other security(ies). No cash or reinvested units were distributed to investors but they still have to pay
      tax on the gains/dividends realized within the ETF. When a notional dividend is made, the dividend is included in income and the
      amount of the notional dividend is added to the book value of the underlying security. So you end up paying tax on the dividend up
      front and get a reduced capital gain or increased capital loss when you eventually sell the ETF.

      In your XSP example, if you held the ETF in a taxable account, the notional dividend would be fully taxable as C$2,963.13 income
      for your 2012 return. Your book value would increase by C$2,963.13.

      The book value of XSP for 4,100 units in your March 2013 statement was C$57,127.11. The return of capital reduces your book value
      and the notional dividend increases it so your book value at the end of April 2013 would be C$57,127.11 - C$60.71 (return of
      capital) + C$2,963.13 (notional dividend) = C$60,029.53.


*** Lots

  - Matching on Inventory Lots should be *loose*: try to match automatically
    against the most SPECIFIC lots.

         (AAPL, 18.45, nil) -> +1
         (AAPL, 17.93, nil) -> +1
         (AAPL, nil, nil)   -> -1    ... should choose any of the inventory

    Also, maybe the inventory's date should be filled in automatically by the
    parser... just an idea. Maybe date doesn't have to be allowed to be nil.


*** Original Idea Description for Integrating the Cost Basis in Beancount

  - Every account carries a cost basis.

  - You can have posting with or without a cost-basis.

  - If the posting has a cost-basis posting, the cost-basis is used to balance the
    transaction.

  - As you sum up the postings in the account, keep track of the full inventory as

      (commodity, cost) -> quantity

    As a special case, "cost" can be null. This is the case where there is no cost
    tracking for this commodity item. We maintain the full inventory of positions
    with a cost basis in the account; as a default case, the cost is null.

  - BALANCE CHECK: When balancing a transaction, if an amount has an associated
    cost basis, use the cost basis instead of the actual amount to balance.

  - INVENTORY CHECK: When a position is modified in the inverse direction,
    require a cost to book against. If no cost is specified, it just degrades to
    decrease from the bucket of commodities with a null cost (it all works out!)

  - ZERO CHECK: Insure that the quantity can never be negative for any bucket.

  - Optional extended check syntax: You could extend the @check syntax to include
    the cost, so that technically you could check that there are a specific number

  2013-03-01 * buy
    Assets:Checking        10 GOOG # 700 USD
    Assets:Investment     -7000 USD

  2013-03-15 * sell
    Assets:Checking       -10 GOOG # 700 USD @ 800 USD
    Income:RealizedPnL    -1000 USD
    Assets:Investment      8000 USD


  Syntax

  Test: Items of the same kind with and without cost basis
  Test: Multiple items of different types with a cost basis in the same account



** Realization

  - You need to convert some of TestRealization to TestCheck.

  - Whether an account shows up in a particular Ledger (realization) really only
    should depend on whether the account was open during the period (we now have
    account open/close dates... let's use them instead of a heuristic!).
    Create a routine to figure out if an account was open during a specific
    time period?

*** Testing

  - Finish the inventory_test.py, with the guard against negative balances when
    a position has an associated cost or lot-date, a test is important.

*** Average Price Booking

  - You now HAVE to implement average price tracking... not an option. Thanks
    to Vanguard #$(*#(*$.

** Prices

  - There should be a corresponding view/presentation for rendering information
    that we have about prices.

  - Build helpers tools for users to create their own scripts that will allow
    you to spit out a list of prices for the price DB.

  - Include directives will be necessary for update, because it will enable
    including the file of prices only. The prices should be in beancount
    language too, this should all be a single file format.

* Operations
** Validation

  - Add a special option to set the EPSILON for the check.

      option "check_precision"  "0.01"

    Note: Maybe this check is per-currency, maybe different currencies need
    different precisions.

  - (validation) In addition to the Check/Open before-constraint, check that
    the entries are always sorted. Add this sanity check.

  - Implement check on the constraint on the kind of currency each account may
    contain. -> validate.py

  - The default validation should check the invariant that Open and Check
    directives come before any Transaction.

  - Check that the currency constraints on accounts are respected.
    (Implement the currency constraints...)

  - Validation: Everywhere we have a filter of entries to entries, we should be
    able to apply a check that the total balances before and the total balances
    after should have the very same value.

  - In validate.py: differentiate between the case of an entry appearing too
    early before an Open directive, and an entry appearing for an account that
    simply just doesn't exist.

  - Auto-detect and warn on likely duplicate transactions within the file.

** Conversions

  - TODO: Try it out in Ledger, see how they deal with it.

  - Make the conversions entry use a price of zero, to maintain the invariants
    for sanity checks, something like this:

       YYYY-MM-DD * "Annul conversions at end of period"
         Equity:Conversions        -56383 CAD @ 0 CONV
         Equity:Conversions        +67000 USD @ 0 CONV


** Open/Close

  - You must issue an error if you close an account that's got a non-zero
    balance!

** Padding

  - Add tests for all the cases of realization padding.

** Locations

  - @location really should just convert into a generic event "location", just
    as address and school should; they're just events with forward fill...
    Serve this at:

       http://localhost:8080/20120101/20130101/events/location/days

  - Add a "reason" field for @location, and display as trips, with
    some sort of meaning to them. Ok, this contradicts the previous idea.



** Auto-Categorization

  - Write a generic import routine that will try to heuristically match
    partially completed transactions from an existing Ledger. Use some NLP or
    somesuch matching algorithm.

    Given some incomplete transactions, complete them heuristically based on
    previous contents of the ledger. This should make import a lot easier. This
    should be generic and work across all importers, a single function call.

** Payee Elision / Auto-Account Leaf Name

  - About the discrepancy between the concept of "Payee" and a superfluous lead
    account, e.g. Internet:TimeWarner, which typically contains only
    transactions from that payee: maybe we can elide the account name if it
    contains only a single payee, or perhaps a warning may be issued? I don't
    know.

    Basically, it would be nice to be ablet to have multiple payees in the same
    category over time (e.g. Electricity, Internet) but to be able to separate
    them somehow, without having to put the payee into the name. This is a
    little fuzzy, and I'm not sure how to do it, because the imported payee
    names are often not very clear and often truncated as well.


* Parser
** Errors

  - We need to gather errors in a single place and report them like the others;
    right now I'm catching them in sum_to_date() and writing using the logging
    module; but they really should be trickled up with the rest.

  - Syntax errors currently have no location... this is unacceptable. Write an
    automated test, check for all kinds of errors, in the lexer, in the parser,
    in the Python. (Just work with the line number, we don't really need
    character position.) Test everything with automated tests.

  - 'lineno' is incorrect, it points to the next entry, not the previous one,
    fix this bug! This is really annoying.

  - Set a correct filename in grammar.y

  - Errors from the parser and others should all be accumulated in one place,
    so that we do all the reporting at the very top level.

  - Don't raise error exceptions anywhere; log everything to an error
    handler/accumulator class instead, and skip to the next entry/declaration.
  - Propagate exception from Python(?)

  - Problematic transactions (!) should spit something of color on stdout, they
    should not be forgotten so easily.

  - When using @@ the signs should match; warn if they don't

  - Bug: Invalid account names should only be reported once.

*** Lexer Level Errors

  - When an error occurs, skip the lexer to the next empty line and recommence.

** Options

  - FIXME: We need to parse the options using the same argparse parser....

  - Remove all strings for types (e.g. Assets), this must go into an option
    context. Make the parser use the options name_* fields in order to validate
    and change the lexer to recognize all account names, not specificially the
    hardcoded ones we have now. (Assets|Liabilities|...).

** Syntax

  - Allow '$' as currency symbol, don't translate to anything, it can just
    stand on its own as a unique kind of currency, it doesn't matter, no
    changes anywhere. Also add the Euro, GBP and yen symbols.

  - The syntax should support multiline strings naturally...

  - For Links vs. Tags: dont impose an order, parse as tags_or_links.
    Right now the order is tags_list and links_list.

  - You should accept commas in the input; simply ignore their value.

  - Add 1/rate syntax for prices (and anything... really, why not).
    Convert at parsing time.


*** Parser Testing

  - Support a mode for the lexer to spit out its results on stdout, so that we
    can cross-check with parsers in other languages.

*** Includes

  - With the new format... support includes, it makes a lot more sense to do
    that now! People want this too.

  - Idea: an include directive should have a "prefix" option, to add a prefix to
    all accounts from the included file.

*** Sensible Syntax for Lots

  - Consider making the lot syntax like this:

       -4 {GOOG @ 790.83 USD}

    instead of:

       -4 GOOG {790.83 USD}

    It's actually a lot more accurate to what's going on...

** Performance

  - Parser performance: try not calling back to builder for simple types that
    just return their value; measure the difference, it may be worth it, and we
    wouldn't lose much of flexibility, especially for the lexer types, which are
    aplenty.

  - Write the builder object in C... it won't change very much anymore, and
    that's probably simple enough.

** Documents

  - Can we automatically add a ^LINK to the document directive in order to
    associate a PDF with a document?!? -> For trade tickets. Maybe let the
    modules provide a import_link() function on the associated PDF files?
    (This is related to ^64647f10b2fd)

  - Auto-doc from directories of files should ignore files already associated
    via an explicit documents directive; just ignore files with the same
    absolute name.

** Testing

  - Allow file objects to parse() and dump_lexer(). This should use fdopen() or
    whatever else to get this job done at the parser level.

  - You need to clean up the memory of the strings created; call free() on each
    string in the rules.

  - Add a unit test for pushtag/poptag errors.
  - Add unittests for tags, pushtag/poptag

** Dated Postings

  - In order to create multiple similar transactions at many dates in one
    syntax' entry, you could allow overriding the date on each posting, e.g.:

       2013-04-01 * Blah di bla
         2013-01-01  Grocery          10 USD
         2013-02-01  Grocery          10 USD
         2013-03-01  Grocery          10 USD
         Cash

    This would create three transactions, with these dates:

        date           aux-date
        2013-01-01     2013-04-01     10 / 3.33
        2013-02-01     2013-04-01     ...
        2013-03-01     2013-04-01     ...

    Could be a nice way to make distributed transactions.

  - Move 'effective date' to the postings in my input file, using the dated
    postings feature.


  - Another idea would be to make @pad able to pad for a percentage of the
    total, so that we're able to use @pad instead of "distribution of expenses"
    entries.


* Tools
** Scripts

  - Build some common pandas.DataFrame command-line exporting routine;
    basically, a new script should be able to load a ledger, filter some
    entries, and build a DataFrame of some kind, and then with some COMMON
    OPTIONS provide the ability to generate an output file in either string,
    csv, excel, or html format.

    The point is, the option to generate the output should all be the same.

** Emacs Support

  - Set the comment-syntax; currently it thinks it's '# '

  - In the new mode, we need to recreate a function that will mark a posting as
    valid (replace '!' by '*').

  - A new ledger mode should have functions to

    * Automatically indent postings sensibly (for the amounts)
    * Automatically align lines with currency numbers

* Reports
** Warnings

  - You should have _some_ way to highlight accounts with either failing checks
    in them, or '!' on their postings or transactions in the balance sheet
    and/or trial balance.

  - Perhaps we want to produce a report of all transactions with a highlight on
    them.

** Total Net Worth Report

  - balsheet: For Equity, separately report the total net worth in terms of EACH
    of the operating currencies, using the latest prices.

** General Rendering

  - You should insert thousand-commas everywhere... no, really.... This should
    be in the same routine that renders amounts by account type, with a sign
    possibly inverted.

** Balance Sheet

  - (web) We really need to reorder the accounts in a way that is more
    sensible... it's annoying to see the accounts I care about at the top of
    the page. Cash, Points, AU, should be at the bottom... I wonder if there's
    a nice heuristic. Last updated date? I think that would be good enough.

  - We need to figure out how to order the accounts on the balsheet; I want the
    most relevant near the top. Sorting accounts: compute a score made up of

    * nb. txns from the last 3 months
    * nb. checks from the last 3 months (weighted more heavily)
    * line-no of Open directive in the file.
    * last updated date.

** Capital Statement

  - Implement the Capital Statement report

** Cash Flow Statement


** Statement of Retained Earnings

  - This is possible; search online for examples, makes sense that we should
    have one, it's really, really simple to do.

** Account Linkage Report

  - Generate a Graphviz link of all the interaccount transactions that are
    larger than a certain amount.

    Generate a graph for the main kinds of account
    interchanges, by looking at the most significant transactions
    between the accounts. For example, ignore transactions which are
    too small in absolute value, or whose total is too small a portion
    of the total.

    Fun little project: Create a graphviz output from a Ledger, where
    transactions above a certain amount would generate a link between
    accounts. Note:  the threshold could be either for single
    transactions, or for aggregate amounts (absolute value).

** HTML Rendering

  - Rendering: When you collapse a parent account, its aggregate amount should
    render, and disappear when not collapsed.

  - Numbers should align to the right.

  - USD and CAD should be aggregated in their own columns for balance sheet and
    income statements. These should be specified from the command-line.

  - All entries should have collapsing a-la-JavaScript, along with
    collapse/reveal all buttons. All JS.

  - If the software is finally fast enough in Go, render RESTful on the fly for
    any date:

    * REST:  /balsheet/20121231/
    * REST:  /income/20121231/20131231/

    This way, you could have any year on the same run. No need to restart, even
    have a menu with all the years, and perhaps even some of the latest months.

  - It would be really nice to render the line numbers to the source in the HTML

  - (Performance) Implement buffered output for faster response using a separate
    thread and an iterator that yields from app.write when the data buffer is
    large enough.

  - Postings that have a "!" flag should have at least their
    background red.

  - You should more explicitly state the beginning and ending period
    on each statement pages (it is super important information).
    Just below the title.



** Excel Output

  - Find good ways to transfer data to an Excel spreadsheet. A link to download
    a file should be supported.


** Credits and Debits Rendering

  - Color the background of numbers with an inverted sign (e.g. payments in a
    liability account) differently! There should be modes to rendering balance
    sheets and income statements with inverted amounts, and it should all be
    done client-side. When amounts are rendered as credits/debits, color their
    background distinctly, so that it's obvious what kind of sign convention is
    in use.


** Links to Source

  - The new format code should keep and optionally render the source file/line
    of any transaction, and allow clicking to get to the source line in the
    rendering.

  - Maybe there should be a script that can take a report specification and
    output a list of emacs-compatible links to the entries, interspersed with
    the text format rendering! You could go "next-error" to go through the
    entries in time order, emacs taking you there one-by-one.

** Multi-Period Reports

  - One kind of report that would be GREAT is a single grid with all income accounts
    on the left with year by year on the horizontal. An overview of all the years.

** CSV Reports / Text Reports

 - Using an intermediate data structure, produce text and csv / xls reports,
   downloadable from the web front-end, or even generatable directly. All of
   this reporting infrastructure should be reusable, ideally.

  - A text rendering of the balance sheet / income statement would be
    _very_ useful for collaboration/communication with others. Add a link to
    download a text version of any report. This would be made easy if we only
    have a few distinct types of reports.

** Plots / Time-Series

  - Create a command to extract time series for any account, as a csv file. You
    could then easily use this for plotting!

  - Render this with gviz (you have to learn it at work anyway).

  - Generate graphs of account amounts over time
  - Include average amounts, average delta amount

** List of Positions

  - Given a list of entries, you should be able to extract a list of positions
    at any point in time. Provide this as a simple function that can just be
    reused.

  - The list of positions should provide a way to check the purchase price of
    each position.

  - Positions should attempt to fetch current values using this:
    http://www.google.com/ig/api?stock=RGAGX


** Maximum Values Report

  - You should report a trial-balance -like listing of the minimum and maximum
    values of all the accounts.

** Event Reports

  - We should be able to count the days of each event type.

** Distribution of Expenses and Income

  - Add a pie chart to visualize the constitution of the Income Statement for
    Expenses and Income.

** Summary Reports

  - To create custom views, for example, weekly summaries, you could
    convert the ledger into another ledger, where entries would have
    been replaced by summary entries instead, and all the other
    functionalities would still work.

** Financial Ratio Analysis

  - Add these: http://www.csun.edu/~bjc20362/Controlling-2.pdf

** Budgeting / Goals

  - We could easily add features for budgeting, e.g. somehow set goals and then
    report on the difference between actual and the goal, and project in the
    future according to rate, e.g.:

       ;; Check that the total for this position between 2013-06-01 and 2013-12-31 < 800 USD
       2013-12-31 goal  Expenses:US:Restaurant  2013-06-01  < 800 USD

       ;; Check that the balance of this account on 2013-12-31 is >= 1000 USD
       2013-12-31 goal  Assets:Savings  >= 1000 USD


* Web Interface
** Error reporting

  - We really need to list all the '!' entries somewhere; they should be
    annoying.

  - In the balance sheet or trial balance, mark accounts that have errors in
    red, or add a little red start next to them.

  - Implement basic error reporting page from the list of errors.

** Debits and Credits

  - The new balance sheets should be able to invert the numbers (and then they
    should get rendered differently). Basically, every number shown should be
    either in signed or cr/dr format. We should be able to switch between the
    two at render time. This should work across all number-rendering routines
    everywhere--do this centrally.

  - In the balance sheet and income statement, we need to render the amounts
    inverted (and in a slightly different style).

** Links

  - Serve links on: /link/LINK, this needs to be implemented; render a nice
    "link" href on the description somehow, use a fancy unicode char (no
    graphics).

  - (web) Render links to the right of descriptions, and the link href link
    should actually render a page of the related linked entries.

** Single-View Server

  - Idea: for condo & baking files into a zip file: allow serving only one
    ledger realization.

    * One option is to use the same base/root straing as for the web URL:

         http://localhost:8080/byyear/2013/...

      serve_one_ledger(getledger('byyear/2013'), port=8080)
      --realization='byyear/2013'

    This would serve only that realization, and not others. This way I could
    bake only this one in a zip file. This would be useful.

** Code Org

  - (web) Move table rendering functions into their own files, smaller files.

** Aesthetics

  - In the entries table HTML, highlight the relevant posting leg somehow, maybe
    use a '>>' marker, or make it bold. Something. (Bold is too much, use >>.)

  - Render "as of YYYY-MM-DD" under the title for Balance Sheet, and "from
    YYYY-MM-DD to YYYY-MM-DD" under the title for Income Statement


  - Answer to favicon.ico request.

  - Add an option to render the entries table upwards, not just downwards.

  - Use that beautiful new font (Roboto) from Tactile in the new rendering.
    Totally worth it. Use the nice Lucida-like font for numbers, like in
    TurboTax.


*** JavaScript / Client-Side Interaction

  - Render balance sheet/ income statement cells with two numbers for parent
    nodes, so that when you collapse a node, all the amounts of its children sum
    up automatically and display in its cell. You should have a consistent
    report regardless of whether nodes are collapsed or not. This will require
    some JavaScript effort.

  - Implemented a JavaScript cursor in JS. J, K up down. SPC = toggle.

  - In Journal view, pressing 'C' should toggle displaying the checks on and off.

** Views

  - Complete listing all the views really nicely in the TOC.

  - (views) You should be able to filter to all transactions related to some
    account, e.g. Immigration

  - In the TOC, list and create views for level 2 (country) and level3
    (institution).

*** View Types

  - By Country

    - You should be able to look at only accounts with a particular pattern (and
      their other legs), e.g. *:CA:*

    - You perhaps should flag all the transactions that have a particular unit
      (e.g. CAD)

  - By Account Prefix

    - Specify a single account, and automatically select all the other accounts
      which are linked by any transaction in this account; generate a balance
      sheet from this list of accounts. e.g. Expenses:Trading, Income:PnL,
      Assets:Trading.

  - By Amount Size

    - I'd love a way to filter down a journal by omitting all the small
      items and keeping just the larger ones, to get an automatic
      overview of the large amounts in a long series of transactions.
      All the small amounts could be lumped together under a special
      entry.

  - By Institution

  - By Country

  - By Tag

  - By Payee

    * You should be able to click on a payee to view its transactions.

  - By Date

    - You should be able to click on dates and see all postings around that date
      too, e.g. +/- 10 days. Another simple and useful filter.

  - By Event (defines a period)

    - "How much did I make during the period of this event", e.g. while I was
      working at CompanyX, while I was in school at UniversityY. This provides
      two dates, generate a view for them:

        /view/event

      This could sum up all the entries for all the internals where the event's
      value was the same.

  - By Currency/Cost-Currency

      You could then possibly compute the IRR around that commodity...


** Search

  - IDEA: Render the transactions into an in-memory SQL database, and provide
    an interface to query it and report results in a table, in the web UI.

** Trial Balance

  - We should have a nicer way to tell what accounts need to be updated.
    Highlight them red if they haven't been updated in more a month
    (configurable).
    Put the last updated date in the balance sheet or perhaps the trial balance
    page. Should be easy; we don't need a dedicated page for this.

  - Do we need a dedicated page for listing all documents? This page could
    include documents without a date, could be rendered as a tree-table, with
    the list of each document in the corresponding account. Maybe that's
    overkill. DK.

  - Shove more information in the Trial Balance page, info about errors, documents, etc.

** Multi-Year

  - A multi-year report is a global report.

** Source

  - The source page should take a special '?line=ddd' parameter that will
    scroll the page to the transaction at that line.

** Conversions

  - Render the Conversions amount at the bottom of the Conversions page...

* Import

  - Ameritrade dividends should have an associated stock name;
    right now we don't know which positions the dividends are associated with.
    (The input file doesn't appear to have it... call Ameritrade to let them know.)

  - Add an option to the importer so merge all the entries before printing them
    out. This would be useful if we have multiple files for the same account.

  - Add a check at the end of the OFX bank import. Missing right now.

  - There should be a script that is able to go through a directory of files
    and automaticalyl attempt to detect which types they are (if any), and
    invoke converters automatically. Other people should be able to add and
    improve this script.

  - Filing: The importers should detect the type of files and identify their
    accounts, and automatically stash the file under the correct documents
    directory, prepended with the date in the format we expect.

  - The OFX importer needs to unescape &amp; and other odd chars, I think
    there's a bug currently, I've seen a few here and there.

  - Add an option --file=delete, that offers to delete (with confirmation) all
    the files that it was able to identify.

** Filing

  - When grepping in PDF files, we should also grep to transaction-id's /
    beancount "links", in order to automatically associate trade ticket PDFs to
    transactions. Add a LINK to the document directive, in order to link them
    together. (^64647f10b2fd)

  - The code that auto-files statements needs to detect and de-dup files which
    have the same contents, because it is likely some files will be downloaded
    twice, it happens a lot.

** Payee Normalization

  - We will want to somehow "normalize" and merge payee names, because some of
    that differ very little are obvious for the same business... this would be
    useful. What kinds of tools will we need for that?

    Clean Import: The new importers should be able to strip the non-payee parts
    of the payee name, e.g. NEW YO, SAN FR, etc. Maybe we could let the user
    provide a filter function to sanitize the names of the payees, or maybe more
    generally just a filter on the entries before printing them out. This way
    you could provide your very own custom filter function that cleans up
    anything you don't like.

** GnuCash Import

  - Write an importer from GnuCash's format, for people wanting to make the
    transition or even just to try it out.

* Export
** HTML Export as File

  - Test "bean-bake" with the v2, it doesn't appear to work.

** Ledger

  - Export the compatible subset to Ledger format, so you can compare the reports.

** SQL Export

  - Write a script to load the data into an SQL database.


* Documentation
** Design Doc & Developer Info

  - INVARIANT: All the entries lists are assumed to be sorted by date
    everywhere.

  - INVARIANT: All Check and Open entries are always at the beginning of a new
    date in a list of entries.

** Documentation

  - Write a simple cheat-sheet with an overview of the syntax

  - Describe and document the data structures in a language-independent way,
    this is really important.  I have a really nice subset by now.

  - Include the nice diagram made for DGreenberg, we need a 3D version of it.

  - Write a series of real-life problems solved. This should be really much
    more helpful than boring docs.

  - Document the realization process, need that large zoom-out graphic that
    shows closing, and opening balances.

  - Add a "team project" as an example use case, or even an example file.

  - Look at GnuCash for some of the reports... some good ideas maybe? I could
    perhaps learn a few things, it looks informed.

  - Start documentation so you have a place to put all these ideas.
    Set it up using Sphinx, or something else.

** Real Usage Examples
*** Transfers Between Accounts
*** mortgage, buying a home
*** capital gains (note about how to do commissions)
*** cie expenses, the way I'm doing it.
*** misc, e.g. credit card
*** stock splits
*** Tracking IRA or RSP Contributions
**** Option 1

2012-10-15 * Contribution 1 to RSP
  Assets:Checking                           -2500 CAD
  Assets:Bank1:RSP                           2500 CAD
  Liabilities:PendingContributions          -2500 RSPCAD
  Expenses:RSPContrib                        2500 RSPCAD

2012-11-15 * Contribution 2 to RSP
  Assets:Checking                           -1500 CAD
  Assets:Bank1:RSP                           1500 CAD
  Liabilities:PendingContributions          -1500 RSPCAD
  Expenses:RSPContrib                        1500 RSPCAD

2013-04-30 * Filing Taxes
  Assets:Receivable                           800 CAD
  Expenses:Taxes                             -800 CAD
  Assets:RSPContrib                         -3500 RSPCAD  ; Not claiming all
  Liabilities:PendingContributions          +4000 RSPCAD
  Assets:RSPContrib:Unclaimed                 500 RSPCAD

2013-05-15 * Paying Taxes - Receiving Amount Due
  Assets:Checking                             800 CAD
  Assets:Receivable                          -800 CAD
  Assets:RSPContrib                          1200 RSPCAD
  Income:RSPContrib                         -1200 RSPCAD


Two RSP investment accounts:

  Assets:Bank1:RSP
  Assets:Bank1:RSP

An account to hold maximum RSP contributions allowed:

  Assets:RSPContrib

How much I've contributed to RSPs in total:

  Expenses:RSPContrib

How much my maximum contributions have increased from the governement as a
result of paying taxes:

  Income:RSPContrib

Pending contributions for this year, some of which to be claimed on my tax filing:

  Liabilities:PendingContributions

Unused RSP contributions made, carried forward to future years:

  Assets:RSPContrib:Unclaimed

**** Option 2 (favourite)

2012-10-15 * Contribution 1 to RSP
  Assets:Checking                           -2500 CAD
  Assets:Bank1:RSP                           2500 CAD
  Assets:RSPContrib:MaxDeductible           -2500 RSPCAD
  Assets:RSPContrib:Contributed              2500 RSPCAD

2012-11-15 * Contribution 2 to RSP
  Assets:Checking                           -1500 CAD
  Assets:Bank1:RSP                           1500 CAD
  Assets:RSPContrib:MaxDeductible           -1500 RSPCAD
  Assets:RSPContrib:Contributed              1500 RSPCAD

2013-04-30 * Filing Taxes
  Assets:Receivable                           800 CAD
  Expenses:Taxes                             -800 CAD
  Assets:RSPContrib:Contributed             -3500 RSPCAD  ; Not claiming all
  Expenses:RSPContrib                       +3500 RSPCAD

2013-05-15 * Paying Taxes - Receiving Amount Due
  Assets:Checking                             800 CAD
  Assets:Receivable                          -800 CAD
  Assets:RSPContrib:MaxDeductible            1200 RSPCAD
  Income:RSPContrib                         -1200 RSPCAD

Two RSP investment accounts:

  Assets:Bank1:RSP
  Assets:Bank1:RSP

An account to hold maximum RSP contributions allowed:

  Assets:RSPContrib:MaxDeductible

Pending unused contributions for this year, some of which to be claimed on my
tax filing:

  Assets:RSPContrib:Contributed

How much I've contributed to RSPs in total:

  Expenses:RSPContrib

How much my maximum contributions have increased from the governement as a
result of paying taxes:

  Income:RSPContrib



** User Documentation

  - Defining your accounts
    - Basic structures: *:Country:Institution:SubAccounts
    - "When and why to put accounts together under a single subaccount?"
      - When it makes sense to sum the total together.
        e.g. IRA employer contribution and your own contribution.

  - Checks
    - Checks work for subaccount balances too (add joint account example)

  - Document the fact that the conversions problem occurs

    * Because we don't reduce to a single "home" currency, and
    * That if you do all your work in a single currency with accounts with
      costs, the value will always be zero, and
    * Explain that currency trading accounts have little to do with this,
      because they are contained, and all in and out flows are in a single
      currency (the base currency of the account). The differences can be
      accounted like positions in financial assets, with corresponding PnLs.


  - Under "About Credits & Debits" - this is where you should write about how
    flows are relative to a boundary around the holder of the accounts.


*** Unrealized Gain

  - Unrealized capital gains could be inserted automatically into special
    sub-accounts, based on the current price and the cost-basis of particular
    accounts. This could be inserted automatically! e.g.

        DATE check Assets:US:Ameritrade:AAPL       10 AAPL {200 USD}

        DATE price AAPL  210 USD

      Assets:US:Ameritrade:AAPL                    2000 USD
      Assets:US:Ameritrade:AAPL:Gains               100 USD

    The "Gains" subaccount could be inserted automatically if the price differs
    from the cost basis... this would be a clever way to represent this! We
    could even do this by inserting a transaction automatically with an
    offsetting account... actually this would be the RIGHT way to do this!

      This could be done as a simple filter function:

        entries = add_unrealized(entries)

      We would need an option to designate which subaccount leaf to create all
      the new transactions for:

        %option account_unrealized  "Unrealized"

        2013-05-23 A "Booking unrealized gains for AAPL"
          Assets:US:Ameritrade:AAPL:Unrealized              230.45 USD
          Income:Unrealized                                -230.45 USD

      By doing this, the reporting does not have anything to do... it can choose
      to report positions at cost or in held units, and whether the gains are
      included or not entirely depends on whether these transactions have been
      inserted in or not.


** List of New features in Beancount v2 (Complete Rewrite) - Idealized

- Implemented in Python 3, from scratch.

- Internal data structures are more functional, immutable, allowing you to more
  easily create scripts that use the in-memory data. Overall, the new code is
  way simpler and much easier to understand because of this. It's actually
  become dead simple.

- New, simplified, and more consistent (and rigid) syntax will make it possible
  to add more features in the future, and to have parsers in other languages too
  (e.g. Go).

- Booking trades with capital gain tracking should now work.

- The new parser is written in C, so it is much much faster, and future changes
  will be easier

- The new web server fixes annoying rendering issues.

  * Balance sheet amounts can now reported in terms of book values.
  * Debit accounts can now be rendered with positive numbers (color-coded).
  * The internal data structure changes are much more general, and allow, for
    instance, creating a balance sheet at any point in time. In particular, you
    can have a balance sheet at the beginning and end of an exercise.

- Some internal design flaws were fixed, like checks on filtered ledgers showing
  up from incorrect periods.

- Various outputs to text, csv, and xls are now supported for easier sharing.

- The input file is monitored by the server, and can be automatically reloaded.
  This makes it easier to just start the web server, then edit the file to
  update what you need.

- There is no need to specify a filter period anymore; the interface is able to
  realize any required periods, and the GUI provides access to most common
  cross-sections (all, by year, by tag, by payee, transactions with bookings,
  etc.). You should be able to just specify the GUI.

- Client-side javascript has been added for a neater, more compact rendering of
  journals.

- There is a new library for code common to all importers; it should be easier
  to write importers now.

- There is a new module that allows you to automatically book new transactions
  on import, based on the previous contents of your ledger file.

- New scripts to extract a list of current positions at any time, and global
  summaries over many years or months.

- There is no more Emacs major mode, but only a minor mode; you may now use any
  text mode you like, most especially org-mode, which allows you to hide and
  show large sections of your file. This is really convenient or organize your
  input file in sections.  Less Emacs customization is better.

  * The account completer function is still there.
  * For org-mode, highlighting is still present.
  * There is a new function to align the prices of a transaction automatically.


** Examples

  - The examples should be drawn from the demo file; the demo file should be
    rewritten, with multiple years, and with good templates for most of the
    important operations that can take place.

* Presentation & Education

  - IDEA!!!  Use drawings a-la-ThinkBig or whatever it is. This will be the
    perfect medium for this. Mix it with video. Start writing a detailed script.

  - Begin with a USB key in hand. "On this 8 GB USB key, I have all of 8 years
    history of financial transactions in my life. Every single price paid that
    went recorded into an account it these.


* New Name

"Comptroller"
"Bottom Line"
"Messari"

"Summa" - already taken, printer tools
"Quaderno" - already taken, invoicing software
"Daycount" - already taken, many other accounting software

"Imprest system"
"Latency"
"Real, Personal and Nominal accounts"

  "Accounting is thousands of years old; the earliest accounting records, which
  date back more than 7,000 years, were found in Mesopotamia (Assyrians). The
  people of that time relied on primitive accounting methods to record the
  growth of crops and herds. Accounting evolved, improving over the years and
  advancing as business advanced.[5]"

  "The word "Accountant" is derived from the French word Compter, which took its origin from the Latin word Computare. "

The oldest discovered record of a complete double-entry system is the Messari (Italian: Treasurer's) accounts of the city of Genoa in 1340.

"In Summa Arithmetica, Pacioli introduced symbols for plus and minus for the first time in a printed book, symbols that became standard notation in Italian Renaissance mathematics. Summa Arithmetica was also the first known book printed in Italy to contain algebra.[26]"

Three major books of account are at the direct basis of this system: the memoriale (Italian: memorandum), the giornale (Journal), and the quaderno (ledger). The ledger is considered as the central one and is accompanied by an alphabetical index.[30]


* Challenges, Problems Beancount should be able to Solve
** Can I generate a nice year-on-year summary of income and expenses?

  - Including RSP contribs, like my bu spreadsheet that I crafted manually? Can
    I do that? That would be awesome!

** Maximum Balance

  - Can I compute the maximum value of each account at the end of every year
    (for foreign assets decl.) This would be useful for FBAR / FATCA
    declarations.

** Complete Return (IRR) on Condo

  - Challenge: Can I compute IRR return on my condo accurately?
    TODO: Add benefits received as an Income, as transactions.
    You should be able to compute the IRR of any Ledger!

** Taxation Rate

  - Challenge: Can I automatically compute my taxation rate for every year?

** List of Assets

  - Challenge: Can I obtain a list of my assets at any time?

** Make a report of currency exposure

  - For a particular balance sheet, report the total currency exposure of the
    ledger. This should be a very simple report, probably in the form of a pie
    chart.  Maybe this pie chart should be located in the capital report
    (possibly makes sense).

** Capital Gains

  - Capital gains should not count commissions nor on the buy nor on the
    sell side. How do we book them like this?  Can we count this somehow
    automatically? Misc accounts? Not sure.

** Inflation Adjusted Balance Sheets and Charts

  - It would be AWESOME to look at a balance sheets from the past but
    inflation-adjusted for any date... Answer this question easily:

      "What was I making in 2010 in today's dollar terms?"

  - How would I produce an inflation adjusted version of some charts. Maybe all
    charts should have that option?

** Statement of Assets (for Will)

  - In order to have someone else be able to take care of your business, you
    should be able to produce a list of the accounts open at the end of the
    period, with the account ids and balances. This should be printable and
    storable, for someone else to take care of your things in case you die.
