#!/usr/bin/env python3
"""Publish a CSV file to a Google Spreadsheet sheet.

This is a convenient script to update an existing Google Spreadsheet document
with the contents of a CSV file.

For example:

  upload-csv-to-google-sheet 19cwo....XFtgM apples.csv oranges.csv

By default, this updates (overwrites) the first two worksheets in the
spreadsheet with the contents of the given CSV files. If you want to update
another sheet or index, you can add them to the filenames, like this:

  upload-csv-to-google-sheet 19cwo....XFtgM apples.csv:MySheet oranges.csv:2

This would override the sheet "MySheet" with the contents of "apples.csv" and
the third sheet with the contents of "oranges.csv". Note that the sheets are
1-indexed, not 0-indexed.

You will need to have an installation of the following libraries for this to
work:

 * apiclient (Google Python client API)
 * oauth2client
 * httplib2

Moreover, you will need to enable the Google Sheets API in the developer console
and download the Client Secrets that Google provides to ~/.google-apis.json. (You
can override this location with the GOOGLE_APIS environment variable.)
"""
__author__ = 'Martin Blais <blais@furius.ca>'

import argparse
import bisect
import collections
import csv
import codecs
import logging
import os
import re
import string
import unittest
from os import path
from pprint import pprint as pp

from oauth2client import client
from oauth2client import tools
from oauth2client import file
import httplib2
from apiclient import discovery


SECRETS_FILENAME = os.environ.get('GOOGLE_APIS',
                                  path.expanduser('~/.google-apis.json'))
STORAGE_FILENAME = os.environ.get('GOOGLE_STORAGE',
                                  path.expanduser('~/.google-storage.json'))

def get_credentials(scopes, args):
    """Authenticate via oauth2 and cache credentials to a file.

    Args:
      scopes: A string or a list of strings, the scopes to get credentials for.
      args: An argparse option values object.
    Returns:
      An authenticated http client object.
    """
    flow = client.flow_from_clientsecrets(
        SECRETS_FILENAME,
        scope=scopes)
    storage = file.Storage(STORAGE_FILENAME)
    credentials = storage.get()
    if not credentials or credentials.invalid:
        credentials = tools.run_flow(flow, storage, args)
        storage.put(credentials)
    http = httplib2.Http()
    credentials.authorize(http)
    if credentials.access_token_expired:
        credentials.refresh(http)
    service = discovery.build(
        'sheets', 'v4',
        http=http,
        discoveryServiceUrl='https://sheets.googleapis.com/$discovery/rest?version=v4')
    return credentials, http, service


def csv_unicode_reader(source, **kwargs):
    """Temporarily encode unicode source to UTF8 because CSV does not support unicode.

    Args:
      source: An iterable sequence of unicode objects.
      **kwargs: Arguments for csv.reader().
    Yields:
      Rows of unicode objects.
    """
    lineiter = (line.encode('utf-8') for line in source)
    csv_reader = csv.reader(lineiter, **kwargs)
    for row in csv_reader:
        yield [cell.decode('utf-8') for cell in row]


# The name of a sheet left as the unique sheet temporarily, while creating a new
# spreadsheet.
EMPTY_SHEET_TITLE = '__EMPTY__'


def create_doc(service):
    """Create a new spreadsheet with an empty initial sheet.

    The empty initial sheet gets deleted later. We cannot create a new
    spreadsheet without at least a single sheet in it.
    """
    resp = service.spreadsheets().create(body={
        'sheets': {'properties': {'title': EMPTY_SHEET_TITLE}}}).execute()
    return resp['spreadsheetId']


def delete_empty_sheets(service, docid):
    """Remove empty sheets created only temporarily."""
    requests = [{'deleteSheet': {'sheetId': sheetId}}
                for title, sheetId in get_sheets(service, docid)
                if title == EMPTY_SHEET_TITLE]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def get_sheets(service, docid):
    """Get the sheet titles and ids of the given spreadsheet."""
    resp = service.spreadsheets().get(spreadsheetId=docid).execute()
    return [(sheet['properties']['title'], sheet['properties']['sheetId'])
            for sheet in resp['sheets']]


def add_sheet(service, docid, title):
    """Create a new sheet and return the sheet id."""
    requests = [{'addSheet': {'properties': {'title': title}}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()
    return resp['replies'][0]['addSheet']['properties']['sheetId']


def get_sheet_size(service, docid, title):
    """Get the size of a spreadsheet."""
    resp = service.spreadsheets().get(spreadsheetId=docid,
                                      ranges=title).execute()
    gridProperties = resp['sheets'][0]['properties']['gridProperties']
    return (gridProperties['rowCount'], gridProperties['columnCount'])


def clear_sheet(service, docid, title, nrowcols=None):
    """Clear the sheet."""
    if nrowcols is None:
        nrows, ncols = get_sheet_size(service, docid, title)
    else:
        nrows, ncols = nrowcols
    range = sheet_range(title, nrows, ncols)
    # Q: Why is an empty body required here?
    resp = service.spreadsheets().values().clear(spreadsheetId=docid,
                                                 range=range,
                                                 body={}).execute()


def resize_sheet(service, docid, sheetId, title, nrows, ncols):
    """Update the size of a sheet."""
    # Q: Why are both the sheetId and the title required here?
    requests = [{
        'updateSheetProperties': {
            'properties': {
                'sheetId': sheetId,
                'title': title,  # Required, unfortunately.
                'gridProperties': {'rowCount': nrows,
                                   'columnCount': ncols}},
            'fields': '*'}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def auto_resize_sheet(service, docid, sheetId):
    """Auto-resize the spreadsheet based on the current data in it."""
    requests = [{
        'autoResizeDimensions': {
            'dimensions': {
                'sheetId': sheetId,
                'dimension': 'COLUMNS'}}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def update_sheet(service, docid, sheetId, title, filename):
    """Clear and replace the data in a sheet with that of a file."""

    # Load the CSV file into an array of rows.
    with open(filename, 'r') as csvfile:
        reader = csv.reader(csvfile)
        rows = list(reader)
        #for irow, row in enumerate(csv_unicode_reader(csvfile), 1):


    nrows = len(rows)
    ncols = max(len(row) for row in rows) if rows else 0

    # Note: Sizing down the sheet also deletes the values from the cells removed
    # automatically.

    resize_sheet(service, docid, sheetId, title, nrows, ncols)
    clear_sheet(service, docid, title, (nrows, ncols))

    # Upload the new values.
    range = sheet_range(title, nrows, ncols)
    resp = service.spreadsheets().values().update(
        spreadsheetId=docid,
        range=range,
        valueInputOption='USER_ENTERED',
        body={'range': range,
              'values': rows}).execute()

    auto_resize_sheet(service, docid, sheetId)

    # FIXME: TODO - is updateCells request in order to be able to set not only
    # the values, but also the formatting of numbers. Don't use USER_ENTERED in
    # this way.


def sheet_range(title, nrows, ncols):
    return '{}!A1:{}{}'.format(title, string.ascii_uppercase[ncols-1], nrows)



def pop_alist(items, key, default=None):
    "Remove the first found element in a multi-association list."
    for index, item in enumerate(items):
        if item[0] == key:
            del items[index]
            return item
    return default


def main():
    logging.basicConfig(level=logging.INFO, format='%(levelname)-8s: %(message)s')

    parser = argparse.ArgumentParser(description=__doc__.strip(),
                                     parents=[tools.argparser])

    parser.add_argument('filenames', nargs='+', action='store',
                        help=("CSV filenames[:name] to upload. "
                              "If 'name' is not provided, infer from the filename."))

    parser.add_argument('--docid', '--id', '-d', dest='docid', action='store',
                        help="Spreadsheets doc id to update")

    args = parser.parse_args()
    _, __, service = get_credentials('https://www.googleapis.com/auth/spreadsheets', args)

    # Figure out what the name mappings should be, from the filenames (or
    # explicitly).
    new_sheets = []
    for filename in args.filenames:
        match = re.match('(.*):(.*)$', filename)
        if match:
            filename, sheet_name = (match.group(1), match.group(2))
        else:
            sheet_name = path.splitext(path.basename(filename))[0]
        new_sheets.append((sheet_name, filename))
    ##pp(new_sheets)

    # Get or create the spreadsheet.
    if args.docid:
        created = False
        docid = args.docid
    else:
        created = True
        docid = create_doc(service)
        logging.info("Created doc: https://docs.google.com/spreadsheets/d/%s/", docid)

    # Get the existings sheets within (this also validates the existence of the
    # document).
    existing_sheets = get_sheets(service, docid)
    ##pp(existing_sheets)

    # Create new or match against existing sheets if necessary. This essentially
    # pairs up spreadsheets from the input to sheet-ids in the doc.
    sheets_alist = []
    for title, filename in new_sheets:
        esheet = pop_alist(existing_sheets, title)
        if esheet is None:
            sheetId = add_sheet(service, docid, title)
        else:
            _, sheetId = esheet
        sheets_alist.append((sheetId, title, filename))
    pp(sheets_alist)

    # Clear and replace the data in the given sheet with that of the given
    # filename.
    for sheetId, title, filename in sheets_alist:
        update_sheet(service, docid, sheetId, title, filename)

    # Clean up temporary sheets created for new documents only.
    if created:
        delete_empty_sheets(service, docid)


if __name__ == '__main__':
    main()


# Q: The API is inconsistent -- sometimes the sheetId is used, sometimes the
# title, and sometimes both are required. This needs to be fixed.

# Q: Why is there UpdateCellsRequest is there is the spreadsheets.values() API?


    # rangeName = 'Class Data!A2:E'
    # result = service.spreadsheets().values().get(
    #     spreadsheetId=spreadsheetId, range=rangeName).execute()
    # values = result.get('values', [])

    # logging.info("Resolving indexes for each of the input files.")
    # filenames, names = enumerate_arguments(args.filenames, args.use_filenames)

    # wslist = find_or_create_worksheets(gd_client, docid, names)

    # logging.info("Processing each worksheet.")
    # for ws, filename in zip(wslist, filenames):
    #     title = ws.title.text

    #     logging.info("[%-32.32s] Loading CSV data and creating batch update.", title)
    #     batch = sheets_data.build_batch_cells_update(docid, ws.get_worksheet_id())
    #     nrows, ncols = csv_to_batch_update(filename, batch)

    #     if nrows == 0:
    #         logging.warn("[%-32.32s] No data, empty file. Skipping.", title)
    #         continue

    #     logging.info("[%-32.32s] Resizing and clearing.", title)
    #     ws.row_count.text = str(nrows)
    #     ws.col_count.text = str(ncols)
    #     gd_client.update(ws)

    #     logging.info("[%-32.32s] Uploading data to spreadsheet.", title)
    #     gd_client.batch(batch, force=True)

    # logging.info("Done.")
