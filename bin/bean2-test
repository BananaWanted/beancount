#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict

import beancount2.parser
from beancount2.parser import *
from beancount2.inventory import Inventory


#-------------------------------------------------------------------------------

def get_account_type(account):
    return account.name.split(':')[0]

def is_balance_sheet_account(account):
    return get_account_type(account) in ('Assets', 'Liabilities', 'Equity')


@contextlib.contextmanager
def print_time(operation):
    t1 = time.time()
    yield
    t2 = time.time()
    print(">>>>> Operation: '{}'  Time: {:.0f}ms".format(operation, (t2 - t1)*1000))


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)


def filter_type(elist, types):
    """Filter the given list to yield only instances of the given types."""
    for element in elist:
        if not isinstance(element, types):
            continue
        yield element


#-------------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    if opts.dump_lexer:
        beancount2.parser.lexer_dump(opts.filename, sys.stdout)
        return

    with print_time('parse'):
        ledger = beancount2.parser.parse(opts.filename)
    
    with print_time('realize'):
        accounts_map = test_realize(ledger.entries)

    if 1:
        # list(map(print, ledger.accounts.get_names()))
        ledger.accounts.dump(sys.stdout)


        # account = ledger.accounts.get('Assets:CA:RBC-Investing:RRSP:AIS512')
        # print(account.name)
        # print(account.parent.name)
        # print(account.parent.parent.name)
        # print(account.parent.parent.parent.parent.parent.name)
        


    # Print all the balances
    if 0:
        maxlen = max(map(len, accounts_map))
        for account, inventory in sorted(accounts_map.items()):
            print("{:{:d}s} {}".format(account, maxlen, inventory))

    # for txn in filter_type(ledger.entries, Transaction):
    #     if not re.search('GOOGLE INC', txn.description):
    #         continue
    #     print('-' * 80)
    #     print(pretty_transaction(txn))
    #     residual = compute_residual(txn.postings)
    #     print(residual)

    if opts.verbose:
        for txn in ledger.entries:
            print(pretty_transaction(txn))

    # print_tags(ledger.entries)


def test_realize(entries):
    accounts_map = defaultdict(Inventory)
    for entry in entries:
        if not isinstance(entry, Transaction):
            continue

        # print('------------------------', entry)
        for posting in entry.postings:
            inventory = accounts_map[posting.account.name]
            inventory.add_position(posting.position)
    return accounts_map



def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)



if __name__ == '__main__':
    main()
