#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict

import beancount2.parser
from beancount2.parser import *
from beancount2.inventory import Inventory


#-------------------------------------------------------------------------------

def is_balance_sheet_account(account):
    return account.type in ('Assets', 'Liabilities', 'Equity')

def is_income_statement_account(account):
    return account.type in ('Income', 'Expenses')


@contextlib.contextmanager
def print_time(operation):
    t1 = time.time()
    yield
    t2 = time.time()
    print(">>>>> Operation: '{}'  Time: {:.0f}ms".format(operation, (t2 - t1)*1000))


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)


def filter_type(elist, types):
    """Filter the given list to yield only instances of the given types."""
    for element in elist:
        if not isinstance(element, types):
            continue
        yield element


#-------------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    if opts.dump_lexer:
        beancount2.parser.lexer_dump(opts.filename, sys.stdout)
        return

    with print_time('parse'):
        entries = beancount2.parser.parse(opts.filename)

    with print_time('realize'):
        accounts_map = test_realize(entries)

    find_unique_templates(entries)


    if 0:
        # list(map(print, ledger.accounts.get_names()))
        ledger.accounts.dump(sys.stdout)


        # account = ledger.accounts.get('Assets:CA:RBC-Investing:RRSP:AIS512')
        # print(account.name)
        # print(account.parent.name)
        # print(account.parent.parent.name)
        # print(account.parent.parent.parent.parent.parent.name)



    # Print all the balances
    if 0:
        maxlen = max(map(len, accounts_map))
        for account, inventory in sorted(accounts_map.items()):
            print("{:{:d}s} {}".format(account, maxlen, inventory))

    # for txn in filter_type(ledger.entries, Transaction):
    #     if not re.search('GOOGLE INC', txn.description):
    #         continue
    #     print('-' * 80)
    #     print(pretty_transaction(txn))
    #     residual = compute_residual(txn.postings)
    #     print(residual)

    if opts.verbose:
        for txn in ledger.entries:
            print(pretty_transaction(txn))

    # print_tags(ledger.entries)



def test_realize(entries):
    accounts_map = defaultdict(Inventory)
    for entry in entries:
        if not isinstance(entry, Transaction):
            continue

        # print('------------------------', entry)
        for posting in entry.postings:
            inventory = accounts_map[posting.account.name]
            inventory.add_position(posting.position)
    return accounts_map



def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)


def unique_alias(account):
    if (account.type == 'Expenses' and
        not re.search(':Taxes:', account.name)):
        return 'Expenses:*'
    else:
        return account.name


def account_sortkey(account):
    """Sort a list of accounts, taking into account the type of account.
    Assets, Liabilities, Equity, Income and Expenses, in this order, then
    in the order of the account's name."""
    return (ACCOUNTS_ORDERING[account.type], account.name)

def account_names_sortkey(account_name):
    """Sort a list of accounts, taking into account the type of account.
    Assets, Liabilities, Equity, Income and Expenses, in this order, then
    in the order of the account's name."""
    account_type = account_name.split(':')[0]
    return (ACCOUNTS_ORDERING[account_type], account_name)

ACCOUNTS_ORDERING = dict((x,i) for (i,x) in enumerate('Assets Liabilities Equity Income Expenses'.split()))



def find_unique_templates(entries):
    """Filter out transactions and group them by types of accounts transacted."""

    groups = defaultdict(list)
    for entry in filter_type(entries, Transaction):
        account_names = frozenset(sorted(unique_alias(posting.account)
                                         for posting in entry.postings))
        groups[account_names].append(entry)

    print(len(groups))

    for account_names, entry_list in sorted(groups.items(), key=lambda x: len(x[1]), reverse=True):
        print(tuple(sorted(account_names, key=account_names_sortkey)), len(entry_list))




if __name__ == '__main__':
    main()
