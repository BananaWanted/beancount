#!/usr/bin/env python3
"""Read a beancount input file and a directory name, and attempt to identify and
convert the files in the directory. There is also an option to automatically
file succesfully detected and converted input files.
"""
import io
import itertools
import os
import re
import datetime
from os import path
import mimetypes
import logging
import subprocess
from pprint import pprint
from xml.etree import ElementTree
import bs4
import collections

from beancount2.parser import load
from beancount2.core import data
from beancount2.core.data import Account, Posting, Transaction, Check, Decimal, Lot, Amount
from beancount2.core.inventory import Position






#
# Generic utility.
#

def walk_files(directories, ignore_dirs=['.hg', '.svn', '.git']):
    """Enumerate the files under the given directories."""
    for directory in directories:
        for root, dirs, filenames in os.walk(directory):
            dirs[:] = [dirname for dirname in dirs if dirname not in ignore_dirs]
            for filename in filenames:
                yield path.join(root, filename)






#
# Getting the file types.
#

EXTRA_FILE_TYPES = [
    (re.compile(regexp, re.I), filetype)
    for regexp, filetype in (
            (r'.*\.qbo$', 'application/vnd.intu.qbo'),
            (r'.*\.(qfx|ofx)$', 'application/x-ofx'),
    )]

try:
    import magic
except ImportError:
    magic = None

def guess_file_type(filename):
    """Attempt to guess the type of the input file.
    Return a suitable mimetype, or None if we don't know."""

    # Try the regular mimetypes association.
    filetype, _ = mimetypes.guess_type(filename, False)

    if filetype is None:
        # Try out some extra ones that we know about.
        for regexp, mimtype in EXTRA_FILE_TYPES:
            if regexp.match(filename):
                filetype = mimtype
                break

    # FIXME: Add python-magic, optionally (if imported).
    if filetype is None:
        if not magic:
            pass # FIXME: issue a warning
        else:
            # Okay, we couldn't figure it out from the filename; use libmagic
            # (if installed).
            bfiletype = magic.from_file(filename, mime=True)
            filetype = bfiletype.decode()

    return filetype






#
# Identification of files to specific accounts.
#


def sliced_match(string):
    """Return a regexp that will match the given string with possibly any number of
    spaces in between. For example, '123' would become '1 *2 * 3'."""
    return '[ -]*'.join(string)


def identify_string(text, account_ids):
    """Given some string 'text', find if any of the account-ids in the 'account_ids'
    map is present in the text and return the corresponding account, or None."""

    for account_id, account in account_ids.items():
        mo = re.search(sliced_match(account_id), text)
        if mo:
            return account_id, account


def identify_pdf(filename, account_ids):
    "Attempt to identify the account for the given PDF file."""

    p = subprocess.Popen(('pdftotext', filename, '-'),
                         shell=False,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    if p.returncode != 0 or stderr:
        logging.error("Error running pdftotext: {}".format(stderr))
        return

    text = stdout.decode()
    return identify_string(text, account_ids)


def identify_csv(filename, account_ids):
    "Attempt to identify the account for the given CSV file."""

    text = open(filename).read()
    return identify_string(text, account_ids)


def ofx_get_account(node):
    "Given a beautifulsoup node, get the corresponding account id."
    acctid = node.find('acctid')
    # There's some garbage in here sometimes; clean it up.
    return acctid.text.split('\n')[0]


def identify_ofx(filename, account_ids):
    "Attempt to identify the account for the given OFX file."""

    soup = bs4.BeautifulSoup(open(filename), 'lxml')
    acctid = ofx_get_account(soup)
    try:
        return (acctid, account_ids[acctid])
    except KeyError:
        return None


IDENTIFY_HANDLERS = {
    'application/pdf'          : identify_pdf,
    'text/csv'                 : identify_csv,
    'application/x-ofx'        : identify_ofx,
    'application/vnd.intu.qbo' : identify_ofx,
}


def identify_account(filename, entries):
    """Given a filename, return the filetype and account that this file corresponds
    to, or None if it could not be identified."""

    filetype = guess_file_type(filename)

    identify_fun = IDENTIFY_HANDLERS.get(filetype, None)
    if identify_fun is None:
        # No handler was found; bail out.
        return

    account_ids = data.get_account_ids(entries)
    account_id, account = identify_fun(filename, account_ids)

    return filetype, account













#
# OFX Parser.
#


UNKNOWN_ACCOUNT = Account('Assets:?', 'Assets')


def souptodict(node):
    """Convert all of the child nodes from BeautifulSoup node into a dict.
    This assumes the direct children are uniquely named, but this is often the
    case."""
    return {child.name: child.contents[0].strip()
            for child in node.contents
            if isinstance(child, bs4.element.Tag)}

def soup_get(node, name, conversion=None):
    "Find a child anywhere below node and return its value or None."
    child = node.find(name)
    if child:
        value = child.contents[0]
        if conversion:
            value = conversion(value)
        return value


def parse_ofx_time(ofx_date_str):
    "Parse an OFX time string and return a datetime object.."
    if len(ofx_date_str) < 14:
        return datetime.datetime.strptime(ofx_date_str[:8], '%Y%m%d')
    else:
        return datetime.datetime.strptime(ofx_date_str[:14], '%Y%m%d%H%M%S')


def get_securities(soup):
    """Extract the list of securities from the OFX file."""

    seclistmsgsrsv = soup.find('seclistmsgsrsv1')
    if not seclistmsgsrsv:
        return

    securities = []
    for secinfo in seclistmsgsrsv.find_all('secinfo'):
        # Merge the two nodes in a dictionary.
        secid = souptodict(secinfo.find('secid'))
        secname = souptodict(secinfo.find('secname'))
        secid.update(secname)
        securities.append(secid)

    return securities


def import_ofx(filename, entries):
    """Extract transaction info from the given OFX file into transactions for the
    given account. This function returns a list of entries possibly partially
    filled entries, and a dictionary of annotations to be attached to entries
    and postings.
    """
    account_ids = data.get_account_ids(entries)

    entries = []
    annotations = {}

    # Parse the XML file.
    soup = bs4.BeautifulSoup(open(filename), 'lxml')

    # Get the description of securities used in this file.
    securities = get_securities(soup)
    securities_map = {security['uniqueid']: security
                      for security in securities}

    # For each statement.
    txn_counter = itertools.count()
    for stmtrs in soup.find_all(re.compile('.*stmtrs$')):
        # account_type = st.find('accttype').text.strip()
        # bank_id = st.find('bankid').text.strip()

        # For each currnecy.
        for currency_node in stmtrs.find_all('curdef'):
            currency = currency_node.contents[0].strip()

            # Extract account-wide information.
            acctid = ofx_get_account(stmtrs)

            # Attempt to get an account from the ledger entries.
            account_name = account_ids.get(acctid).name
            if account_name is None:
                account_name = UNKNOWN_ACCOUNT.name

            # Process all regular or credit-card transaction lists.
            for tranlist in stmtrs.find_all(re.compile('(|cc)tranlist')):
                ## print(tranlist.prettify())

                # Process the transactions from that list.
                for stmttrn in tranlist.find_all('stmttrn'):
                    trndict = souptodict(stmttrn)

                    # Build the transaction.
                    # date_start = parse_ofx_time(trndict['dtstart']).date()
                    # date_end = parse_ofx_time(trndict['dtend']).date()
                    date = parse_ofx_time(trndict['dtposted']).date()
                    fileloc = data.FileLocation(filename, next(txn_counter))
                    flag = data.FLAG_WARNING
                    payee = None
                    narration = ' / '.join(filter(None, (trndict.get(x, None) for x in ('trntype', 'name', 'memo'))))
                    entry = Transaction(fileloc, date, flag, payee, narration, set(), [])

                    # Create a posting for it.
                    position = Position(Lot(currency, None, None), Decimal(trndict['trnamt']))
                    price = None # FIXME: Does it sometime make sense?
                    flag = None
                    account = data.account_from_name(account_name)
                    entry.postings.append(Posting(entry, account, position, price, flag))

                    entries.append(entry)


#FIXME: Farm this out to a Vanguard-specific function.

            # Process all investment transaction lists.
            # Note: this was developed for Vanguard.
            for invtranlist in stmtrs.find_all(re.compile('invtranlist')):

                for tran in invtranlist.find_all(re.compile('(buymf|sellmf|reinvest|buystock|sellstock|buyopt|sellopt|transfer)')):

                    date = parse_ofx_time(soup_get(tran, 'dttrade')).date()
                    # date = parse_ofx_time(trndict['dtsettle']).date()

                    uniqueid = soup_get(tran, 'uniqueid')
                    security = securities_map[uniqueid]['ticker']

                    units = soup_get(tran, 'units', Decimal)
                    unitprice = soup_get(tran, 'unitprice', Decimal)
                    total = soup_get(tran, 'total', Decimal)

                    fileloc = data.FileLocation(filename, next(txn_counter))
                    flag = data.FLAG_WARNING
                    payee = None

                    trantype = tran.name.upper()
                    incometype = soup_get(tran, 'incometype')
                    source = soup_get(tran, 'inv401ksource')
                    narration = ' - '.join(filter(None, (trantype, incometype, source)))

                    entry = Transaction(fileloc, date, flag, payee, narration, set(), [])

                    # Create a posting for it.
                    position = Position(Lot(security, Amount(unitprice, currency), None), units)
                    price = None # FIXME: Does it sometime make sense?
                    flag = None
                    account = data.account_from_name('{}:{}'.format(account_name, security))
                    entry.postings.append(Posting(entry, account, position, price, flag))

                    if total is not None:
                        position = Position(Lot(currency, None, None), -total)
                        account = data.account_from_name(account_name)
                        entry.postings.append(Posting(entry, account, position, None, None))

                    entries.append(entry)

                # Process all positions, convert them to Check directives.
                # Note: this was developed for Vanguard.
                for invposlist in stmtrs.find_all('invposlist'):
                    for invpos in invposlist.find_all('invpos'):
                        date = parse_ofx_time(soup_get(invpos, 'dtpriceasof')).date()

                        uniqueid = soup_get(invpos, 'uniqueid')
                        security = securities_map[uniqueid]['ticker']

                        units = soup_get(invpos, 'units', Decimal)
                        unitprice = soup_get(invpos, 'unitprice', Decimal)

                        fileloc = data.FileLocation(filename, next(txn_counter))
                        account = data.account_from_name('{}:{}'.format(account_name, security))

                        amount = Amount(units, security)
                        entries.append(Check(fileloc, date, account, amount, None))

    entries.sort()
    return entries, annotations








#
# Importers.
#

IMPORTER_HANDLERS = {
    # 'text/csv'                 : identify_csv,
    'application/x-ofx'        : import_ofx,
    'application/vnd.intu.qbo' : import_ofx,
}








#
# Conversion to text.
#


class EntryPrinter:
    "Multi-method for printing an entry."

    @classmethod
    def __call__(cls, obj):
        oss = io.StringIO()
        getattr(cls, obj.__class__.__name__)(cls, obj, oss)
        return oss.getvalue()

    def Transaction(_, entry, oss):
        # Compute the string for the payee and narration line.
        strings = []
        if entry.payee:
            strings.append('"{}" |'.format(entry.payee))
            format_string(entry.payee)
        if entry.narration:
            strings.append('"{}"'.format(entry.narration))

        oss.write('{e.date} {e.flag} {}\n'.format(' '.join(strings), e=entry))

        for posting in entry.postings:
            flag = '{} '.format(posting.flag) if posting.flag else ''
            assert posting.account is not None
            assert posting.position is not None
            oss.write('  {}{:64} {} {}\n'.format(flag, posting.account.name, posting.position, posting.price or ''))

    def Check(_, entry, oss):
        oss.write('{e.date} check {e.account.name} {e.position}\n'.format(e=entry))

    def Pad(_, entry, oss):   raise NotImplementedError
    def Open(_, entry, oss):  raise NotImplementedError
    def Close(_, entry, oss): raise NotImplementedError
    def Note(_, entry, oss):  raise NotImplementedError
    def Event(_, entry, oss): raise NotImplementedError
    def Price(_, entry, oss): raise NotImplementedError


def format_string(string):
    return '"%s"' % string if string is not None else ''


def format_entry(entry):
    return EntryPrinter()(entry)

















# Handler:
# - rename with import date
# - import transactions

#   - Write some code to detect when a transaction is already there
#   - Write some code to convert from entries into text

def main():
    import argparse, logging
    logging.basicConfig(level=logging.INFO, format='%(levelname)-8s: %(message)s')
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename', help='Beancount input file')
    parser.add_argument('directories', nargs='+', help='Directories to inspect')

    opts = parser.parse_args()

    entries, errors, options = load(opts.filename)

    for filename in walk_files(opts.directories):
        print(',--------------------------------------------------------------------------------')
        print(filename)
        print()
        identification = identify_account(filename, entries)
        if not identification:
            continue # Skip file.
        filetype, account = identification

        importer = IMPORTER_HANDLERS.get(filetype)
        if importer is None:
            continue # No importer available for this filetype.

        new_entries, annotations = importer(filename, entries)

        for entry in new_entries:
            print(format_entry(entry))


## FIXME: What do we do when there are mutiple accounts?













if __name__ == '__main__':
    main()
