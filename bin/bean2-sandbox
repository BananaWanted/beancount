#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import datetime
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict, namedtuple

import pandas
import matplotlib; matplotlib.use('agg')
from matplotlib import pyplot

import beancount2.parser
from beancount2.utils.bisect_key import bisect_left_withkey
from beancount2 import validation
from beancount2 import utils
from beancount2 import data
from beancount2 import realization
from beancount2.parser import *
from beancount2.inventory import Inventory
from beancount2.data import render_fileloc


#-------------------------------------------------------------------------------


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)


#-------------------------------------------------------------------------------


def find_balance(real_account, date=None):
    """Find the balance right before the given date.
    If date is None, get the total balance of the entire account."""

    postings = real_account.postings
    if date is None:
        # Find the last posting that had a non-null balance.
        index = len(postings) - 1
    else:
        index = bisect_left_withkey(postings, date,
                                    key=lambda real_posting: real_posting.entry.date)
    if index == 0:
        return 0, Inventory()
    else:
        # Take the balance of the previous element, the last one on previous
        # dates.
        index -= 1

        # Find the last posting that had a non-null balance.
        for i in range(index, -1, -1):
            real_posting = postings[i]
            if isinstance(real_posting, realization.RealPosting):
                return (index+1), real_posting.balance
        else:
            return 0, Inventory()


# A generic tuple to return various data by account type.
AccountTypeData = namedtuple('AccountTypeData', 'Assets Liabilities Equity Income Expenses')


def compute_balance_by_type(real_accounts, date):
    """Compute the total balance for each account type, evaluated at the given
    date. Returns a tuple with an inventor for each accoutn type."""

    balances = {typename: Inventory()
                for typename in AccountTypeData._fields}
    for real_account in real_accounts.values():
        if real_account.postings:
            typename = data.account_type(real_account.name)
            _, balance = find_balance(real_account, date)
            balances[typename] += balance

    return AccountTypeData(**balances)


def compute_yearly_balances(real_accounts):
    """Given a realization, compute the yearly balances of each account type."""

    data = {}
    for balance_date in (datetime.date(year, 1, 1) for year in range(2004, 2015)):
        balances = compute_balance_by_type(real_accounts, balance_date)
        rows = []
        for account_type, balance in balances._asdict().items():
            costs = balance.get_cost().get_amounts()
            index = [cost.currency for cost in costs]
            series = pandas.Series([cost.number for cost in costs], index=index)
            rows.append(series)
        date_data = pandas.DataFrame(rows, index=AccountTypeData._fields)
        data[balance_date] = date_data

    return pandas.Panel.from_dict(data)


def check_equity_balances(real_accounts):
    """Try to figure out which method is best to summarize income/expenses into equity.
    Comparing (I+X) with (A+L), they really should be equal."""

    for balance_date in (datetime.date(year, 1, 1) for year in range(2004, 2015)):
        print('------------------------', balance_date)
        balances = compute_balance_by_type(real_accounts, balance_date)

        balsheet_inventory = balances.Assets + balances.Liabilities + balances.Equity
        income_inventory = balances.Income + balances.Expenses

        print('Balance Sheet: {}'.format(balsheet_inventory))
        print('Income:        {}'.format(income_inventory))

        # We need to synthesize a transaction here instead of doing this.
        conversions = -(balsheet_inventory + income_inventory)
        print('Conversions:   {}'.format(conversions.get_cost()))
        balsheet_inventory += conversions.get_cost()

        assert (balsheet_inventory + income_inventory).get_cost().is_empty()
        print((balsheet_inventory + income_inventory))
        print((balsheet_inventory + income_inventory).get_cost())
        print()

        balances_fwd = compute_balance_by_type(real_accounts, balance_date + datetime.timedelta(days=365))
        print(balances_fwd)
        conversions_fwd = -(balances_fwd.Assets +
                            balances_fwd.Liabilities +
                            balances_fwd.Equity +
                            balances_fwd.Income +
                            balances_fwd.Expenses)
        print('conversions_fwd', conversions_fwd)
        print('conversions_diff', conversions.get_cost() + (-conversions_fwd).get_cost())


def summarize(real_accounts, date, opening_acount):
    """Summarize all the accounts before date.

    This function replaces the transactions up to (and not including) the given
    date with a single opening balance transaction, for each account. Return a
    new list of realized accounts.

    Note: This routine must operate on a realization (as opposed to on the
    entries) because the padding entries inserted by the realization will need
    to be included in the summarization as well.
    """
    new_accounts = RealAccountTree()

    for real_account in real_accounts.values():
        if real_account.postings:
            index, balance = find_balance(real_account, date)
            new_account = new_accounts.get_create(real_account.name)

            # Insert an opening balance entry.
            fileloc = FileLocation('<summary>', 0)
            # entry = Transaction(
            ## FIXME:HERE: fix the realization first. It's possible we have to operate on the list of entries. Not sure yet.

            # Copy the list of postings after the index found.
            new_account.extend(real_account.postings[index:])

    return new_accounts







# a. summarize
# b. annul_income
# c. conversion adjustment

    # 3. Insert a conversion error entry.





#-------------------------------------------------------------------------------

def print_entries_by_date(entries):
    prev_date = None
    for entry in entries:
        if prev_date != entry.date:
            print()
            prev_date = entry.date
        print(entry)

def print_errors(errors):
    # Report all the realization errors.
    for error in errors:
        print('{} {}'.format(render_fileloc(error.fileloc), error.message))


def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    with utils.print_time('parse'):
        contents = beancount2.parser.parse(opts.filename)
        # print_entries_by_date(contents.entries)

    with utils.print_time('check'):
        check_errors = validation.check(contents.entries, contents.accounts)
        print_errors(check_errors)

    with utils.print_time('pad'):
        padded_entries, pad_errors = realization.pad(contents.entries)
        print_errors(pad_errors)

    for entry in utils.filter_type(padded_entries, data.Transaction):
        if entry.flag == 'P':
            print(entry)


    raise SystemExit

    with utils.print_time('realize'):
        real_accounts, real_errors = realization.realize(contents.entries, check=True)

    # For timing only.
    with utils.print_time('balance_all'): # 89ms... okay.
        balance = Inventory()
        for entry in utils.filter_type(contents.entries, data.Transaction):
            for posting in entry.postings:
                balance.add_position(posting.position)


    for real_account in sorted(real_accounts.values()):
        print('{:56} {}'.format(real_account.name, real_account.account))

    raise SystemExit

    # real_account = real_accounts['Assets:CA:RBC-Investing:RRSP']

    if 0:
        print('--------------------------------------------------------------------------------')
        for real_posting in real_account.postings:
            balance = getattr(real_posting, 'balance', None)
            if balance:
                print(real_posting.entry.date, balance)
        print('--------------------------------------------------------------------------------')

    # Report all the realization errors.
    for error in real_errors:
        print('{} {}'.format(render_fileloc(error.fileloc),
                             error.message))

    ##realization.dump_tree_balances(real_accounts, sys.stdout)

    if 1:
        check_equity_balances(real_accounts)

    if 0:
        yearly = compute_yearly_balances(real_accounts)

        print(yearly.to_frame().to_string())
        # print(yearly.major_xs('Assets').to_string())
        USD = yearly.minor_xs('USD')
        CAD = yearly.minor_xs('CAD')
        total = USD + CAD
        print(total.to_string())
        # print(yearly.minor_xs('CAD').to_string())

        sums = total.sum(axis=0)
        print(sums.to_string())
        total.plot()
        pyplot.show()




    if 0:
        # Sum up all the amounts for the trial balance.
        total_balance = Inventory()
        for account_type in ('Assets', 'Liabilities', 'Equity', 'Income', 'Expense'):
            trial_balance = Inventory()
            for real_account in real_accounts.values():
                if not real_account.name.startswith(account_type):
                    continue

                for real_posting in reversed(real_account.postings):
                    if isinstance(real_posting, realization.RealPosting):
                        break
                else:
                    continue
                # print('{:64} {}'.format(real_account.name, real_posting.balance))
                trial_balance += real_posting.balance

            print(account_type)
            print(sorted(trial_balance.get_cost().get_amounts(), key=data.amount_sortkey))
            print()

            total_balance += trial_balance

        print('TOTAL')
        print(sorted(total_balance.get_cost().get_amounts(), key=data.amount_sortkey))
        print()

    if 0:
        real_account = real_accounts['Assets:Cash']
        for real_posting in real_account.postings:
            print('{} {:48} {:72} {:72}'.format(real_posting.entry.date,
                                          ' | '.join([real_posting.entry.payee or '', real_posting.entry.narration]),
                                          real_posting.posting.position,
                                          real_posting.balance,
                                          ))


    # find_unique_templates(entries)


    # Print all the balances
    if 0:
        maxlen = max(map(len, accounts_map))
        for account, inventory in sorted(accounts_map.items()):
            print("{:{:d}s} {}".format(account, maxlen, inventory))


    # for txn in filter_type(ledger.entries, Transaction):
    #     if not re.search('GOOGLE INC', txn.description):
    #         continue
    #     print('-' * 80)
    #     print(pretty_transaction(txn))
    #     residual = compute_residual(txn.postings)
    #     print(residual)


    if opts.verbose:
        for txn in ledger.entries:
            print(pretty_transaction(txn))

    # print_tags(ledger.entries)


def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)


def unique_alias(account):
    if (account.type == 'Expenses' and
        not re.search(':Taxes:', account.name)):
        return 'Expenses:*'
    else:
        return account.name


def find_unique_templates(entries):
    """Filter out transactions and group them by types of accounts transacted."""

    groups = defaultdict(list)
    for entry in filter_type(entries, Transaction):
        account_names = frozenset(sorted(unique_alias(posting.account)
                                         for posting in entry.postings))
        groups[account_names].append(entry)

    print(len(groups))

    for account_names, entry_list in sorted(groups.items(), key=lambda x: len(x[1]), reverse=True):
        print(tuple(sorted(account_names, key=data.account_names_sortkey)), len(entry_list))




if __name__ == '__main__':
    main()
