#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict

import beancount2.parser
from beancount2 import checks
from beancount2 import utils
from beancount2 import data
from beancount2 import realization
from beancount2.parser import *
from beancount2.inventory import Inventory
from beancount2.data import render_fileloc


#-------------------------------------------------------------------------------


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)






#-------------------------------------------------------------------------------

def print_entries_by_date(entries):
    prev_date = None
    for entry in entries:
        if prev_date != entry.date:
            print()
            prev_date = entry.date
        print(entry)

def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    with utils.print_time('parse'):
        contents = beancount2.parser.parse(opts.filename)

    # print_entries_by_date(contents.entries)

    with utils.print_time('check'):

        # Run the checks.
        check_errors = checks.check(contents.entries, contents.accounts)

        # Report all the basic errors.
        for error in check_errors:
            print('{} {}'.format(render_fileloc(error.fileloc),
                                 error.message))


    with utils.print_time('realize'):
        real_accounts, real_errors = realization.realize(contents.entries, check=True)

    real_account = real_accounts['Assets:CA:RBC-Investing:RRSP']

    if 0:
        print('--------------------------------------------------------------------------------')
        for real_posting in real_account.postings:
            balance = getattr(real_posting, 'balance', None)
            if balance:
                print(real_posting.entry.date, balance)
        print('--------------------------------------------------------------------------------')

    # Report all the realization errors.
    for error in real_errors:
        print('{} {}'.format(render_fileloc(error.fileloc),
                             error.message))

    realization.dump_tree_balances(real_accounts, sys.stdout)

    # Sum up all the amounts for the trial balance.
    total_balance = Inventory()
    for account_type in ('Assets', 'Liabilities', 'Equity', 'Income', 'Expense'):
        trial_balance = Inventory()
        for real_account in real_accounts.values():
            if not real_account.name.startswith(account_type):
                continue

            for real_posting in reversed(real_account.postings):
                if isinstance(real_posting, realization.RealPosting):
                    break
            else:
                continue
            # print('{:64} {}'.format(real_account.name, real_posting.balance))
            trial_balance += real_posting.balance

        print(account_type)
        print(sorted(trial_balance.get_costs(), key=data.amount_sortkey))
        print()

        total_balance += trial_balance

    print('TOTAL')
    print(sorted(total_balance.get_costs(), key=data.amount_sortkey))
    print()

    # List positions.
    print("List of positions:")
    for position in total_balance.get_positions():
        if position.lot.cost or position.lot.lot_date:
            cost = position.get_cost()
            print(('{p.number:12.2f} {p.lot.currency:8} '
                   '{p.lot.cost.number:12.2f} {p.lot.cost.currency:8} '
                   '{c.number:12.2f} {c.currency:8}').format(p=position, c=cost))
    print()


    if 0:
        real_account = real_accounts['Assets:Cash']
        for real_posting in real_account.postings:
            print('{} {:48} {:72} {:72}'.format(real_posting.entry.date,
                                          ' | '.join([real_posting.entry.payee or '', real_posting.entry.narration]),
                                          real_posting.posting.position,
                                          real_posting.balance,
                                          ))



    # with print_time('realize'):
    #     accounts_map = test_realize(entries)

    # find_unique_templates(entries)


    #if 0:
        # account = ledger.accounts.get('Assets:CA:RBC-Investing:RRSP:AIS512')
        # print(account.name)
        # print(account.parent.name)
        # print(account.parent.parent.name)
        # print(account.parent.parent.parent.parent.parent.name)



    # Print all the balances
    if 0:
        maxlen = max(map(len, accounts_map))
        for account, inventory in sorted(accounts_map.items()):
            print("{:{:d}s} {}".format(account, maxlen, inventory))

    # for txn in filter_type(ledger.entries, Transaction):
    #     if not re.search('GOOGLE INC', txn.description):
    #         continue
    #     print('-' * 80)
    #     print(pretty_transaction(txn))
    #     residual = compute_residual(txn.postings)
    #     print(residual)

    if opts.verbose:
        for txn in ledger.entries:
            print(pretty_transaction(txn))

    # print_tags(ledger.entries)


def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)


def unique_alias(account):
    if (account.type == 'Expenses' and
        not re.search(':Taxes:', account.name)):
        return 'Expenses:*'
    else:
        return account.name


def find_unique_templates(entries):
    """Filter out transactions and group them by types of accounts transacted."""

    groups = defaultdict(list)
    for entry in filter_type(entries, Transaction):
        account_names = frozenset(sorted(unique_alias(posting.account)
                                         for posting in entry.postings))
        groups[account_names].append(entry)

    print(len(groups))

    for account_names, entry_list in sorted(groups.items(), key=lambda x: len(x[1]), reverse=True):
        print(tuple(sorted(account_names, key=data.account_names_sortkey)), len(entry_list))




if __name__ == '__main__':
    main()
