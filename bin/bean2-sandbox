#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict

import beancount2.parser
from beancount2 import checks
from beancount2 import utils
from beancount2 import data
from beancount2 import realization
from beancount2.parser import *
from beancount2.inventory import Inventory


#-------------------------------------------------------------------------------


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)






#-------------------------------------------------------------------------------

def print_entries_by_date(entries):
    prev_date = None
    for entry in entries:
        if prev_date != entry.date:
            print()
            prev_date = entry.date
        print(entry)

def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    with utils.print_time('parse'):
        contents = beancount2.parser.parse(opts.filename)

    # print_entries_by_date(contents.entries)

    with utils.print_time('check'):

        # Run the checks.
        errors = checks.check(contents.entries, contents.accounts)

        # Report all the errors.
        for error in errors:
            print('{} {}'.format(checks.render_fileloc(error.fileloc),
                                 error.message))


    with utils.print_time('realize'):
        real_accounts = realization.realize(contents.entries)

        if 1:
            def render_inventory(real_account):
                if real_account.postings:
                    return '        {:32s}'.format(real_account.postings[-1].inventory)

            real_accounts.dump(sys.stdout, render_inventory)

        # real_account = real_accounts['Assets:Cash']
        # for real_posting in real_account.postings:
        #     print('{} {:48} {:72} {:72}'.format(real_posting.entry.date,
        #                                   ' | '.join([real_posting.entry.payee or '', real_posting.entry.narration]),
        #                                   real_posting.posting.position,
        #                                   real_posting.inventory,
        #                                   ))



    # with print_time('realize'):
    #     accounts_map = test_realize(entries)

    # find_unique_templates(entries)


    #if 0:
        # account = ledger.accounts.get('Assets:CA:RBC-Investing:RRSP:AIS512')
        # print(account.name)
        # print(account.parent.name)
        # print(account.parent.parent.name)
        # print(account.parent.parent.parent.parent.parent.name)



    # Print all the balances
    if 0:
        maxlen = max(map(len, accounts_map))
        for account, inventory in sorted(accounts_map.items()):
            print("{:{:d}s} {}".format(account, maxlen, inventory))

    # for txn in filter_type(ledger.entries, Transaction):
    #     if not re.search('GOOGLE INC', txn.description):
    #         continue
    #     print('-' * 80)
    #     print(pretty_transaction(txn))
    #     residual = compute_residual(txn.postings)
    #     print(residual)

    if opts.verbose:
        for txn in ledger.entries:
            print(pretty_transaction(txn))

    # print_tags(ledger.entries)


def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)


def unique_alias(account):
    if (account.type == 'Expenses' and
        not re.search(':Taxes:', account.name)):
        return 'Expenses:*'
    else:
        return account.name


def find_unique_templates(entries):
    """Filter out transactions and group them by types of accounts transacted."""

    groups = defaultdict(list)
    for entry in filter_type(entries, Transaction):
        account_names = frozenset(sorted(unique_alias(posting.account)
                                         for posting in entry.postings))
        groups[account_names].append(entry)

    print(len(groups))

    for account_names, entry_list in sorted(groups.items(), key=lambda x: len(x[1]), reverse=True):
        print(tuple(sorted(account_names, key=data.account_names_sortkey)), len(entry_list))




if __name__ == '__main__':
    main()
