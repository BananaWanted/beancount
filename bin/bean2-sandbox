#!/usr/bin/env python3
"""Various tests for beancount2.
(This is the main test program I fiddle with during development.)
"""
import datetime
import argparse
import contextlib
import io
import re
import sys
import time
from collections import defaultdict, namedtuple

import pandas
import matplotlib; matplotlib.use('agg')
from matplotlib import pyplot

import beancount2.parser
from beancount2.utils.bisect_key import bisect_left_withkey
from beancount2 import validation
from beancount2 import utils
from beancount2 import data
from beancount2 import realization
from beancount2.parser import *
from beancount2.inventory import Inventory
from beancount2 import summarize
from beancount2.data import render_fileloc



# A generic tuple to return various data by account type.
AccountTypeData = namedtuple('AccountTypeData', 'Assets Liabilities Equity Income Expenses')


def compute_balance_by_type(real_accounts, date):
    """Compute the total balance for each account type, evaluated at the given
    date. Returns a tuple with an inventor for each accoutn type."""

    balances = {typename: Inventory()
                for typename in AccountTypeData._fields}
    for real_account in real_accounts.values():
        if real_account.postings:
            typename = data.account_type(real_account.name)
            balance = realization.find_balance(real_account, date)
            balances[typename] += balance

    return AccountTypeData(**balances)


def compute_yearly_balances(real_accounts):
    """Given a realization, compute the yearly balances of each account type."""

    data = {}
    for balance_date in (datetime.date(year, 1, 1) for year in range(2004, 2015)):
        balances = compute_balance_by_type(real_accounts, balance_date)
        rows = []
        for account_type, balance in balances._asdict().items():
            costs = balance.get_cost().get_amounts()
            index = [cost.currency for cost in costs]
            series = pandas.Series([cost.number for cost in costs], index=index)
            rows.append(series)
        date_data = pandas.DataFrame(rows, index=AccountTypeData._fields)
        data[balance_date] = date_data

    return pandas.Panel.from_dict(data)


def check_equity_balances(real_accounts):
    """Try to figure out which method is best to summarize income/expenses into equity.
    Comparing (I+X) with (A+L), they really should be equal."""

    year_range = range(2004, 2015)
    for balance_date in (datetime.date(year, 1, 1) for year in year_range):
        print('------------------------', balance_date)
        balances = compute_balance_by_type(real_accounts, balance_date)

        balsheet_inventory = balances.Assets + balances.Liabilities + balances.Equity
        income_inventory = balances.Income + balances.Expenses

        print('A+L+E     (cost): {}'.format(balsheet_inventory.get_cost()))
        print('I+X       (cost): {}'.format(income_inventory.get_cost()))
        print('A+L+E+I+X (cost): {}'.format((balsheet_inventory + income_inventory).get_cost()))

        # We need to synthesize a transaction here instead of doing this.
        conversions = -(balsheet_inventory + income_inventory)
        print('Conversions:   {}'.format(conversions.get_cost()))
        balsheet_inventory += conversions.get_cost()

        assert (balsheet_inventory + income_inventory).get_cost().is_empty()
        # print('A+L+E+I+X (pos) ', (balsheet_inventory + income_inventory))
        print('A+L+E+I+X (cost)', (balsheet_inventory + income_inventory).get_cost())

        balances_fwd = compute_balance_by_type(real_accounts, balance_date + datetime.timedelta(days=365))
        print('balances_fwd', balances_fwd)
        conversions_fwd = -(balances_fwd.Assets +
                            balances_fwd.Liabilities +
                            balances_fwd.Equity +
                            balances_fwd.Income +
                            balances_fwd.Expenses)
        print('conversions_fwd', conversions_fwd)
        print('conversions_diff', conversions.get_cost() + (-conversions_fwd).get_cost())














# c. conversion adjustment

# 3. Insert a conversion error entry.


#-------------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(__doc__.strip())

    parser.add_argument('filename',
                        help='Beancount input filename.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print out verbose information")

    parser.add_argument('-l', '--dump-lexer', action='store_true',
                        help="Run the lexer only, output the tags.")

    opts = parser.parse_args()

    with utils.print_time('parse'):
        contents = beancount2.parser.parse(opts.filename)
        parse_errors = contents.parse_errors
        data.print_errors(contents.parse_errors)

    with utils.print_time('pad'):
        entries, pad_errors = realization.pad(contents.entries)
        data.print_errors(pad_errors)

    with utils.print_time('validation'):
        valid_errors = validation.validate(entries, contents.accounts)
        data.print_errors(valid_errors)

    with utils.print_time('realize'):
        real_accounts, real_errors = realization.realize(entries, do_check=True)
        data.print_errors(real_errors)

    if opts.verbose:
        realization.dump_tree_balances(real_accounts, sys.stdout)



    if 1:
        # Test out transfer and summarization, together.
        account_transfer = data.Account('Equity:PreviousEarnings', 'Equity')
        account_opening = data.Account('Equity:OpeningBalances', 'Equity')
        report_date = datetime.date(2013, 1, 1)
        tran_entries = summarize.transfer(entries, report_date,
                                          data.is_income_statement_account, account_transfer)

        before_entries, after_entries = summarize.summarize(tran_entries, report_date, account_opening)
        sum_entries = before_entries # + after_entries

        out = open('/tmp/out.log', 'w')
        for entry in sum_entries:
            print(entry, file=out)

        real_accounts, real_errors = realization.realize(sum_entries, do_check=True)
        assert not real_errors

        realization.dump_tree_balances(real_accounts, sys.stdout)


    if 0:
        # Test out summarization.
        real_log = open('/tmp/real.log', 'w')
        realization.dump_tree_balances(real_accounts, real_log)
        total_balance = realization.compute_total_balance(entries)
        print("TRIAL_BALANCE", total_balance, file=real_log)
        print("TRIAL_BALANCE (cost)", total_balance.get_cost(), file=real_log)


        with utils.print_time('summarize'):
            account_opening = data.Account('Equity:OpeningBalances', 'Equity')
            before_entries, after_entries = summarize.summarize(entries, datetime.date(2012, 1, 1), account_opening)
            sum_entries = before_entries + after_entries
            sumreal_accounts, sumreal_errors = realization.realize(sum_entries, do_check=True)
            data.print_errors(sumreal_errors)

            sum_log = open('/tmp/sum.log', 'w')
            realization.dump_tree_balances(sumreal_accounts, sum_log)
            total_balance = realization.compute_total_balance(sum_entries)
            print("TRIAL_BALANCE", total_balance, file=sum_log)
            print("TRIAL_BALANCE (cost)", total_balance.get_cost(), file=sum_log)



    if 0:
        check_equity_balances(real_accounts)

    if 0:
        yearly = compute_yearly_balances(real_accounts)

        print(yearly.to_frame().to_string())
        # print(yearly.major_xs('Assets').to_string())
        USD = yearly.minor_xs('USD')
        CAD = yearly.minor_xs('CAD')
        total = USD + CAD
        print(total.to_string())
        # print(yearly.minor_xs('CAD').to_string())

        sums = total.sum(axis=0)
        print(sums.to_string())
        total.plot()
        pyplot.show()

    if 0:
        # Sum up all the amounts for the trial balance.
        total_balance = Inventory()
        for account_type in ('Assets', 'Liabilities', 'Equity', 'Income', 'Expense'):
            trial_balance = Inventory()
            for real_account in real_accounts.values():
                if not real_account.name.startswith(account_type):
                    continue

                for real_posting in reversed(real_account.postings):
                    if isinstance(real_posting, realization.RealPosting):
                        break
                else:
                    continue
                # print('{:64} {}'.format(real_account.name, real_posting.balance))
                trial_balance += real_posting.balance

            print(account_type)
            print(sorted(trial_balance.get_cost().get_amounts(), key=data.amount_sortkey))
            print()

            total_balance += trial_balance

        print('TOTAL')
        print(sorted(total_balance.get_cost().get_amounts(), key=data.amount_sortkey))
        print()




def print_debug_account(real_account):
    for real_posting in real_account.postings:
        print('{} {:48} {:72} {:72}'.format(real_posting.entry.date,
                                      ' | '.join([real_posting.entry.payee or '', real_posting.entry.narration]),
                                      real_posting.posting.position,
                                      real_posting.balance,
                                      ))


def pretty_transaction(txn):
    """Format nicely a transaction for printing. Returns a string"""
    lines = ["{} {} {} | {} {}".format(txn.date, txn.flag, txn.payee or '', txn.description,
                                         ','.join(txn.tags))]
    for post in txn.postings:
        lines.append("  {:1} {:58s} {} {} {}".format(
            chr(post.flag) if post.flag else '', post.account.name, post.position.number, post.position.lot, post.price or ''))
    return '\n'.join(lines)


def print_locations(entries):
    for e in entries:
        if isinstance(e, Event) and e.type == 'location':
            print (e)


def print_open_close(entries):

    accmap = defaultdict(list)
    for e in entries:
        if isinstance(e, (Open, Close)):
            accmap[e.account].append(e)

    for account, openclose in accmap.items():
        if is_balance_sheet_account(account):
            print(account)
            for e in openclose:
                print('  ', e)


def print_tags(entries):

    tagsmap = defaultdict(list)
    for e in entries:
        if isinstance(e, Transaction):
            for tag in e.tags:
                tagsmap[tag].append(e)

    for tag, entry_list in tagsmap.items():
        print
        print(tag)
        for e in entry_list:
            print('  ', e)


def unique_alias(account):
    if (account.type == 'Expenses' and
        not re.search(':Taxes:', account.name)):
        return 'Expenses:*'
    else:
        return account.name


def find_unique_templates(entries):
    """Filter out transactions and group them by types of accounts transacted."""

    groups = defaultdict(list)
    for entry in filter_type(entries, Transaction):
        account_names = frozenset(sorted(unique_alias(posting.account)
                                         for posting in entry.postings))
        groups[account_names].append(entry)

    print(len(groups))

    for account_names, entry_list in sorted(groups.items(), key=lambda x: len(x[1]), reverse=True):
        print(tuple(sorted(account_names, key=data.account_names_sortkey)), len(entry_list))



def print_entries_by_date(entries):
    prev_date = None
    for entry in entries:
        if prev_date != entry.date:
            print()
            prev_date = entry.date
        print(entry)

def measure_balance_total(entries):
    # For timing only.
    with utils.print_time('balance_all'): # 89ms... okay.
        balance = Inventory()
        for entry in utils.filter_type(entries, data.Transaction):
            for posting in entry.postings:
                balance.add_position(posting.position)


def print_real_accounts(real_accounts):
    for real_account in sorted(real_accounts.values()):
        print('{:56} {}'.format(real_account.name, real_account.account))


def print_real_postings(real_account):
    print('--------------------------------------------------------------------------------')
    for real_posting in real_account.postings:
        balance = getattr(real_posting, 'balance', None)
        if balance:
            print(real_posting.entry.date, balance)
    print('--------------------------------------------------------------------------------')


if __name__ == '__main__':
    main()
