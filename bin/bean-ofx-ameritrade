FIXME incomplete, was just starting to play with OFX download
AMeritrade doesn't allow click to download

#!/usr/bin/python
import time, os, httplib, urllib2
import sys

join = str.join

sites = {
    "MYCreditUnion": {
        "caps": [ "SIGNON", "BASTMT" ],
        "fid": "31337",     # ^- this is what i added, for checking/savings/debit accounts- think "bank statement"
        "fiorg": "MyCreditUnion", 
        "url": "https://ofx.mycreditunion.org",
        "bankid": "21325412453", # bank routing #
        },    
    "vanguard": {
        "caps": [ "SIGNON", "INVSTMT"],
        "fiorg": "vanguard.com",
        "url" : "https://vesnc.vanguard.com/us/OfxDirectConnectServlet",
        },
    "schwab_brokerage": {
        "caps": [ "SIGNON", "INVSTMT"],
        "fiorg": "SCHWAB>COM",
        "url": "https://ofx.schwab.com/cgi_dev/ofx_server",
        },
    "schwab_bank": {
        "caps": [ "SIGNON", "BASTMT"],
        "fid" : "101",
        "fiorg": "ISC",
        "url": "https://ofx.schwab.com/bankcgi_dev/ofx_server",
        "bankid" : "121202211",
        },
    "edward_jones" : {
        "caps" : [ "SIGNON", "INVSTMT"],
        "fiorg" : "www.edwardjones.com",
        "url" : "https://ofx.edwardjones.com",
        }
    }
                                                
def _field(tag,value):
    return "<"+tag+">"+value

def _tag(tag,*contents):
    return join("\r\n",["<"+tag+">"]+list(contents)+["</"+tag+">"])

def _date():
    return time.strftime("%Y%m%d%H%M%S",time.localtime())

def _genuuid():
    return os.popen("uuidgen").read().rstrip().upper()

class OFXClient:
    """Encapsulate an ofx client, config is a dict containg configuration"""
    def __init__(self, config, user, password):
        self.password = password
        self.user = user
        self.config = config
        self.cookie = 3
        config["user"] = user
        config["password"] = password
        if not config.has_key("appid"):
            config["appid"] = "QWIN"  # i've had to fake Quicken to actually get my unwilling test server to talk to me
            config["appver"] = "1200"

    def _cookie(self):
        self.cookie += 1
        return str(self.cookie)

    """Generate signon message"""
    def _signOn(self):
        config = self.config
        fidata = [ _field("ORG",config["fiorg"]) ]
        if config.has_key("fid"):
            fidata += [ _field("FID",config["fid"]) ]
        return _tag("SIGNONMSGSRQV1",
                    _tag("SONRQ",
                         _field("DTCLIENT",_date()),
                         _field("USERID",config["user"]),
                         _field("USERPASS",config["password"]),
                         _field("LANGUAGE","ENG"),
                         _tag("FI", *fidata),
                         _field("APPID",config["appid"]),
                         _field("APPVER",config["appver"]),
                         ))

    def _acctreq(self, dtstart):
        req = _tag("ACCTINFORQ",_field("DTACCTUP",dtstart))
        return self._message("SIGNUP","ACCTINFO",req)

# this is from _ccreq below and reading page 176 of the latest OFX doc.
    def _bareq(self, acctid, dtstart, accttype):
        config=self.config
    req = _tag("STMTRQ",
           _tag("BANKACCTFROM",
               _field("BANKID",sites [argv[1]] ["bankid"]),
                _field("ACCTID",acctid),
            _field("ACCTTYPE",accttype)),
           _tag("INCTRAN",
               _field("DTSTART",dtstart),
            _field("INCLUDE","Y")))
    return self._message("BANK","STMT",req)
    
    def _ccreq(self, acctid, dtstart):
        config=self.config
        req = _tag("CCSTMTRQ",
                   _tag("CCACCTFROM",_field("ACCTID",acctid)),
                   _tag("INCTRAN",
                        _field("DTSTART",dtstart),
                        _field("INCLUDE","Y")))
        return self._message("CREDITCARD","CCSTMT",req)

    def _invstreq(self, brokerid, acctid, dtstart):
        dtnow = time.strftime("%Y%m%d%H%M%S",time.localtime())
        req = _tag("INVSTMTRQ",
                   _tag("INVACCTFROM",
                      _field("BROKERID", brokerid),
                      _field("ACCTID",acctid)),
                   _tag("INCTRAN",
                        _field("DTSTART",dtstart),
                        _field("INCLUDE","Y")),
                   _field("INCOO","Y"),
                   _tag("INCPOS",
                        _field("DTASOF", dtnow),
                        _field("INCLUDE","Y")),
                   _field("INCBAL","Y"))
        return self._message("INVSTMT","INVSTMT",req)

    def _message(self,msgType,trnType,request):
        config = self.config
        return _tag(msgType+"MSGSRQV1",
                    _tag(trnType+"TRNRQ",
                         _field("TRNUID",_genuuid()),
                         _field("CLTCOOKIE",self._cookie()),
                         request))
    
    def _header(self):
        return join("\r\n",[ "OFXHEADER:100",
                           "DATA:OFXSGML",
                           "VERSION:102",
                           "SECURITY:NONE",
                           "ENCODING:USASCII",
                           "CHARSET:1252",
                           "COMPRESSION:NONE",
                           "OLDFILEUID:NONE",
                           "NEWFILEUID:"+_genuuid(),
                           ""])

    def baQuery(self, acctid, dtstart, accttype):
        """Bank account statement request"""
        return join("\r\n",[self._header(),
                       _tag("OFX",
                                self._signOn(),
                                self._bareq(acctid, dtstart, accttype))])
                        
    def ccQuery(self, acctid, dtstart):
        """CC Statement request"""
        return join("\r\n",[self._header(),
                          _tag("OFX",
                               self._signOn(),
                               self._ccreq(acctid, dtstart))])

    def acctQuery(self,dtstart):
        return join("\r\n",[self._header(),
                          _tag("OFX",
                               self._signOn(),
                               self._acctreq(dtstart))])

    def invstQuery(self, brokerid, acctid, dtstart):
        return join("\r\n",[self._header(),
                          _tag("OFX",
                               self._signOn(),
                               self._invstreq(brokerid, acctid,dtstart))])

    def doQuery(self,query,name):
        # N.B. urllib doesn't honor user Content-type, use urllib2
        request = urllib2.Request(self.config["url"],
                                  query,
                                  { "Content-type": "application/x-ofx",
                                    "Accept": "*/*, application/x-ofx"
                                  })
        if 1:
            f = urllib2.urlopen(request)
            response = f.read()
            f.close()
            
            f = file(name,"w")
            f.write(response)
            f.close()
    else:
            print request
            print self.config["url"], query
        
        # ...

import getpass
from Crypto.Cipher import AES

argv = sys.argv
if __name__=="__main__":
    # check for correct incantation
    if len(argv) < 3:
        print "Usage:",sys.argv[0], "site user [account] [dtstart] [CHECKING/SAVINGS/.. if using BASTMT]"
        print "available sites:",join(", ",sites.keys())
        sys.exit()

    passwd = ""
    # get encrypted passwords from file passwords
    try:
        f = open("passwords", "r")
        ciphertext = f.read()
        f.close()   
    # handle any errors opening password file
    except IOError:
        print "Stored passwords file not found!  Please enter password for ", argv[1]
        passwd = getpass.getpass()
    
    #for param in os.environ.keys():
    #    print "%20s %s" % (param,os.environ[param])

    if passwd == "":        
        # get a password to decrypt the file
        if "PASS" in os.environ:
            print "Using environmental variable $PASS to decrypt passwords file"
            passwd = os.environ["PASS"]
        else:            
            print "Stored password file found!  Enter password to decrypt stored password file"
            passwd = getpass.getpass()
        
        # set up decryption
        obj = AES.new(passwd.ljust(16),AES.MODE_ECB)
        dictstr = obj.decrypt(ciphertext)
    
        # convert the stored dict definition string to an actual dict
        try:
            passdict = eval(dictstr)        
        except SyntaxError:
            print "Invalid Password!  Password file not decrypted successfully!"
            sys.exit()

        # do another sanity check
        if passdict["decryption"] != "OK" :
            print "Invalid Password!  Password file not decrypted successfully!"
            sys.exit()
        
        # look for stored password for desired account
        if not argv[1] in passdict :
            print "Password for ", argv[1], " not found in stored password directory!"
            passwd = getpass.getpass()
        else:
            passwd = passdict[argv[1]]
    
    # construct time range
    #dtstart = time.strftime("%Y%m%d",time.localtime(time.time()-31*86400))   
    dtstart = "19700101000000"
    dtnow = time.strftime("%Y%m%d",time.localtime())

    # set up OFXClient class
    client = OFXClient(sites[argv[1]], argv[2], passwd)
    
    if len(argv) < 4:
        # no account number passed.  get accounts from FI
        query = client.acctQuery(dtstart)
        client.doQuery(query, argv[1]+"_acct.ofx") 
    else:
        # start date passed as 5th argument
        if len(argv) > 4:
            dtstart = sys.argv[4]        

        if "CCSTMT" in sites[argv[1]]["caps"]:
            query = client.ccQuery(sys.argv[3], dtstart)
        elif "INVSTMT" in sites[argv[1]]["caps"]:
            query = client.invstQuery(sites[argv[1]]["fiorg"], sys.argv[3], dtstart)
        elif "BASTMT" in sites[argv[1]]["caps"]:
            if len(argv) < 6 :
                print "Bank Account Type not Specified for statement download!"
                sys.exit()
            query = client.baQuery(sys.argv[3], dtstart, argv[5])
        client.doQuery(query, argv[1]+argv[3]+"-"+dtnow+".ofx")


# Code to generate passwords file
#encpass = getpass.getpass()
