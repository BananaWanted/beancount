#!/usr/bin/env python3
"""Publish a CSV file to a Google Spreadsheet sheet.

This is a convenient script to update an existing Google Spreadsheet document
with the contents of a CSV file.

NOTE: This script replaces and obsoletes 'upload-csv-to-google-sheet'.

For example, this invocation creates a new Google Sheet doc and upload the
contents of the CSV files to sheets named 'apples' and 'oranges':

  upload-to-sheets apples.csv oranges.csv

You can override the name of the sheets created by appending a colon and the
name, like this:

  upload-to-sheets apples.csv:Apples oranges.csv:Oranges

If you'd like to upload the sheets in an existing document, provide it as an
option:

  upload-to-sheets --docid=1xcCjHM-Tjvkwq3R5NuHCv0dGj1ubo0Y09DfGn8HRMLY apples.csv oranges.csv

Note that if you do this and there are existing sheets with the same names, e.g.
"apples", the contents of these sheets will be replaced by the uploaded
contents. All the other sheets will remain untouched. This is designed so that
you can manually craft a custom spreadsheet and upload only some of it sheets
with contents derived from another program (e.g. Beancount).

This script only requires the latest and official Google client API libraries
(it does not need gdata nor Python wrappers for sheets). It uses the v4 Sheets
API (current as of 2016-12-15). You will need to have an installation of the
following libraries for this to work:

 * apiclient (Google Python client API)
 * oauth2client
 * httplib2

Moreover, you will need to enable the Google Sheets API in the developer console
and download the Client Secrets that Google provides to ~/.google-apis.json. (You
can override this location with the GOOGLE_APIS environment variable.)
"""
__author__ = 'Martin Blais <blais@furius.ca>'

import argparse
import bisect
import collections
import csv
import codecs
import logging
import os
import re
import string
import unittest
from os import path

from oauth2client import client
from oauth2client import tools
from oauth2client import file
import httplib2
from apiclient import discovery


# Location of your secrets file.
SECRETS_FILENAME = os.environ.get('GOOGLE_APIS',
                                  path.expanduser('~/.google-apis.json'))


# Location to store credentials for reuse between invocations.
STORAGE_FILENAME = os.environ.get('GOOGLE_STORAGE',
                                  path.expanduser('~/.google-storage.json'))


# The name of a sheet left as the unique sheet temporarily, while creating a new
# spreadsheet.
EMPTY_SHEET_TITLE = '__EMPTY__'


def get_credentials(scopes, args):
    """Authenticate via oauth2 and cache credentials to a file (or refresh them).

    Args:
      scopes: A string or a list of strings, the scopes to get credentials for.
      args: An argparse option values object.
    Returns:
      An authenticated http client object.
    """
    flow = client.flow_from_clientsecrets(SECRETS_FILENAME, scope=scopes)
    storage = file.Storage(STORAGE_FILENAME)
    credentials = storage.get()
    if not credentials or credentials.invalid:
        credentials = tools.run_flow(flow, storage, args)
        storage.put(credentials)
    http = httplib2.Http()
    credentials.authorize(http)
    if credentials.access_token_expired:
        credentials.refresh(http)
    return credentials, http


def csv_unicode_reader(source, **kwargs):
    """Encode unicode source to UTF8 because the csv module does not support unicode.

    Args:
      source: An iterable sequence of unicode objects.
      **kwargs: Arguments for csv.reader().
    Yields:
      Rows of unicode objects.
    """
    lineiter = (line.encode('utf-8') for line in source)
    csv_reader = csv.reader(lineiter, **kwargs)
    for row in csv_reader:
        yield [cell.decode('utf-8') for cell in row]


def pop_alist(items, key, default=None):
    """Remove the first found element in a multi-association list.

    Args:
      items: An iterable sequence of pairs of items.
      key: A key for those pairs.
    Returns:
      The value associated with the first matching key in the list, or the
      default value if not found.
    """
    for index, item in enumerate(items):
        if item[0] == key:
            del items[index]
            return item
    else:
        return default


def sheet_range(title, nrows, ncols):
    """Build up the full range of a sheet for some size of rows and columns.

    Args:
      title: A string, the name of the sheet in the doc.
      nrows: An integer, the number of rows to resize to.
      ncols: An integer, the number of columns to resize to.
    Returns:
      A string repreenting the full range of this sheet.
    """
    return '{}!A1:{}{}'.format(title, string.ascii_uppercase[ncols-1], nrows)


def create_doc(service):
    """Create a new spreadsheet with an empty initial sheet.

    The empty initial sheet gets deleted later. We cannot create a new
    spreadsheet without at least a single sheet in it.

    Args:
      service: A Google sheets v4 API Resource object.
    Returns:
      A string, the id of the spreadsheet drive document. Something that
      looks like '1xcCjHM-Tjvkwq3R5NuHCv0dGj1ubo0Y09DfGn8HRMLY'.
    """
    resp = service.spreadsheets().create(body={
        'sheets': {'properties': {'title': EMPTY_SHEET_TITLE}}}).execute()
    return resp['spreadsheetId']


def delete_empty_sheets(service, docid):
    """Remove empty sheets created only temporarily.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
    """
    requests = [{'deleteSheet': {'sheetId': sheetId}}
                for title, sheetId in get_sheets(service, docid)
                if title == EMPTY_SHEET_TITLE]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def get_sheets(service, docid):
    """Get the sheet titles and ids of the given spreadsheet.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
    Returns:
      A list of (title string, sheet-id integer) pairs, in the order that they appear in
      the document.
    """
    resp = service.spreadsheets().get(spreadsheetId=docid).execute()
    return [(sheet['properties']['title'], sheet['properties']['sheetId'])
            for sheet in resp['sheets']]


def add_sheet(service, docid, title):
    """Create a new sheet in an existing doc.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      title: A string, the name of the new sheet to create.
    Returns:
      An integer, the sheet-id of the newly created sheet.
    """
    requests = [{'addSheet': {'properties': {'title': title}}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()
    return resp['replies'][0]['addSheet']['properties']['sheetId']


def get_sheet_size(service, docid, title):
    """Get the size of a spreadsheet.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      title: A string, the name of the sheet in the doc.
    Returns:
      A pair of (num-rows, num-columns) integers, the size of the sheet.
    """
    resp = service.spreadsheets().get(spreadsheetId=docid,
                                      ranges=title).execute()
    gridProperties = resp['sheets'][0]['properties']['gridProperties']
    return (gridProperties['rowCount'], gridProperties['columnCount'])


def clear_sheet(service, docid, title, nrowcols=None):
    """Clear the sheet.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      title: A string, the name of the sheet in the doc.
    """
    if nrowcols is None:
        nrows, ncols = get_sheet_size(service, docid, title)
    else:
        nrows, ncols = nrowcols
    srange = sheet_range(title, nrows, ncols)
    resp = service.spreadsheets().values().clear(spreadsheetId=docid,
                                                 range=srange,
                                                 body={}).execute()


def resize_sheet(service, docid, sheetId, title, nrows, ncols):
    """Update the size of a sheet.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      sheetId: An integer, the id of the sheet in the doc.
      title: A string, the name of the sheet in the doc.
      nrows: An integer, the number of rows to resize to.
      ncols: An integer, the number of columns to resize to.
    """
    requests = [{
        'updateSheetProperties': {
            'properties': {
                'sheetId': sheetId,
                'title': title,  # Required, unfortunately.
                'gridProperties': {'rowCount': nrows,
                                   'columnCount': ncols}},
            'fields': '*'}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def auto_resize_sheet(service, docid, sheetId):
    """Auto-resize the spreadsheet based on the current data in it.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      sheetId: An integer, the id of the sheet in the doc.
    """
    requests = [{
        'autoResizeDimensions': {
            'dimensions': {
                'sheetId': sheetId,
                'dimension': 'COLUMNS'}}}]
    resp = service.spreadsheets().batchUpdate(spreadsheetId=docid,
                                              body={'requests': requests}).execute()


def update_sheet(service, docid, sheetId, title, filename):
    """Clear and replace the data in a sheet with that of a file.

    Args:
      service: A Google sheets v4 API Resource object.
      docid: The id of the spreadsheet drive document.
      sheetId: An integer, the id of the sheet in the doc.
      title: A string, the name of the sheet in the doc.
      filename: A string, the path to the CSV filename to load and upload.
    """
    # Load the CSV file into an array of rows.
    with open(filename, 'r') as csvfile:
        rows = csv_unicode_reader(csvfile)

    nrows = len(rows)
    ncols = max(len(row) for row in rows) if rows else 0

    # Note: Sizing down the sheet also deletes the values from the cells removed
    # automatically.
    resize_sheet(service, docid, sheetId, title, nrows, ncols)

    # Clear the remaining contents.
    clear_sheet(service, docid, title, (nrows, ncols))

    # Upload the new values.
    #
    # FIXME: Using an "updateCells" request in order to be able to set not only
    # the values would be an improvement and allow for much more control over
    # the formatting of numbers. It would be better not to use USER_ENTERED.
    srange = sheet_range(title, nrows, ncols)
    resp = service.spreadsheets().values().update(
        spreadsheetId=docid,
        range=srange,
        valueInputOption='USER_ENTERED',
        body={'range': srange,
              'values': rows}).execute()

    # Make sure the newly created sheet looks good by default, by sizing the
    # columns to fit the newly updated data.
    auto_resize_sheet(service, docid, sheetId)


def main():
    logging.basicConfig(level=logging.INFO, format='%(levelname)-8s: %(message)s')

    parser = argparse.ArgumentParser(description=__doc__.strip(),
                                     parents=[tools.argparser])

    parser.add_argument('filenames', nargs='+', action='store',
                        help=("CSV filenames[:name] to upload. "
                              "If 'name' is not provided, infer from the filename."))

    parser.add_argument('--docid', '--doc', '--id', '-d', dest='docid', action='store',
                        help="Spreadsheets doc id to update")

    args = parser.parse_args()

    # Discover the service.
    _, http = get_credentials('https://www.googleapis.com/auth/spreadsheets', args)
    url = discoveryServiceUrl='https://sheets.googleapis.com/$discovery/rest?version=v4'
    service = discovery.build('sheets', 'v4', http=http, discoveryServiceUrl=url)

    # Figure out what the name mappings should be, from the filenames (or
    # explicitly).
    new_sheets = []
    for filename in args.filenames:
        match = re.match('(.*):(.*)$', filename)
        if match:
            filename, sheet_name = (match.group(1), match.group(2))
        else:
            sheet_name = path.splitext(path.basename(filename))[0]
        new_sheets.append((sheet_name, filename))

    # Get or create the spreadsheet.
    if args.docid:
        created = False
        docid = args.docid
    else:
        created = True
        docid = create_doc(service)
        logging.info("Created doc: https://docs.google.com/spreadsheets/d/%s/", docid)

    # Get the existings sheets within (this also validates the existence of the
    # document).
    existing_sheets = get_sheets(service, docid)

    # Create new or match against existing sheets if necessary. This essentially
    # pairs up spreadsheets from the input to sheet-ids in the doc.
    sheets_alist = []
    for title, filename in new_sheets:
        sheetId = pop_alist(existing_sheets, title)
        if sheetId is None:
            sheetId = add_sheet(service, docid, title)
        sheets_alist.append((sheetId, title, filename))

    # Clear and replace the data in the given sheet with that of the given
    # filename.
    for sheetId, title, filename in sheets_alist:
        update_sheet(service, docid, sheetId, title, filename)

    # Clean up temporary sheets created for new documents only.
    if created:
        delete_empty_sheets(service, docid)


if __name__ == '__main__':
    main()
